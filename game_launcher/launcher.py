class GameLauncher:
    def __init__(self, root):
        self.launcher_start_time = time.time()
        self.root = root
        self.root.title("Game Launcher")
        self.root.configure(bg="#1e1e1e")
        self._resize_timer = None 
        self.root.bind("<Configure>", self._on_root_resize)
        self._button_icons = {}
        self._menu_icons = {} 
        self.start_up_time_points = {} 
        self.record_startup_time("init_start")
        self._load_icons() 
        self.local_settings = load_local_settings()
        self.current_section = "Strona Główna" 

        # --- NOWE ZMIANY: Dodaj flagi inicjalizacji stron tutaj ---
        self._library_initialized = False
        self._achievements_initialized = False
        self._news_initialized = False
        self._news_loaded = False # Nadal potrzebna dla danych newsów (oddzielna od _news_initialized)
        self._reminders_initialized = False
        self._settings_initialized = False
        self._roadmap_initialized = False
        self._stats_initialized = False
        # --- KONIEC NOWYCH ZMIAN ---
        # --- NOWE ZMIANY (Strona Wyboru Serwera - Inicjalizacja) ---
        self._server_selection_initialized = False # Flaga dla nowej strony
        # --- KONIEC NOWYCH ZMIAN ---

        # --- NOWE ZMIANY (Wielu Serwerów Czatu - Inicjalizacja) ---
        self.chat_servers_list = self.local_settings.get("chat_servers", [])
        self.active_chat_server_id = self.local_settings.get("active_chat_server_id")
        self.chat_auto_connect_to_default_var = tk.BooleanVar(value=self.local_settings.get("chat_auto_connect_to_default", True))

        self.chat_server_url = "http://127.0.0.1:5000" # Domyślny fallback
        self.current_server_credentials = {"email": "", "password": ""} # Dane dla aktywnego serwera
        # --- NOWE ZMIANY: Poprawne inicjalizowanie current_server_remember_credentials i auto_login ---
        self.current_server_remember_credentials = False # Domyślnie False
        self.current_server_auto_login = False         # Domyślnie False
        # --- KONIEC NOWYCH ZMIAN ---

        active_server_data = self._get_active_server_data()
        if active_server_data:
            self.chat_server_url = active_server_data.get("url", self.chat_server_url)
            creds = active_server_data.get("credentials", {})
            self.current_server_credentials["email"] = creds.get("email", "")
            self.current_server_credentials["password"] = creds.get("password", "")
            # --- NOWE ZMIANY: Poprawne wczytywanie remember_credentials i auto_login_to_server ---
            self.current_server_remember_credentials = active_server_data.get("remember_credentials", False)
            self.current_server_auto_login = active_server_data.get("auto_login_to_server", False)
            # --- KONIEC NOWYCH ZMIAN ---
        
        # `self.chat_server_url_var` jest teraz używane w dialogu edycji pojedynczego serwera,
        # ale docelowo dialogi będą operować na `self.chat_servers_list`.
        # Na razie możemy go zainicjować URL-em aktywnego serwera.
        if not hasattr(self, 'chat_server_url_var'): # Jeśli nie było wcześniej (np. po usunięciu z ustawień)
            self.chat_server_url_var = tk.StringVar(value=self.chat_server_url)
        else:
            self.chat_server_url_var.set(self.chat_server_url)
        # --- KONIEC NOWYCH ZMIAN ---
        self.sio = None
        self.chat_logged_in_user = None 
        self.chat_connected_to_server = False 
        self.chat_authenticated = False 
        self.chat_users = {} 
        self.active_chat_partner_id = None 
        self._last_open_chat_partner_id = None   # kto był otwarty poprzednio
        self.chat_messages = {}
        # --- NOWE ZMIANY (CHAT GRUPOWY - Etap 2/5 - Zmiana 1/5) ---
        # Będziemy używać 'u_' jako prefixu dla użytkowników i 'r_' dla pokoi,
        # aby uniknąć kolizji ID między user.id i room.id w IID Treeview.
        self.CHAT_PREFIX_USER = "u_"
        self.CHAT_PREFIX_ROOM = "r_"
        # Nowe słowniki do przechowywania danych o pokojach
        self.chat_rooms = {} # room_id: {name: ..., members: [...]}
        # Nowe dane, jeśli wybierzemy chat grupowy (nie pojedynczego partnera)
        self.active_chat_type = None # "user" or "room"
        self._current_chat_participants = {} # mapuje user_id na username dla aktywnego chatu grupowego
        # --- KONIEC NOWYCH ZMIAN ---
        self.unread_messages_count = {} 
        self.online_users = set()   # id zalogowanych użytkowników
        self._last_chat_message_search_term = "" # <-- DODAJ TO
        # --- NOWE ZMIANY: Atrybut dla oczekującego załącznika ---
        self._pending_chat_attachment = None # Będzie słownikiem {'filepath': ..., 'original_filename': ...} lub None
        # --- KONIEC NOWYCH ZMIAN ---
        # --- NOWE ZMIANY (Blokowanie użytkowników czatu) ---
        self.blocked_user_ids = set(self.local_settings.get("chat_blocked_user_ids", []))
        # --- KONIEC NOWYCH ZMIAN ---

        # --- NOWE ZMIANY (CHAT) ---
        self.typing_status = {} # {user_id: bool (is_typing), ...}
        self._typing_timeout_timer = None # Nowy timer dla wskaźnika pisania
        self._typing_sent_flag = False # Flaga, czy event 'typing_start' został już wysłany
        # --- KONIEC NOWYCH ZMIAN (CHAT) --
        # --- NOWE ZMIANY (CHAT) ---
        # Zainicjuj wszystkie StringVar dla pól logowania/rejestracji czatu na początku __init__
        self.chat_email_var = tk.StringVar()
        self.chat_password_var = tk.StringVar()
        self.chat_username_var = tk.StringVar()
        # --- KONIEC NOWYCH ZMIAN (CHAT) ---
        # --- NOWE ZMIANY (CHAT) ---
        # --- NOWE ZMIANY: Inicjalizacja StringVar dla checkboxów na podstawie danych aktywnego serwera ---
        # Usuwamy odczyt globalnych "chat_remember_me" i "chat_auto_login" z local_settings tutaj.
        # Zamiast tego używamy wartości wczytanych dla aktywnego serwera.
        self.chat_remember_me_var = tk.BooleanVar(value=self.current_server_remember_credentials)
        self.chat_auto_login_var = tk.BooleanVar(value=self.current_server_auto_login)
        # --- KONIEC NOWYCH ZMIAN ---
        # --- KONIEC NOWYCH ZMIAN (CHAT) ---
        # --- ZMIANA: Przenieś inicjalizację chat_dashboard_placeholder_id TUTAJ ---
        self.chat_dashboard_placeholder_id = "chat_dashboard_view" # Unikalne ID dla placeholderu
        # --- KONIEC ZMIANY ---
        self._rendered_chat_partner_id = None   # ID partnera, którego historia jest już na ekranie
        self.chat_page_size = 50
        self.chat_history_has_more = False
        self.chat_history_before = None
        self.chat_history_loading = False
        # --- NOWE ZMIANY ---
        self.MESSAGE_HIGHLIGHT_COLOR = "#FFD700" # Złoty kolor do podświetlania (można zmienić)
        self._rendered_message_widgets = {} # Słownik do mapowania message_id na widget dymka
        self._jump_target_message_id = None # ID wiadomości, do której chcemy przeskoczyć po przeładowaniu
        # --- KONIEC NOWYCH ZMIAN ---

        # --- KONIEC NOWYCH ZMIAN (CHAT) ---

        # --- NOWE ZMIANY ---
        # Zainicjuj wszystkie StringVar dla filtrów i stanów na początku __init__
        self.library_view_mode = tk.StringVar(value=self.local_settings.get("library_view_mode", "tiles"))
        self.filter_or_group_var = tk.StringVar(value="Wszystkie Gry") # Dla menu grup/filtrów
        self.search_var = tk.StringVar() # Dla pola wyszukiwania
        self.filter_var = tk.StringVar(value="Wszystkie Gatunki") # Dla filtra gatunków
        self.tag_filter_var = tk.StringVar(value="Wszystkie Tagi") # Dla filtra tagów
        self.game_type_filter_var = tk.StringVar(value="Wszystkie Typy") # Dla filtra typu gry
        self.sort_var = tk.StringVar(value="Nazwa") # Dla sortowania
        # --- KONIEC NOWYCH ZMIAN ---



        logging.info(f"Załadowano ustawienia lokalne: {self.local_settings}")
        self.stats_bar_color = '#0078d7'
        
        default_geometry_base = "1024x768"
        saved_geometry_str = self.local_settings.get("window_geometry")
        saved_maximized = self.local_settings.get("window_maximized", False) 
        initial_center_width = 1024
        initial_center_height = 768

        if saved_geometry_str and re.match(r'^\d+x\d+', saved_geometry_str):
            try:
                parts = saved_geometry_str.split('x')
                initial_center_width = int(parts[0])
                initial_center_height = int(parts[1].split('+')[0])
            except (ValueError, IndexError) as e:
                logging.warning(f"Nieprawidłowy format zapisanej geometrii do odczytu wymiarów: {saved_geometry_str}. Używam domyślnych 1024x768. Błąd: {e}")
        
        self.root.minsize(800, 600)

        if saved_maximized:
            try: self.root.state('zoomed')
            except tk.TclError:
                try: self.root.wm_attributes('-zoomed', True)
                except tk.TclError:
                    logging.warning("Nie można ustawić stanu zmaksymalizowanego. Okno zostanie wyśrodkowane.")
                    self._center_window(root, initial_center_width, initial_center_height)
        else:
            self._center_window(root, initial_center_width, initial_center_height)

        self.root.withdraw() # Okno będzie ukryte dopóki nie zostanie jawnie pokazane
        self.root.after_idle(self._capture_initial_root_size)
        self._last_root_width = self.root.winfo_width()
        self._last_root_height = self.root.winfo_height()
        self.record_startup_time("init_gui_base")

        # --- KONIEC KROKU 2 ---

        self.track_overlay = None # Inicjalizuj jako None
        self.overlay_update_timer = None
        # --- NOWE ZMIANY (CHAT - Odpowiadanie) ---
        self._current_reply_message_data = None # Słownik wiadomości, na którą odpowiadamy
        # --- KONIEC NOWYCH ZMIAN (CHAT - Odpowiadanie) ---
        self._search_timer_id = None
        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
        logging.info("Inicjalizacja GameLauncher...") 
        self._launch_buttons = {}
        self.items_per_page = 24
        self.current_page = 1
        self._total_pages = 1
        self.current_tile_width = 200
        os.makedirs(GAMES_FOLDER, exist_ok=True)
        os.makedirs(IMAGES_FOLDER, exist_ok=True)
        os.makedirs(INTERNAL_MUSIC_DIR,  exist_ok=True)
        os.makedirs(CUSTOM_THEMES_DIR, exist_ok=True)

        # Stylizacja (bez zmian)
        style = ttk.Style(self.root); style.theme_use('clam'); # etc.
        style.configure("TFrame", background="#1e1e1e") # Przykładowe style
        style.configure("TLabel", background="#1e1e1e", foreground="white")
        style.configure("TButton", background="#2e2e2e", foreground="white", padding=6)
        style.map("TButton", background=[('active', '#3e3e3e')])
        style.configure("Game.TFrame", background="#1e1e1e", borderwidth=1, relief="solid")
        style.configure("Game.TButton", background="#1e1e1e", foreground="white", borderwidth=0, highlightthickness=0)
        style.map("Game.TButton", background=[('active', '#1e1e1e')], borderwidth=[('active', 0)], relief=[('active', 'flat')])
        style.configure("TEntry", fieldbackground="#2e2e2e", background="#2e2e2e", foreground="white", insertbackground='white')
        style.configure("TScrollbar", background="#2e2e2e", troughcolor="#1e1e1e", arrowcolor="white")
        style.configure("Green.TButton", background="green", foreground="white")
        style.configure("Red.TButton", background="red", foreground="white")
        style.configure("Tile.TButton", padding=(3, 1), font=("Segoe UI", 7))
        style.map("Tile.TButton", background=[('active', '#4e4e4e'), ('!disabled', '#2e2e2e')], foreground=[('active', 'white'), ('!disabled', 'white')])
        style.configure("Link.TButton", foreground="lightblue", padding=0, relief="flat", borderwidth=0)
        style.map("Link.TButton", underline=[('active', 1)])
        style.configure("Treeview", background="#2e2e2e", foreground="white", fieldbackground="#2e2e2e", rowheight=25)
        style.map("Treeview", background=[('selected', '#0078d7')])
        style.configure("Treeview.Heading", background="#2e2e2e", foreground="white", font=("Segoe UI", 10, "bold"))
        style.map("Treeview.Heading", background=[('active', '#3e3e3e')])
        style.configure("Toolbutton", padding=1)

        # --- NOWE ZMIANY ---
        # Wcześniejsze uruchomienie listenera gamepada jest odroczone do _post_init_heavy_jobs.
        # threading.Thread(target=self.controller_listener, daemon=True).start()
        # --- KONIEC NOWYCH ZMIAN ---


        self.config = load_config()
        self.settings = self.config.setdefault("settings", {})
        self.games = self.config.setdefault("games", {})
        self.groups = self.config.setdefault("groups", {})
        self.user = self.config.setdefault("user", {})
        self.roadmap = self.config.setdefault("roadmap", [])
        self.archive = self.config.setdefault("archive", [])
        self.mods_data = self.config.setdefault("mods_data", {})

        # --- NOWE ZMIANY ---
        # Zainicjuj self.reminders z konfiguracji. To zapewni, że atrybut zawsze istnieje.
        self.reminders = self.config.setdefault("reminders", []) 
        # --- KONIEC NOWYCH ZMIAN ---

        self.user.setdefault("achievements", {})
        self.user.setdefault("theme_change_count", 0)
        self.local_settings.setdefault("last_run_date", "")
        self.local_settings.setdefault("consecutive_days", 0)

        # Logika sprawdzania dni z rzędu (pozostaje na tym etapie, jest szybka)
        today_str = datetime.date.today().strftime('%Y-%m-%d')
        last_run_str = self.local_settings.get("last_run_date", "")
        consecutive_days = self.local_settings.get("consecutive_days", 0)

        if last_run_str == today_str:
            pass
        else:
            try:
                last_run_date = datetime.datetime.strptime(last_run_str, '%Y-%m-%d').date()
                yesterday_date = datetime.date.today() - datetime.timedelta(days=1)
                if last_run_date == yesterday_date:
                    consecutive_days += 1
                else:
                    consecutive_days = 1
            except ValueError:
                consecutive_days = 1
            self.local_settings["last_run_date"] = today_str
            self.local_settings["consecutive_days"] = consecutive_days
            save_local_settings(self.local_settings)

        self.achievement_definitions = [] 
        self._load_achievement_definitions()
        self.record_startup_time("init_config_loaded")

        initial_view = self.local_settings.get("library_view_mode", "tiles")
        self.library_view_mode = tk.StringVar(value=initial_view)

        # Inicjalizacja Discord RPC
        self.DISCORD_CLIENT_ID = "1300136792636522517"
        self.rpc = None
        self.extended_mod_manager: ExtendedModManager | None = None
        self.rpc_loop = None
        self.rpc_thread = None
        self.discord_status_text = self.local_settings.get("discord_status_text", "Korzysta z Game Launcher")
        self.discord_rpc_enabled_var = tk.BooleanVar(value=self.local_settings.get("discord_rpc_enabled", False))
        self.discord_status_text_var = tk.StringVar(value=self.discord_status_text)
        self._is_connecting_rpc = False

        # Flask Server
        self._flask_app = None
        self._flask_thread = None
        self._server_running = False
        self.remote_server_port = self.local_settings.get("remote_control_port", 5000)

        # Hotkeys
        self.global_hotkeys_listener = None
        self.active_hotkeys = {}
        self.key_combination_listener = None
        self.current_new_hotkey_action = None
        self.current_new_hotkey_stringvar = None
        
        self.progress_queue = queue.Queue()
        self.processes = {}
        self.archive = self.config.get('archive', [])
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        self.root.bind("<Unmap>", self.on_minimize)
                        
        self.translator = DummyTranslator()
        logging.info("Używam DummyTranslator - tłumaczenia tymczasowo wyłączone.")
            
        self.STATS_PERIOD_OPTIONS_TRANSLATED = {
            "Last 7 Days": "Ostatnie 7 dni", "Last 30 Days": "Ostatnie 30 dni", "This Month": "Ten miesiąc",
            "This Year": "Ten rok", "All Time": "Cały czas", "Custom Range...": "Zakres niestandardowy..."
        }
        self.STATS_VIEW_OPTIONS_TRANSLATED = {
            "Playtime per Day": "Czas gry dziennie", "Games Played per Day": "Gry uruchamiane dziennie",
            "Playtime per Game": "Czas gry (wszystkie gry)", "Playtime per Game (Selected)": "Czas gry (wybrana gra)",
            "Playtime by Genre (Pie)": "Czas gry wg Gatunku (Kołowy)", "Most Launched Games": "Najczęściej Uruchamiane Gry",
            "Average Session Time": "Średni Czas Sesji (per Gra)", "Launcher Usage per Day": "Czas w launcherze dziennie"
        }
        self.TRANSLATED_TO_STATS_PERIOD = {v: k for k, v in self.STATS_PERIOD_OPTIONS_TRANSLATED.items()}
        self.TRANSLATED_TO_STATS_VIEW = {v: k for k, v in self.STATS_VIEW_OPTIONS_TRANSLATED.items()}

        self.ACHIEVEMENT_RULE_TYPES_TRANSLATED = {
            "games_launched_count": "Liczba uruchomionych gier", "library_size": "Rozmiar biblioteki",
            "total_playtime_hours": "Łączny czas gry (godziny)", "games_completed_100": "Gry ukończone w 100%",
            "playtime_single_game_hours": "Czas gry w jednej grze (godz.)",
            "genre_played_count": "Liczba gier z gatunku",       
            "tag_played_count": "Liczba gier z tagiem",        
            "group_played_count": "Liczba gier w grupie",       
            "genre_completed_100": "Gry 100% z gatunku",       
            "tag_completed_100": "Gry 100% z tagiem",          
            "group_completed_100": "Gry 100% w grupie",         
            "roadmap_completed_count": "Ukończone gry z Roadmapy", "games_rated_count": "Liczba ocenionych gier",
            "groups_created": "Liczba stworzonych grup", "games_with_tags": "Liczba gier z tagami",
            "mods_installed": "Liczba zainstalowanych modów",
            "roadmap_items_added": "Liczba gier dodanych do Roadmapy",
            "themes_changed": "Liczba zmian motywu",
            "game_launched_at_night": "Gra uruchomiona w nocy (2-4)",
            "consecutive_days_used": "Dni używania z rzędu"
        }
        self.record_startup_time("init_translations_and_constants")

        # Aplikacja motywu
        theme_name_from_settings = self.settings.get("theme", "Dark")
        theme_def_to_apply = self.get_all_available_themes().get(theme_name_from_settings, THEMES["Dark"])
        self.apply_theme(theme_def_to_apply)
        self.apply_font_settings() # Wywołaj funkcję stosującą czcionkę
        bg_image_path = self.settings.get("background_image", "")
        if bg_image_path:
            self.apply_background_image(bg_image_path)
        self.record_startup_time("init_theme_applied")


        # Główny układ
        self.root.columnconfigure(1, weight=1)
        self.root.rowconfigure(0, weight=1)

        # --- Tworzenie Głównych Ramek UI --- (TYLKO SAME RAMKI)
        # Panel boczny
        self.sidebar = ttk.Frame(self.root, width=200)
        self.sidebar.grid(row=0, column=0, sticky="ns")
        self.sidebar.grid_propagate(False)
        self.create_sidebar() # Sidebara budujemy od razu (bo jest krytyczny dla nawigacji)
        self.record_startup_time("init_sidebar_created")

        # Strona Główna
        self.home_frame = ttk.Frame(self.root)
        self.home_frame.grid(row=0, column=1, sticky="nsew") # Jest widoczna po utworzeniu
        self.home_frame.columnconfigure(0, weight=1)
        self.home_frame.rowconfigure(1, weight=1)
        # --- ZMIANY: Nie wywołujemy create_home_page() tutaj ---
        # `create_home_page()` zostanie wywołane z refresh_ui(),
        # które samo w sobie jest opóźnione.
        # --- KONIEC ZMIAN ---
        self.record_startup_time("init_homepage_created")


        # Strona Biblioteka
        self.main_frame = ttk.Frame(self.root)
        self.main_frame.grid(row=0, column=1, sticky="nsew")
        self.main_frame.grid_remove() # UKRYJ
        self.main_frame.columnconfigure(0, weight=1)
        self.main_frame.rowconfigure(1, weight=1)
        self.header = ttk.Frame(self.main_frame)
        self.header.grid(row=0, column=0, sticky="ew")
        # --- ZMIANY: Nie wywołujemy create_header() tutaj ---
        # `create_header()` i `create_game_grid()` zostaną wywołane w show_library()
        self.content = ttk.Frame(self.main_frame)
        self.content.grid(row=1, column=0, sticky="nsew")
        self.content.columnconfigure(0, weight=1)
        self.content.rowconfigure(0, weight=1)
        self.content.rowconfigure(1, weight=0)
        # --- ZMIANY: Nie wywołujemy create_game_grid() tutaj ---
        self.record_startup_time("init_library_created")


        # Strona Menedżera Modów
        self.mod_manager_frame = ttk.Frame(self.root)
        self.mod_manager_frame.grid(row=0, column=1, sticky="nsew")
        self.mod_manager_frame.grid_remove() # UKRYJ
        self.mod_manager_frame.columnconfigure(0, weight=1)
        self.mod_manager_frame.rowconfigure(1, weight=1)

        # Strona Newsy
        self.news_frame = ttk.Frame(self.root)
        self.news_frame.grid(row=0, column=1, sticky="nsew")
        self.news_frame.grid_remove() # UKRYJ
        self.news_frame.columnconfigure(0, weight=1)
        self.news_frame.rowconfigure(0, weight=1)
        # --- ZMIANY: Nie wywołujemy create_news_page() tutaj ---
        self.record_startup_time("init_news_created")

        # Strona Przypomnienia
        self.reminders_frame = ttk.Frame(self.root)
        self.reminders_frame.grid(row=0, column=1, sticky="nsew")
        self.reminders_frame.grid_remove() # UKRYJ
        self.reminders_frame.columnconfigure(0, weight=1)
        self.reminders_frame.rowconfigure(1, weight=1)
        # --- ZMIANY: Nie wywołujemy create_reminders_page() tutaj ---
        self.record_startup_time("init_reminders_created")

        # Strona Ustawień
        self.settings_page_frame = ttk.Frame(self.root, style="TFrame")
        self.settings_page_frame.grid(row=0, column=1, sticky="nsew")
        self.settings_page_frame.grid_remove() # UKRYJ
        self.settings_page_frame.columnconfigure(0, weight=1)
        self.settings_page_frame.rowconfigure(1, weight=1)
        # --- ZMIANY: Nie wywołujemy _create_settings_page_content() tutaj ---
        self.record_startup_time("init_settings_created")


        # Ramka Osiągnięć
        self.achievements_frame = ttk.Frame(self.root, style="TFrame")
        self.achievements_frame.grid(row=0, column=1, sticky="nsew")
        self.achievements_frame.grid_remove() # UKRYJ

        # Ramka strony Muzyki
        self.music_page_frame = ttk.Frame(self.root, style="TFrame")
        self.music_page_frame.grid(row=0, column=1, sticky="nsew")
        self.music_page_frame.grid_remove() 
        self.music_player_page_instance = None 

        # --- NOWE ZMIANY (CHAT) ---
        self.chat_page_frame = ttk.Frame(self.root, style="TFrame")
        self.chat_page_frame.grid(row=0, column=1, sticky="nsew")
        self.chat_page_frame.grid_remove() # Ukryj domyślnie
        # --- KONIEC NOWYCH ZMIAN (CHAT) ---

        # --- NOWE ZMIANY (Strona Wyboru Serwera - Tworzenie Ramki) ---
        self.server_selection_page_frame = ttk.Frame(self.root, style="TFrame")
        self.server_selection_page_frame.grid(row=0, column=1, sticky="nsew")
        self.server_selection_page_frame.grid_remove() # Ukryj domyślnie
        # --- KONIEC NOWYCH ZMIAN ---

        # Ramka Statystyk (już ukryta, budowana z opóźnieniem, więc bez zmian)
        self.stats_page_frame = ttk.Frame(self.root, style="TFrame")
        self.stats_page_frame.grid(row=0, column=1, sticky="nsew")
        self.stats_page_frame.grid_remove()
        self.root.after(500, lambda: (self.create_statistics_page(), self.stats_page_frame.grid_remove()))
        # --- KONIEC ZMIANY: Usunąłem record_startup_time("init_misc_ui_created") z tego miejsca
        # Zapiszemy go poniżej, po sekcji 'else' (po init_first_ui_display) ---


        # --- Sekcja zarządzająca pierwszym uruchomieniem / wyświetlaniem UI ---
        if not self.user.get("username"):
            self.prompt_initial_setup_choice() 
            # Jeśli użytkownik wyjdzie, aplikacja zakończy się tutaj.
            # Jeśli kontynuuje, UI zostanie pokazane, a _post_init_heavy_jobs uruchomione poniżej.
            if not self.user.get("username"): # Podwójne sprawdzenie, na wypadek gdyby prompt_initial_setup_choice nie ustawił użytkownika
                self.root.quit()
                return # Zakończ __init__ jeśli nie ma użytkownika
        
        # Pokaż główne okno dopiero po ewentualnym prompt_initial_setup_choice
        self.root.deiconify()
        self.root.lift()
        self.root.focus_force()
        self.root.update_idletasks()
        self.record_startup_time("init_first_ui_display")
            
        # --- ZMIANA: ZAWSZE POKAZUJ STRONĘ GŁÓWNĄ NA STARCIE (POZA PROMPTEM) ---
        self.show_home() # Ustaw stronę główną jako startową
        # --- KONIEC ZMIANY ---
            
        # Odłożone pełne odświeżenie UI i cięższe zadania
        self.root.after(150, self.refresh_ui) # Dajmy UI chwilę na ustabilizowanie się przed pełnym odświeżeniem
            
        if self.user.get("username"): # Uruchom cięższe zadania tylko jeśli mamy użytkownika
            self.root.after(300, self._post_init_heavy_jobs) # Zwiększono trochę opóźnienie
            
        self.tracking_games = {}
        self.game_start_times = {}
        self.processes = {}
        self.vr_filter_var = tk.StringVar(value="Wszystkie")

        if self.user.get("username"):
            # Jeśli użytkownik istnieje (lub został właśnie stworzony/wczytany)
            # Uruchamiamy odłożone zadania.
            self.root.after(250, self._post_init_heavy_jobs) 

        # TEN CHECKPOINT NALEŻY TERAZ NA SAM KONIEC KONSTRUKTORA.
        self.record_startup_time("init_end_of_constructor")


    # Nowa metoda, którą dodajemy do klasy GameLauncher, np. po _post_init_heavy_jobs
    def record_startup_time(self, checkpoint_name: str):
        """Rejestruje czas (od startu aplikacji) dla danego punktu kontrolnego."""
        if not hasattr(self, '_startup_initial_time'):
            self._startup_initial_time = time.monotonic() # Referencyjny punkt zero (czas startu GameLauncher)
        
        elapsed = (time.monotonic() - self._startup_initial_time) * 1000 # Czas w milisekundach
        self.start_up_time_points[checkpoint_name] = elapsed
        logging.debug(f"STARTUP TIME CHECKPOINT: {checkpoint_name} -> {elapsed:.2f} ms")


    # Zmień nazwę metody i dodaj ikony przycisków
    def _load_icons(self): # Zmieniono nazwę
        """Ładuje ikony używane w menu i na przyciskach do cache."""
        icon_defs = {
            # Ikony Menu (16x16)
            "play_menu": "icons/play_16.png", # Inna nazwa dla menu
            "edit": "icons/edit_16.png",
            "folder_open": "icons/folder_open_16.png",
            "save_disk": "icons/save_disk_16.png",
            "mods": "icons/mods_16.png",
            "reset": "icons/reset_16.png",
            "group_add": "icons/group_add_16.png",
            "group_remove": "icons/group_remove_16.png",
            "delete": "icons/delete_16.png",
            # --- NOWE IKONY MENU ---
            "checklist": "icons/checklist_16.png",
            "screenshot": "icons/screenshot_16.png",
            # --- KONIEC NOWYCH ---
            # Ikony Przycisków (mogą być większe, np. 20x20 lub 16x16)
            "play_btn": "icons/play_16.png", # Możesz użyć tej samej lub innej ikony
            "stop_btn": "icons/stop_16.png", # Potrzebna ikona stop
            "save_btn": "icons/save_disk_16.png", # Ikona dla przycisku "Zapisy"
            "profile_menu_btn": "icons/down_arrow_16.png" # Ikona dla menu profili
        }
        # --- ZMIANA: Użyj jednego słownika cache ---
        # self._menu_icons = {} # Usuń osobny słownik menu
        # --- KONIEC ZMIANY ---
        icon_size_menu = (16, 16)
        icon_size_button = (16, 16) # Ustaw rozmiar dla ikon przycisków

        for key, path in icon_defs.items():
            if key not in self._button_icons: # Użyj jednego cache
                try:
                    size = icon_size_button if "_btn" in key else icon_size_menu
                    img = Image.open(path).resize(size, resampling)
                    if img.mode != 'RGBA': img = img.convert('RGBA')
                    self._button_icons[key] = ImageTk.PhotoImage(img) # Zapisz w self._button_icons
                except FileNotFoundError:
                    logging.warning(f"Nie znaleziono ikony: {path}")
                    self._button_icons[key] = None
                except Exception as e:
                    logging.error(f"Błąd ładowania ikony {path}: {e}")
                    self._button_icons[key] = None
        logging.info(f"Załadowano {len([icon for icon in self._button_icons.values() if icon])} ikon.")

    # --- NOWA METODA ---
# W klasie GameLauncher

    # --- NOWA METODA ---
    def prompt_initial_setup_choice(self):
        logging.info("Brak skonfigurowanego użytkownika. Wyświetlanie dialogu początkowego.")

        dialog = tk.Toplevel(self.root) # Nadal rodzicem jest root
        dialog.title("Witaj w Game Launcher!")
        active_theme_name = self.settings.get('theme', 'Dark')
        all_themes = self.get_all_available_themes()
        theme_def = all_themes.get(active_theme_name, THEMES.get('Dark', {}))
        dialog.configure(bg=theme_def.get('background', '#1e1e1e'))
        
        # Centrowanie dialogu względem GŁÓWNEGO okna launchera (nawet jeśli ukrytego)
        self.root.update_idletasks() # Wymuś aktualizację, aby wymiary głównego okna były znane
        root_x = self.root.winfo_x()
        root_y = self.root.winfo_y()
        root_w = self.root.winfo_width()
        root_h = self.root.winfo_height()
        dialog_w = 400
        dialog_h = 200
        pos_x = root_x + (root_w // 2) - (dialog_w // 2)
        pos_y = root_y + (root_h // 2) - (dialog_h // 2)
        dialog.geometry(f"{dialog_w}x{dialog_h}+{pos_x}+{pos_y}")
        
        dialog.grab_set() 
        dialog.resizable(False, False)
        dialog.transient(self.root) 

        choice_made = tk.StringVar() # Do przechowania wyboru

        def handle_choice(chosen_action):
            choice_made.set(chosen_action)
            dialog.destroy() # Zamknij dialog
            
        ttk.Label(dialog, text="Nie wykryto konfiguracji użytkownika.", font=("Helvetica", 11)).pack(pady=(15, 5))
        ttk.Label(dialog, text="Co chcesz zrobić?", font=("Helvetica", 11, "bold")).pack(pady=(5, 15))

        btn_frame = ttk.Frame(dialog)
        btn_frame.pack(pady=10, fill=tk.X, padx=20)
        btn_frame.columnconfigure((0,1,2), weight=1)

        ttk.Button(btn_frame, text="Wczytaj Backup", command=lambda: handle_choice("load_backup")).grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        ttk.Button(btn_frame, text="Nowy Użytkownik", command=lambda: handle_choice("new_user")).grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        ttk.Button(btn_frame, text="Wyjdź", command=lambda: handle_choice("exit")).grid(row=0, column=2, padx=5, pady=5, sticky="ew")
        
        dialog.protocol("WM_DELETE_WINDOW", lambda: handle_choice("exit")) # Jeśli zamknięto przez X
        self.root.wait_window(dialog) # Czekaj na zamknięcie dialogu

        user_choice = choice_made.get()
        if user_choice == "load_backup":
            logging.info("Użytkownik wybrał wczytanie backupu.")
            # Zawsze pokaż główne okno przed wczytywaniem, aby postęp był widoczny na głównym oknie
            self.root.deiconify() 
            self.root.lift()
            self.root.focus_force()
            
            # Wczytaj backup (zawiera już logikę odświeżania UI w tle)
            self.load_local_backup() 

            # Po wczytaniu backupu (lub nawet jeśli się nie powiedzie), uruchom opóźnione zadania
            # pod warunkiem, że użytkownik *kontynuował* i aplikacja nie została zamknięta.
            if self.user.get("username"): # Jeśli użytkownik został wczytany pomyślnie z backupu
                 self.root.after(250, self._post_init_heavy_jobs) 
                 logging.info("Backup wczytany. Kontynuacja normalnego startu.")
            else:
                # Backup nie powiódł się lub nie zawierał użytkownika. Aplikacja powinna się zamknąć.
                logging.warning("Wczytywanie backupu nie powiodło się lub backup nie zawierał danych użytkownika. Zamykam aplikację.")
                self.root.quit() # Jeśli backup nie ma danych użytkownika i _post_init_heavy_jobs nie powinno się uruchomić

        elif user_choice == "new_user":
            logging.info("Użytkownik wybrał utworzenie nowego użytkownika.")
            # Zapytaj o nazwę użytkownika (teraz to prostsze - nie w if self.user.get("username"):)
            self.ask_for_username()
            if self.user.get("username"): # Jeśli użytkownik podał nazwę
                # Pokaż główne okno i kontynuuj normalny start.
                self.root.deiconify() 
                self.root.lift()
                self.root.focus_force()
                self.refresh_ui() # To ustawi startową Stronę Główną
                self.root.after(200, self.update_game_grid) # Pierwsze ładowanie siatki
                self.root.after(250, self._post_init_heavy_jobs) 
                logging.info("Nowy użytkownik stworzony. Kontynuacja normalnego startu.")
            else: 
                # Jeśli użytkownik anulował podawanie nazwy lub poda pustą.
                logging.info("Tworzenie nowego użytkownika anulowane lub brak nazwy. Zamykam aplikację.")
                self.root.quit() # Zamknij aplikację

        elif user_choice == "exit" or not user_choice:
            logging.info("Użytkownik wybrał wyjście z dialogu początkowego. Zamykam aplikację.")
            self.root.quit()

    def _on_root_resize(self, event):
        """Obsługuje zmianę rozmiaru głównego okna z opóźnieniem,
           tylko jeśli rozmiar faktycznie się zmienił."""
        if event.widget == self.root:
            new_width = event.width
            new_height = event.height

            size_changed = (new_width != self._last_root_width or new_height != self._last_root_height)

            if size_changed:
                 logging.debug(f"Wykryto zmianę rozmiaru okna: {self._last_root_width}x{self._last_root_height} -> {new_width}x{new_height}")
                 self._last_root_width = new_width
                 self._last_root_height = new_height

                 if self._resize_timer:
                     self.root.after_cancel(self._resize_timer)

                 # --- NOWE ZMIANY: Poprawiona kolejność sprawdzania hasattr ---
                 # Najpierw upewnij się, że wszystkie potrzebne atrybuty istnieją
                 if hasattr(self, 'main_frame') and \
                    hasattr(self, 'library_view_mode') and \
                    hasattr(self, 'current_frame'): 
                     # Dopiero teraz możemy bezpiecznie używać tych atrybutów
                     if self.current_frame == self.main_frame and self.library_view_mode.get() == 'tiles':
                         self._resize_timer = self.root.after(250, self.reset_and_update_grid)
                 # --- KONIEC NOWYCH ZMIAN ---
            # else: 
            #    logging.debug("Zdarzenie Configure, ale rozmiar bez zmian.")

    def _get_pynput_key_string(self, key):
        """Konwertuje obiekt klawisza pynput na string, gotowy do użycia w GlobalHotKeys."""
        if hasattr(key, 'char') and key.char is not None:
            # Dla znaków alfanumerycznych i symboli, które mają 'char'
            return key.char
        
        # Dla klawiszy specjalnych (Key.space, Key.enter, Key.f1, Key.alt, etc.)
        # używamy ich wewnętrznej reprezentacji stringowej, którą pynput powinien rozumieć
        # lub nazwy, którą GlobalHotKeys potrafi sparsować (często sama nazwa bez <>)
        # ALE dla pewności i zgodności z formatem '<modifier>+<key>', klawisze specjalne
        # (niemodyfikatory) też mogą potrzebować bycia otoczonymi przez <>, jeśli nie są literą/cyfrą.
        
        key_name = None
        if isinstance(key, keyboard.KeyCode): # Jeśli to zwykły znak
            if key.char: return key.char
        elif isinstance(key, keyboard.Key): # Jeśli to klawisz specjalny (Key.space, Key.ctrl etc.)
            key_name = key.name
        
        if key_name:
            # Modyfikatory dla GlobalHotKeys najlepiej podawać w formacie <ctrl>, <alt>, <shift>
            # ale sama funkcja parse w pynput może oczekiwać 'ctrl_l', 'alt_gr' itp.
            # Funkcja _build_hotkey_string_from_set już dba o format modyfikatorów.
            # Tutaj interesuje nas główny klawisz.
            if key_name in ['ctrl_l', 'ctrl_r', 'ctrl']: return 'ctrl'
            if key_name in ['alt_l', 'alt_r', 'alt_gr', 'alt']: return 'alt'
            if key_name in ['shift_l', 'shift_r', 'shift']: return 'shift'
            if key_name in ['cmd', 'cmd_l', 'cmd_r', 'win_l', 'win_r']: return 'cmd' # lub 'super'
            
            # Dla klawiszy specjalnych, które są "głównym" klawiszem w skrócie
            # GlobalHotKeys oczekuje ich nazw bez nawiasów trójkątnych LUB w nawiasach.
            # Bezpieczniej jest podawać nazwy, które parse na pewno zrozumie.
            # Funkcja parse("<space>") działa.
            if key_name in ['space', 'enter', 'tab', 'esc', 
                        'up', 'down', 'left', 'right',
                        'home', 'end', 'page_up', 'page_down', 
                        'delete', 'insert'] or key_name.startswith('f'): # f1, f2 ...
                return f"<{key_name}>" # Zawsze otaczajmy specjalne klawisze w <>
            return key_name # Dla innych nietypowych, np. 'media_play_pause'
        
        return str(key) # Ostateczny fallback


    def _build_hotkey_string_from_set(self, pressed_keys_set: set) -> str | None:
        """Tworzy string skrótu z setu wciśniętych klawiszy pynput w formacie GlobalHotKeys."""
        modifiers = set()       # Przechowa stringi modyfikatorów, np. '<alt>'
        primary_key_str = None  # Przechowa string "głównego" klawisza, np. 'a' lub '<space>'
        
        # Potencjalne modyfikatory i klucze, które *nie* są modyfikatorami, ale są specjalne
        known_modifiers_internal = {'ctrl', 'alt', 'shift', 'cmd', 'super'}
        
        processed_key_objects = list(pressed_keys_set) # Pracuj na kopii, aby można było usuwać

        # Najpierw wyekstrahuj i sformatuj modyfikatory
        temp_modifiers_from_set = []
        for key_obj in list(processed_key_objects): # Iteruj po kopii, bo możemy usuwać
            internal_rep = self._get_pynput_internal_representation(key_obj)
            if internal_rep in known_modifiers_internal:
                mod_string = f"<{internal_rep}>"
                if mod_string not in modifiers: # Unikaj duplikatów np. <ctrl> z Key.ctrl_l i Key.ctrl_r
                    modifiers.add(mod_string)
                processed_key_objects.remove(key_obj) # Usunięto modyfikator z listy do dalszego przetwarzania

        # Teraz znajdź główny klawisz spośród pozostałych
        if processed_key_objects: # Jeśli coś zostało po usunięciu modyfikatorów
            # Bierzemy pierwszy pozostały jako główny klawisz. 
            # Jeśli wciśnięto np. Ctrl+A+B, to A będzie głównym (pierwszym niemodyfikatorem).
            main_key_obj = processed_key_objects[0]
            main_key_internal_rep = self._get_pynput_internal_representation(main_key_obj)

            if len(main_key_internal_rep) == 1 and main_key_internal_rep.isalnum():
                primary_key_str = main_key_internal_rep # np. 'a', '1'
            else: # Klawisze specjalne jak space, enter, F1, strzałki
                primary_key_str = f"<{main_key_internal_rep}>" # np. '<space>', '<f1>', '<right>'
        
        if not primary_key_str:
            logging.debug("_build_hotkey_string_from_set: Brak klawisza głównego w kombinacji.")
            return None # Skrót musi mieć główny klawisz (niemodyfikator)

        sorted_modifiers_list = sorted(list(modifiers))
        
        if sorted_modifiers_list:
            return '+'.join(sorted_modifiers_list) + '+' + primary_key_str
        else:
            return primary_key_str

    # Metoda _on_release_for_new_hotkey wymaga również drobnej korekty
    # w logice walidacji, aby poprawnie identyfikować "główny" klawisz.

    def _get_pynput_internal_representation(self, key) -> str:
        """Pomocnicza, zwraca prosty string dla klawisza (bez <> dla modyfikatorów na tym etapie)."""
        if hasattr(key, 'char') and key.char:
            return key.char.lower() # Zawsze zwracaj małą literę dla spójności
        if hasattr(key, 'name'): # Dla Key.space, Key.ctrl_l, Key.f1 itp.
            name = key.name.lower() # Pracuj na małych literach
            # Normalizuj modyfikatory do generycznych nazw
            if name.startswith('ctrl'): return 'ctrl'
            if name.startswith('alt'): return 'alt'
            if name.startswith('shift'): return 'shift'
            if name.startswith('cmd') or name.startswith('win') or name == 'super': return 'cmd' # lub 'super'
            return name # np. 'space', 'enter', 'f1', 'right', 'left', 'up', 'down'
        return str(key).lower()


    def _on_press_for_new_hotkey(self, key):
        """Callback dla Listenera - zbiera wciśnięte klawisze do ustawienia nowego skrótu."""
        if not hasattr(self, '_pressed_keys_for_new_hotkey'):
            self._pressed_keys_for_new_hotkey = set()
        
        self._pressed_keys_for_new_hotkey.add(key)
        
        # Aktualizuj tymczasowo etykietę w oknie "Ustaw Skrót" (jeśli je mamy)
        # Na razie pomijamy UI dla tego etapu, skupmy się na logice
        current_combination = self._build_hotkey_string_from_set(self._pressed_keys_for_new_hotkey)
        if hasattr(self, 'capturing_hotkey_label') and self.capturing_hotkey_label.winfo_exists():
            self.capturing_hotkey_label.config(text=current_combination or "Naciśnij klawisze...")


    # --- NOWA METODA ---
    def _center_window(self, root, width, height):
        """
        Oblicza i ustawia geometrię okna, aby wyśrodkować je na ekranie.
        """
        # Upewnij się, że wymiary widgetów są aktualne
        root.update_idletasks() 

        # Pobierz wymiary ekranu
        screen_width = root.winfo_screenwidth()
        screen_height = root.winfo_screenheight()

        # Oblicz pozycję X i Y, aby wyśrodkować okno
        x = (screen_width - width) // 2
        y = (screen_height - height) // 2

        # Zastosuj geometrię
        try:
            root.geometry(f"{width}x{height}+{x}+{y}")
            logging.info(f"Ustawiono okno na środku ekranu: {width}x{height}+{x}+{y}")
        except tk.TclError as e:
            logging.error(f"Błąd TclError podczas centrowania okna {width}x{height}+{x}+{y}: {e}. Używam domyślnej pozycji.")
            # Fallback na domyślną, ustaloną pozycję, jeśli centrowanie zawiedzie
            root.geometry(f"{width}x{height}+100+100") 
    # --- KONIEC NOWEJ METODY ---


    def _on_press_for_new_hotkey(self, key):
        """Callback dla Listenera - zbiera wciśnięte klawisze."""
        if not hasattr(self, '_pressed_keys_for_new_hotkey'): # Powinno być zainicjowane w _set_music_hotkey_dialog
            self._pressed_keys_for_new_hotkey = set()
        
        # Pynput czasami wysyła osobne zdarzenia dla lewego/prawego modyfikatora.
        # Staramy się je znormalizować już w _get_pynput_key_string.
        self._pressed_keys_for_new_hotkey.add(key) # Dodajemy obiekt klawisza, nie string
        
        current_combination = self._build_hotkey_string_from_set(self._pressed_keys_for_new_hotkey)
        if hasattr(self, 'capturing_hotkey_label') and self.capturing_hotkey_label.winfo_exists():
            self.capturing_hotkey_label.config(text=current_combination or "Naciśnij klawisze...")
        logging.debug(f"Naciśnięto w listenerze: {key}, Aktualna kombinacja: {current_combination}")

    def _on_press_for_new_hotkey(self, key):
        """Callback dla Listenera - zbiera wciśnięte klawisze."""
        if not hasattr(self, '_pressed_keys_for_new_hotkey'): # Powinno być zainicjowane w _set_music_hotkey_dialog
            self._pressed_keys_for_new_hotkey = set()
        
        # Pynput czasami wysyła osobne zdarzenia dla lewego/prawego modyfikatora.
        # Staramy się je znormalizować już w _get_pynput_key_string.
        self._pressed_keys_for_new_hotkey.add(key) # Dodajemy obiekt klawisza, nie string
        
        current_combination = self._build_hotkey_string_from_set(self._pressed_keys_for_new_hotkey)
        if hasattr(self, 'capturing_hotkey_label') and self.capturing_hotkey_label.winfo_exists():
            self.capturing_hotkey_label.config(text=current_combination or "Naciśnij klawisze...")
        logging.debug(f"Naciśnięto w listenerze: {key}, Aktualna kombinacja: {current_combination}")

    def _on_release_for_new_hotkey(self, key):
        """Callback dla Listenera - finalizuje ustawianie skrótu po zwolnieniu 'głównego' klawisza."""
        if not hasattr(self, '_pressed_keys_for_new_hotkey') or not self._pressed_keys_for_new_hotkey:
            # Jeśli jakimś cudem ten zbiór jest pusty, ale listener nadal działa,
            # próbuj go zatrzymać i zakończ.
            if self.key_combination_listener and self.key_combination_listener.is_alive():
                self.key_combination_listener.stop()
            if hasattr(self, 'capturing_hotkey_toplevel') and self.capturing_hotkey_toplevel.winfo_exists():
                try: self.capturing_hotkey_toplevel.destroy()
                except tk.TclError: pass
            return False # Zatrzymaj listenera

        # Sprawdź, czy zwolniony klawisz jest ostatnim "niemodyfikatorem" lub czy pozostały same modyfikatory.
        # To bardziej złożone niż proste sprawdzanie is_modifier_released,
        # bo musimy wiedzieć, co jeszcze jest wciśnięte.

        # Zbuduj proponowany string skrótu PRZED usunięciem klawisza ze zbioru (jeśli jest to istotne dla logiki)
        # Ale `_build_hotkey_string_from_set` bierze cały zbiór, więc to ok.
        
        # Jeśli `_pressed_keys_for_new_hotkey` zawiera tylko ten `key` LUB
        # jeśli `key` nie jest modyfikatorem (a inne mogą być)
        is_main_key_released = False
        released_key_internal_rep = self._get_pynput_internal_representation(key)
        if released_key_internal_rep not in ['ctrl', 'alt', 'shift', 'cmd', 'super']:
            is_main_key_released = True
        elif len(self._pressed_keys_for_new_hotkey) == 1 and key in self._pressed_keys_for_new_hotkey:
             # Puszczono ostatni wciśnięty klawisz, którym był modyfikator
             is_main_key_released = True # Traktujemy to jako próbę finalizacji (niepoprawną)

        if not is_main_key_released: # Jeśli puściliśmy modyfikator, a inne klawisze (potencjalnie główny) są wciśnięte
            if key in self._pressed_keys_for_new_hotkey:
                self._pressed_keys_for_new_hotkey.remove(key)
            # Zaktualizuj UI, ale kontynuuj nasłuchiwanie
            current_combination = self._build_hotkey_string_from_set(self._pressed_keys_for_new_hotkey)
            if hasattr(self, 'capturing_hotkey_label') and self.capturing_hotkey_label.winfo_exists():
                try: self.capturing_hotkey_label.config(text=current_combination or "Naciśnij klawisze...")
                except tk.TclError: pass
            return True # Kontynuuj nasłuchiwanie


        # Jeśli doszliśmy tutaj, to albo zwolniono "główny" klawisz,
        # albo zwolniono ostatni klawisz (który mógł być modyfikatorem, co da niepoprawny skrót)
        final_hotkey_string = self._build_hotkey_string_from_set(self._pressed_keys_for_new_hotkey)
        self._pressed_keys_for_new_hotkey.clear()

        if self.key_combination_listener and self.key_combination_listener.is_alive():
            self.key_combination_listener.stop()
            self.key_combination_listener = None # Listener pynput nie wspiera join() z własnego wątku
            logging.debug("Zatrzymano listenera pynput (keyboard.Listener) dla nowego skrótu.")

        if hasattr(self, 'capturing_hotkey_toplevel') and self.capturing_hotkey_toplevel.winfo_exists():
            try: self.capturing_hotkey_toplevel.destroy()
            except tk.TclError: pass

        is_valid_hotkey_format = False
        if final_hotkey_string:
            # Poprawny skrót musi zawierać co najmniej jeden klawisz, który nie jest tylko modyfikatorem
            # (np. 'a', '<space>', '<f1>')
            parts = final_hotkey_string.split('+')
            has_non_modifier_primary_key = any(
                not (part.lower() in ['<ctrl>', '<alt>', '<shift>', '<cmd>', '<super>']) for part in parts
            )
            if has_non_modifier_primary_key:
                 is_valid_hotkey_format = True

        if is_valid_hotkey_format and self.current_new_hotkey_action and self.current_new_hotkey_stringvar:
            # ... (logika zapisu i odświeżania skrótów - bez zmian) ...
            logging.info(f"Ustawiono nowy skrót dla '{self.current_new_hotkey_action}': {final_hotkey_string}")
            self.current_new_hotkey_stringvar.set(final_hotkey_string)
            current_hotkeys = self.local_settings.get("music_hotkeys", DEFAULT_MUSIC_HOTKEYS.copy())
            current_hotkeys[self.current_new_hotkey_action] = final_hotkey_string
            self.local_settings["music_hotkeys"] = current_hotkeys
            save_local_settings(self.local_settings)
            self.root.after(0, self._reregister_all_global_hotkeys)
            display_name = self.hotkey_actions_display_names.get(self.current_new_hotkey_action, self.current_new_hotkey_action)
            self.root.after(0, lambda d=display_name, h=final_hotkey_string: messagebox.showinfo("Skrót Ustawiony", f"Nowy skrót dla '{d}' to: {h}", parent=self.settings_page_frame if hasattr(self, 'settings_page_frame') and self.settings_page_frame.winfo_exists() else self.root))
        elif self.current_new_hotkey_action:
            old_hotkey = self.local_settings.get("music_hotkeys", {}).get(self.current_new_hotkey_action, "")
            if self.current_new_hotkey_stringvar: self.current_new_hotkey_stringvar.set(old_hotkey)
            self.root.after(0, lambda: messagebox.showwarning("Anulowano Ustawianie Skrótu", "Nie udało się przechwycić poprawnej kombinacji klawiszy lub skrót jest nieprawidłowy (np. składa się tylko z modyfikatorów).\nPrzywrócono poprzedni skrót.", parent=self.settings_page_frame if hasattr(self, 'settings_page_frame') and self.settings_page_frame.winfo_exists() else self.root))
        
        self.current_new_hotkey_action = None
        self.current_new_hotkey_stringvar = None
        return False # Zawsze zatrzymaj listener po tej finalizacji

    def _initialize_track_overlay_from_settings(self): # Zmieniona nazwa
        """Tworzy instancję overlay'a, jeśli jest włączony w ustawieniach."""
        if self.local_settings.get("show_track_overlay", False):
            self.show_track_overlay() 
        else:
            self.hide_track_overlay() # Upewnij się, że jest ukryty, jeśli wyłączony

    def _toggle_track_overlay_setting(self):
        """Zapisuje ustawienie pokazywania overlay'a i go pokazuje/ukrywa."""
        if not hasattr(self, 'show_track_overlay_var'): return

        show = self.show_track_overlay_var.get()
        self.local_settings["show_track_overlay"] = show
        # Pozycja X i Y jest zapisywana przez samo okno overlay'a
        save_local_settings(self.local_settings)
        logging.info(f"Ustawienie pokazywania nakładki odtwarzacza zmienione na: {show}")

        if show:
            self.show_track_overlay()
            # Uruchom/wznów regularne aktualizacje, jeśli jeszcze nie działają
            if not self.overlay_update_timer:
                 self.root.after(100, self._update_overlay_regularly)
        else:
            self.hide_track_overlay()
            if self.overlay_update_timer:
                self.root.after_cancel(self.overlay_update_timer)
                self.overlay_update_timer = None

    def show_track_overlay(self):
        if not hasattr(self, 'track_overlay') or not self.track_overlay or not self.track_overlay.winfo_exists():
            logging.info("Tworzenie nowej instancji TrackOverlayWindow.")
            initial_x = self.local_settings.get("overlay_x_pos") # Domyślnie None
            initial_y = self.local_settings.get("overlay_y_pos") # Domyślnie None
            self.track_overlay = TrackOverlayWindow(self.root, initial_x, initial_y, launcher_instance=self)
        
        if self.track_overlay:
            try:
                self.track_overlay.show_overlay()
            except tk.TclError as e:
                logging.error(f"Błąd TclError podczas pokazywania overlay'a: {e}"); self.track_overlay = None


    def hide_track_overlay(self):
        """Ukrywa okno nakładki, jeśli istnieje."""
        if hasattr(self, 'track_overlay') and self.track_overlay and self.track_overlay.winfo_exists():
            try:
                self.track_overlay.hide_overlay()
                logging.debug("Wywołano hide_overlay() na instancji TrackOverlayWindow.")
            except tk.TclError as e:
                logging.error(f"Błąd TclError podczas ukrywania overlay'a: {e}")
                self.track_overlay = None
        else:
            logging.debug("Próba ukrycia overlay'a, który nie istnieje lub już jest ukryty.")
            

    # --- NOWE ZMIANY (CHAT) ---
    def show_chat_page(self):
        # --- ZMIANA: Logika kolejności ładowania i logowania ---
        remembered_partner = self._last_open_chat_partner_id 

        # 1. Zapewnij, że główna ramka strony czatu jest widoczna
        self.chat_page_frame.grid()
        self.chat_page_frame.tkraise()
        self.current_frame = self.chat_page_frame

        # 2. Leniwe tworzenie zawartości strony czatu
        if not getattr(self, "_chat_initialized", False):
            self._create_chat_page_content()
            self._chat_initialized = True

        # 3. Wczytaj zapisane dane logowania do pól formularza (JEŚLI "Remember me")
        #    To tylko wypełnia pola, nie loguje.
        if self.chat_remember_me_var.get():
             self._load_saved_chat_credentials()
        else: # Jeśli "remember me" nie jest zaznaczone, wyczyść pola
             self.chat_email_var.set(self.local_settings.get("chat_last_email", "")) # Lub samo self.local_settings.get("chat_email","") jeśli to aktualniejsze
             self.chat_password_var.set("") # Zawsze czyść hasło jeśli nie "remember me"

        # 4. Zaktualizuj stan interfejsu (pokaż panel logowania lub główny panel czatu)
        #    Jeśli użytkownik NIE JEST zalogowany, to powinno pokazać chat_auth_panel
        self._update_chat_ui_state()

        # 5. Spróbuj automatycznego logowania (JEŚLI włączone i mamy dane)
        #    To wywoła _chat_login, które z kolei po sukcesie zaktualizuje UI i połączy z SIO.
        if not self.chat_logged_in_user: # Tylko jeśli jeszcze nie jesteśmy zalogowani
            self._try_auto_chat_login() 
        
        # 6. Przywróć ostatniego partnera czatu, jeśli jest to możliwe (po ev. auto-logowaniu)
        #    Dajemy opóźnienie, aby dać czas na auto-logowanie i aktualizację UI.
        #    _restore_last_chat_partner powinno samo sprawdzić, czy jesteśmy zalogowani.
        if remembered_partner and remembered_partner != self.chat_dashboard_placeholder_id:
            self.root.after(
                500, # Zwiększono opóźnienie, aby dać czas na połączenie SIO i pobranie użytkowników
                lambda pid=remembered_partner: self._restore_last_chat_partner(pid)
            )
        elif self.chat_logged_in_user and self.chat_authenticated: # Jeśli zalogowani, ale brak zapamiętanego -> pokaż dashboard
             if not hasattr(self, 'chat_users_tree') or not self.chat_users_tree.winfo_exists():
                 self.root.after(100, self._show_chat_dashboard) # Jeśli treeview jeszcze nie ma
             elif self.chat_users_tree.exists(self.chat_dashboard_placeholder_id):
                self.chat_users_tree.selection_set(self.chat_dashboard_placeholder_id)
                self.chat_users_tree.focus(self.chat_dashboard_placeholder_id)
                self.root.after(50, self._show_chat_dashboard)


        self._reset_chat_search_field()
        self.current_section = "Czat"
        self._update_discord_status(status_type="browsing", activity_details=self.current_section)
        # --- KONIEC ZMIANY ---


    def _restore_last_chat_partner(self, partner_id_to_restore):
        """
        Próbuje przywrócić ostatnio otwarty czat, jeśli jesteśmy zalogowani.
        """
        if self.chat_logged_in_user and self.chat_authenticated: # Sprawdź, czy jesteśmy zalogowani
            if self.active_chat_partner_id == self.chat_dashboard_placeholder_id: # Tylko jeśli dashboard jest aktywny
                logging.debug(f"Chat: Próba przywrócenia ostatniego partnera: {partner_id_to_restore}")
                # Trzeba będzie rozróżnić, czy to user_id czy room_id na podstawie
                # struktury `remembered_partner` (np. przez przechowywanie obiektu, a nie tylko ID).
                # Na razie zakładamy, że jest to ID użytkownika (bo pokoje nie były jeszcze obsługiwane).
                # Potrzebujemy tutaj informacji o TYPIE remembered_partner (user/room).
                # To wymaga zmiany w `_on_chat_user_select`, aby `_last_open_chat_partner_id`
                # zapisywało `selected_iid_str` (z prefixem) zamiast czystego ID.

                # ---- UPROSZCZONA WERSJA DO TESTÓW ----
                # Ta wersja może wymagać poprawy, gdy w pełni zaimplementujemy zapamiętywanie pokoi.
                # Dla celów obecnego debugowania statusu online użytkowników:
                # Spróbujmy zaznaczyć, ale najpierw pobierz użytkowników i pokoje,
                # co powinno się zdarzyć w `_update_chat_ui_state` po `_try_auto_chat_login`.

                # Zakładamy, że `_fetch_chat_users` zostało już wywołane w `_update_chat_ui_state`
                # i `self.chat_users` / `self.chat_rooms` są wypełnione.

                item_to_select_iid = None
                # To jest słabe, bo nie wiemy, czy partner_id_to_restore to user czy room bez dodatkowej informacji.
                # Próbujemy odgadnąć. Jeśli ID jest w self.chat_users, to pewnie user.
                if partner_id_to_restore in self.chat_users:
                    item_to_select_iid = f"{self.CHAT_PREFIX_USER}{partner_id_to_restore}"
                elif partner_id_to_restore in self.chat_rooms: # Jeśli ID jest w self.chat_rooms
                     item_to_select_iid = f"{self.CHAT_PREFIX_ROOM}{partner_id_to_restore}"
                
                if item_to_select_iid and self.chat_users_tree.exists(item_to_select_iid):
                     self.chat_users_tree.selection_set(item_to_select_iid)
                     self.chat_users_tree.see(item_to_select_iid)
                     self.chat_users_tree.focus(item_to_select_iid)
                     # Ręczne wywołanie eventu, aby załadować historię
                     self.chat_users_tree.event_generate("<<TreeviewSelect>>")
                else:
                     logging.warning(f"Nie można przywrócić ostatniego partnera '{partner_id_to_restore}', brak w Treeview lub danych.")
                     # Jeśli nie można przywrócić, upewnij się, że dashboard jest wybrany.
                     self.chat_users_tree.selection_set(self.chat_dashboard_placeholder_id)
                     self.chat_users_tree.focus(self.chat_dashboard_placeholder_id)
                     self._show_chat_dashboard() # To ustawi panel główny
            else:
                 logging.debug(f"Dashboard nie jest aktywny, nie przywracam partnera ({self.active_chat_partner_id}).")
        else:
            logging.info("Nie jesteśmy zalogowani, pomijanie przywracania ostatniego partnera.")


    def _select_chat_partner_silently(self, partner_id: int):
        """
        Wewnętrzne: wybiera partnera czatu **bez czyszczenia okna**
        i bez dodatkowych mignięć.
        """
        # jeśli w międzyczasie user wybrał kogoś innego – nie ruszaj
        if self.active_chat_partner_id != self.chat_dashboard_placeholder_id:
            return

        # ustaw partnera i załaduj historię
        self.active_chat_partner_id = partner_id
        self.chat_users_tree.selection_set(str(partner_id))   # podświetl w liście
        self.chat_users_tree.see(str(partner_id))
        self.chat_active_partner_label.config(
            text=f"Czat z: {self.chat_users.get(partner_id, {}).get('username', '...?')}"
        )
        self._load_and_display_chat_history(
            self.chat_logged_in_user['user_id'],
            partner_id
        )


    # --- NOWE ZMIANY (CHAT) ---
    # W _try_auto_chat_login, użyj danych dla aktywnego serwera
    def _try_auto_chat_login(self):
        if self.chat_logged_in_user: return
        
        active_server_data = self._get_active_server_data()
        if not (active_server_data and \
                active_server_data.get("auto_login_to_server", False) and \
                active_server_data.get("remember_credentials", False)):
            logging.debug("Chat: Automatyczne logowanie wyłączone dla aktywnego serwera lub brak danych.")
            return

        creds = active_server_data.get("credentials", {})
        saved_email = creds.get("email")
        saved_password = creds.get("password") # Nadal plain/zaszyfrowane

        if saved_email and saved_password:
            logging.info(f"Chat: Próba automatycznego logowania do serwera '{active_server_data.get('name')}'...")
            self.chat_email_var.set(saved_email)
            self.chat_password_var.set(saved_password)
            self.root.after_idle(self._chat_login)
        else:
            logging.debug(f"Chat: Brak zapisanego e-maila/hasła do automatycznego logowania dla serwera '{active_server_data.get('name')}'.")

    # --- KONIEC NOWYCH ZMIAN (CHAT) ---

# W klasie GameLauncher, metoda _create_chat_page_content()

# game_launcher.py

# ... (istniejący kod) ...

    def _create_chat_page_content(self):
        # usuń poprzednią zawartość ramki
        for widget in self.chat_page_frame.winfo_children():
            widget.destroy()

        self.chat_page_frame.columnconfigure(0, weight=1)
        self.chat_page_frame.rowconfigure(0, weight=1)

        # ---------- PANEL LOGOWANIA ----------
        self.chat_auth_panel = ttk.Frame(self.chat_page_frame, padding=20)
        self.chat_auth_panel.columnconfigure(1, weight=1) 
        self.chat_auth_panel.columnconfigure(2, weight=0) 
        
        # --- NOWE ZMIANY: Inicjalizacja current_auth_panel_row ---
        current_auth_panel_row = 0 
        # --- KONIEC NOWYCH ZMIAN ---
        
        ttk.Label(self.chat_auth_panel, text="Logowanie / Rejestracja do Czatu",
                font=("Helvetica", 14, "bold")).grid(row=current_auth_panel_row, column=0, columnspan=3, pady=(0, 10))
        current_auth_panel_row += 1

        ttk.Label(self.chat_auth_panel, text="Adres E-mail:").grid(row=current_auth_panel_row, column=0, sticky="w", pady=5)
        ttk.Entry(self.chat_auth_panel, textvariable=self.chat_email_var)\
            .grid(row=current_auth_panel_row, column=1, sticky="ew", pady=5)
        current_auth_panel_row += 1

        ttk.Label(self.chat_auth_panel, text="Hasło:").grid(row=current_auth_panel_row, column=0, sticky="w", pady=5)
        ttk.Entry(self.chat_auth_panel, textvariable=self.chat_password_var, show="*")\
            .grid(row=current_auth_panel_row, column=1, sticky="ew", pady=5)
        current_auth_panel_row += 1

        ttk.Button(self.chat_auth_panel, text="Zaloguj", command=self._chat_login)\
            .grid(row=current_auth_panel_row, column=0, columnspan=2, pady=(10,2), sticky="ew")
        current_auth_panel_row += 1
        
        remember_me_check = ttk.Checkbutton(
            self.chat_auth_panel, text="Zapamiętaj dane logowania", 
            variable=self.chat_remember_me_var, command=self._on_remember_me_toggle)
        remember_me_check.grid(row=current_auth_panel_row, column=0, columnspan=2, sticky="w", padx=0, pady=(0,0)) 
        current_auth_panel_row += 1
        
        auto_login_check = ttk.Checkbutton(
            self.chat_auth_panel, text="Automatyczne logowanie", 
            variable=self.chat_auto_login_var, command=self._on_auto_login_toggle)
        auto_login_check.grid(row=current_auth_panel_row, column=0, columnspan=2, sticky="w", padx=0, pady=(0, 10)) 
        current_auth_panel_row += 1
        
        ttk.Label(self.chat_auth_panel, text="--- Brak konta? ---").grid(row=current_auth_panel_row, column=0, columnspan=2, pady=(5,5))
        current_auth_panel_row += 1
        
        ttk.Label(self.chat_auth_panel, text="Nazwa Użytkownika:").grid(row=current_auth_panel_row, column=0, sticky="w", pady=5)
        ttk.Entry(self.chat_auth_panel, textvariable=self.chat_username_var)\
            .grid(row=current_auth_panel_row, column=1, sticky="ew", pady=5)
        current_auth_panel_row += 1
        
        ttk.Button(self.chat_auth_panel, text="Zarejestruj", command=self._chat_register)\
            .grid(row=current_auth_panel_row, column=0, columnspan=2, pady=(10,5), sticky="ew")
        current_auth_panel_row += 1

        server_list_btn_auth_panel = ttk.Button(
            self.chat_auth_panel, 
            text="🌐 Wybierz/Zarządzaj Serwerami Czatu", 
            command=self._go_to_server_selection_from_chat_auth,
            style="Toolbutton.TButton" 
        )
        server_list_btn_auth_panel.grid(row=current_auth_panel_row, column=0, columnspan=2, pady=(15, 5), sticky="ew")
        ToolTip(server_list_btn_auth_panel, "Pokaż listę serwerów czatu i zarządzaj nimi")
        # current_auth_panel_row +=1 # Nie potrzebujemy już inkrementować, bo to ostatni element w tej sekcji


        # ---------- PANEL GŁÓWNY CZATU ----------
        self.chat_main_panel = ttk.Frame(self.chat_page_frame)
        self.chat_main_panel.columnconfigure(0, weight=1)
        self.chat_main_panel.rowconfigure(0, weight=1)

        self.chat_paned_window = ttk.PanedWindow(self.chat_main_panel, orient=tk.HORIZONTAL)
        self.chat_paned_window.grid(row=0, column=0, sticky="nsew") 

        # -------- LEWY: lista użytkowników --------
        self.chat_users_panel = ttk.Frame(self.chat_paned_window)
        self.chat_paned_window.add(self.chat_users_panel, weight=1) # Zmieniamy wagę na 1 (proporcjonalnie mniejszy)
        self.chat_users_panel.columnconfigure(0, weight=1)
        # --- NOWE ZMIANY ---
        self.chat_users_panel.rowconfigure(1, weight=0) # Wiersz dla labela użytkownika
        self.chat_users_panel.rowconfigure(2, weight=0) # Wiersz dla przycisku edycji
        self.chat_users_panel.rowconfigure(3, weight=0) # Nowy wiersz dla przycisku "Utwórz Pokój"
        self.chat_users_panel.rowconfigure(4, weight=1) # Wiersz dla pola wyszukiwarki i Treeview
        # --- KONIEC NOWYCH ZMIAN ---
        
        self.chat_connection_status_label = ttk.Label(self.chat_users_panel, text="Status: Rozłączono", font=("Segoe UI", 8, "italic"), anchor="w")
        self.chat_connection_status_label.grid(row=0, column=0, sticky="ew", padx=5, pady=(5,0))

        # --- NOWE ZMIANY ---
        # Ramka na etykietę nazwy użytkownika i przycisk edycji
        user_info_frame = ttk.Frame(self.chat_users_panel)
        user_info_frame.grid(row=1, column=0, sticky="ew", padx=5, pady=(5,0))
        user_info_frame.columnconfigure(0, weight=1) # Etykieta nazwy użytkownika rozciąga się

        self.chat_current_user_label = ttk.Label(user_info_frame, text="Zalogowano jako: Nieznany", font=("Segoe UI", 9, "bold"))
        self.chat_current_user_label.grid(row=0, column=0, sticky="w") # W tej ramce, w kolumnie 0

        edit_username_btn = ttk.Button(user_info_frame, text="Edytuj", command=self._edit_chat_username_dialog, width=6)
        edit_username_btn.grid(row=0, column=1, sticky="e", padx=(5,0)) # W tej ramce, w kolumnie 1
        # --- KONIEC NOWYCH ZMIAN ---

        # --- NOWE ZMIANY (CHAT GRUPOWY - Etap 1/5) ---
        # Przycisk "Utwórz Pokój"
        self.create_room_btn = ttk.Button(self.chat_users_panel, text="➕ Utwórz Pokój", command=self._create_room_dialog)
        self.create_room_btn.grid(row=2, column=0, sticky="ew", padx=5, pady=(5,0)) # Nowy wiersz 2
        ToolTip(self.create_room_btn, "Stwórz nowy pokój czatu (opcjonalnie z hasłem)")
        # --- KONIEC NOWYCH ZMIAN ---

        self.chat_user_search_var = tk.StringVar()
        self.chat_user_search_var.trace_add("write", lambda *args: self._filter_chat_users())
        self.chat_user_search_entry = ttk.Entry(self.chat_users_panel, textvariable=self.chat_user_search_var, width=20)
        # --- ZMIANA WIERZSZ W GRID ---
        self.chat_user_search_entry.grid(row=3, column=0, sticky="ew", padx=5, pady=(5,0)) # Teraz jest w wierszu 3
        # --- KONIEC ZMIANY WIERZSZ ---
        ToolTip(self.chat_user_search_entry, "Wyszukaj użytkowników...")

        # ---- >>>  Treeview + BIND  <<< ----
        # --- NOWE ZMIANY (CHAT GRUPOWY - Etap 2/5 - Zmiana 1/5) ---
        self.chat_users_tree = ttk.Treeview(self.chat_users_panel, columns=("username", "unread_count"), show="headings", selectmode="browse")
        self.chat_users_tree.heading("username", text="Nazwa") 
        self.chat_users_tree.heading("unread_count", text="Nowe") 
        self.chat_users_tree.column("username", width=120, anchor="w")
        self.chat_users_tree.column("unread_count", width=40, anchor="center", stretch=False) 

        self.chat_users_tree.grid(row=4, column=0, sticky="nsew", padx=5, pady=(0, 5)) 

        # Styl dla grup, użytkowników i nagłówka panelu
        self.chat_users_tree.tag_configure("user_chat_item", foreground="white", background="#2e2e2e")
        self.chat_users_tree.tag_configure("room_chat_item", font=("Segoe UI", 9, "bold"), foreground="cyan", background="#3a3a3a") 
        self.chat_users_tree.tag_configure("room_member_tag", foreground="cyan", font=("Segoe UI", 9, "bold")) 
        self.chat_users_tree.tag_configure("room_non_member_tag", foreground="gray", font=("Segoe UI", 9, "italic")) 
        self.chat_users_tree.tag_configure("room_has_password_tag", font=("Segoe UI Symbol", 9), foreground="yellow") 

        # Przewidywane znaczniki: online/offline/unread
        self.chat_users_tree.tag_configure("user_online_tag", foreground="lightgreen")
        self.chat_users_tree.tag_configure("user_offline_tag", foreground="gray")
        self.chat_users_tree.tag_configure("new_message_tag", foreground="yellow", font=("Segoe UI", 9, "bold"))

        # separator/dashboard
        self.chat_users_tree.tag_configure("system_header_tag", foreground="lightgray", font=("Segoe UI", 9, "italic"))

        self.chat_users_tree.bind("<<TreeviewSelect>>", self._on_chat_user_select)
        # --- POPRAWKA: Zmieniono 'elf' na 'self' ---
        self.chat_users_tree.bind("<Button-3>", self._on_chat_list_right_click) 
        # --- KONIEC POPRAWKI ---

        users_scrollbar = ttk.Scrollbar(self.chat_users_panel, orient="vertical", command=self.chat_users_tree.yview)
        users_scrollbar.grid(row=4, column=1, sticky="ns", pady=(0, 5))
        self.chat_users_tree.config(yscrollcommand=users_scrollbar.set)

        # tagi Treeview (kolory…)
        # --- ZMIANA: Poprawione odwołanie do 'self' zamiast 'self.launcher' ---
        theme_def = self.get_all_available_themes().get(self.settings.get('theme', 'Dark'), THEMES['Dark'])
        # --- KONIEC ZMIANY ---
        new_message_fg = "yellow"
        normal_user_fg = theme_def.get('foreground', 'white')
        normal_user_bg = theme_def.get('tree_background', '#2e2e2e')

        self.chat_users_tree.tag_configure("new_message",
            foreground=new_message_fg, font=("Segoe UI", 9, "bold"))
        self.chat_users_tree.tag_configure("normal_user_chat_tree",
            foreground=normal_user_fg, background=normal_user_bg)

        # NOWE TAGI DLA STATUSU ONLINE/OFFLINE
        online_fg = "lightgreen"
        offline_fg = "gray"

        self.chat_users_tree.tag_configure("online_user_chat_tree", 
            foreground=online_fg, background=normal_user_bg )
        self.chat_users_tree.tag_configure("offline_user_chat_tree", 
            foreground=offline_fg, background=normal_user_bg )


        # -------- PRAWY: okno wiadomości --------
        self.chat_messages_panel = ttk.Frame(self.chat_paned_window)
        self.chat_paned_window.add(self.chat_messages_panel, weight=3) # Zmieniamy wagę na 3 (proporcjonalnie większy)
        self.chat_messages_panel.columnconfigure(0, weight=1)
        
        # START NEW: Layout prawego panelu z wiadomościami i polem do pisania
        
        # Konfiguracja rozciągania wierszy w chat_messages_panel
        self.chat_messages_panel.rowconfigure(0, weight=0) # Etykieta partnera (stała wysokość)
        self.chat_messages_panel.rowconfigure(1, weight=0) # Etykieta pisania (stała wysokość)
        self.chat_messages_panel.rowconfigure(2, weight=0) # Ramka wyszukiwarki (stała)
        self.chat_messages_panel.rowconfigure(3, weight=1) # Okno wiadomości (POCHŁANIA WOLNĄ PRZESTRZEŃ)
        self.chat_messages_panel.rowconfigure(4, weight=0) # Pole wprowadzania (stała wysokość)
        # UWAGA: rzędy 5, 6, 7 i 8 poniżej
        self.chat_messages_panel.rowconfigure(5, weight=0) # Ramka podglądu odpowiedzi
        self.chat_messages_panel.rowconfigure(6, weight=0) # Ramka podglądu załącznika
        self.chat_messages_panel.rowconfigure(7, weight=0) # Ramka przycisków akcji
        self.chat_messages_panel.rowconfigure(8, weight=0) # Przycisk Wyloguj

        # Etykieta aktywnego czatu
        self.chat_active_partner_label = ttk.Label(self.chat_messages_panel, text="Wybierz partnera czatu", font=("Segoe UI", 10, "bold"), anchor="w")
        self.chat_active_partner_label.grid(row=0, column=0, sticky="ew", padx=10, pady=(5,0))

        # Wskaźnik pisania
        self.chat_typing_indicator_label = ttk.Label(self.chat_messages_panel, text="", font=("Segoe UI", 8, "italic"), foreground="gray", anchor="w")
        self.chat_typing_indicator_label.grid(row=1, column=0, sticky="ew", padx=10, pady=(0,5)) # Wiersz 1

        # Ramka dla wyszukiwarki (nad oknem wiadomości)
        chat_message_search_frame = ttk.Frame(self.chat_messages_panel)
        chat_message_search_frame.grid(row=2, column=0, columnspan=2, sticky="ew", padx=10, pady=(5,0)) # Wiersz 2
        chat_message_search_frame.columnconfigure(0, weight=1) # Pole Entry rośnie

        self.chat_message_search_var = tk.StringVar()
        self.chat_message_search_var.trace_add("write", lambda *args: self._on_chat_message_search_change())
        
        chat_message_search_entry = ttk.Entry(chat_message_search_frame, textvariable=self.chat_message_search_var)
        chat_message_search_entry.grid(row=0, column=0, sticky="ew", padx=(0,2))
        ToolTip(chat_message_search_entry, "Wyszukaj w wiadomościach tego czatu...")

        clear_message_search_btn = ttk.Button(
            chat_message_search_frame, text="✖", 
            command=self._clear_chat_message_search, # Nowa metoda
            width=3, style="Toolbutton.TButton"
        )
        clear_message_search_btn.grid(row=0, column=1, sticky="e")

        # Okno wyświetlania wiadomości (wiersz 3)
        self.chat_message_display = tk.Text(self.chat_messages_panel, wrap=tk.WORD, state=tk.DISABLED, height=10, bg="#2e2e2e", fg="white")
        self.chat_message_display.grid(row=3, column=0, sticky="nsew", padx=10, pady=5) # Wiersz 3

        messages_scrollbar = ttk.Scrollbar(self.chat_messages_panel, orient="vertical", command=self.chat_message_display.yview)
        messages_scrollbar.grid(row=3, column=1, sticky="ns", pady=5)
        def _on_chat_scroll(lower, upper):
            messages_scrollbar.set(lower, upper)
            if float(lower) <= 0.02 and self.chat_history_has_more and not self.chat_history_loading:
                self._fetch_more_chat_history()

        self.chat_message_display.config(yscrollcommand=_on_chat_scroll)

        theme_def = self.get_all_available_themes().get(self.settings.get('theme', 'Dark'), THEMES['Dark'])
        my_msg_fg = theme_def.get('link_foreground', 'lightblue')
        other_msg_fg = theme_def.get('foreground', 'lightgreen')
        system_msg_fg = theme_def.get('chart_axis_color', 'gray')
        error_msg_fg = 'red'

        # Style tagów systemowych/error
        self.chat_message_display.tag_config("system_tag", 
            foreground=system_msg_fg, font=("Segoe UI", 9, "italic"), justify="center", 
            lmargin1=10, lmargin2=10, rmargin=10, spacing1=5, spacing2=2)
        self.chat_message_display.tag_config("error_tag", 
            foreground=error_msg_fg, font=("Segoe UI", 9, "bold"), justify="center",
            spacing1=5, spacing2=2) 

        # Style dla moich wiadomości (wyrównane do prawej, bez tła)
        self.chat_message_display.tag_config("my_message_tag",
            foreground=my_msg_fg,
            background="#004e92",
            borderwidth=5,
            relief="solid",
            justify="right",
            lmargin1=10,
            lmargin2=10,
            rmargin=10,
            spacing1=8,
            spacing2=4,
            spacing3=8
        )

        # Style dla wiadomości od innych – szary „dymek”
        self.chat_message_display.tag_config("other_message_tag",
            foreground=other_msg_fg,
            background="#2e2e2e",
            borderwidth=5,
            relief="solid",
            justify="left",
            lmargin1=10,
            lmargin2=10,
            rmargin=10,
            spacing1=8,
            spacing2=4,
            spacing3=8
        )
        
        s = ttk.Style()
        theme_bg = self.chat_message_display.cget('bg')
        theme_fg = self.chat_message_display.cget('fg')
        
        # Styl dla ramki oczekującego załącznika (delikatne tło)
        pending_attachment_frame_bg = theme_def.get('entry_background', '#282828')
        s.configure("ChatPendingAttachment.TFrame", background=pending_attachment_frame_bg, borderwidth=1, relief="groove")
        s.configure("ChatPendingAttachment.TLabel", background=pending_attachment_frame_bg, foreground=theme_fg, font=("Segoe UI", 8))
        s.configure("ChatPendingAttachment.Toolbutton.TButton", 
                    background=pending_attachment_frame_bg, 
                    foreground=theme_fg,
                    relief="flat", 
                    padding=(1,0),
                    font=("Segoe UI Symbol", 9, "bold"))
        s.map("ChatPendingAttachment.Toolbutton.TButton",
              foreground=[('active', 'red'), ('hover', 'red')],
              background=[('active', pending_attachment_frame_bg), ('hover', pending_attachment_frame_bg)])

        self.chat_message_display.bind("<Configure>", self._on_chat_display_resize)

        # Pole do wpisywania wiadomości (wiersz 4)
        self.chat_input_var = tk.StringVar()
        self.chat_input_entry = ttk.Entry(self.chat_messages_panel, textvariable=self.chat_input_var)
        self.chat_input_entry.grid(row=4, column=0, columnspan=2, sticky="ew", padx=10, pady=5) # Wiersz 4
        self.chat_input_entry.bind("<Key>", self._on_chat_input_key_press)
        self.chat_input_entry.bind("<Return>", self._send_chat_message)
        self.attach_file_icon = None

        # --- NOWE ZMIANY: RAMKA PODGLĄDU CYTOWANEJ WIADOMOŚCI (wiersz 5) ---
        # --- NOWE ZMIANY (CHAT KLIENT - Odpowiadanie) ---
        self.chat_reply_preview_frame = tk.Frame(self.chat_messages_panel, relief="solid", bd=1) # Zmieniono na tk.Frame i bd
        self.chat_reply_preview_frame.columnconfigure(0, weight=1)
        # --- KONIEC NOWYCH ZMIAN ---
        
        self.reply_preview_label = ttk.Label(self.chat_reply_preview_frame, text="", wraplength=300, justify=tk.LEFT, font=("Segoe UI", 8, "italic"))
        self.reply_preview_label.grid(row=0, column=0, sticky="ew")

        self.cancel_reply_button = ttk.Button(self.chat_reply_preview_frame, text="✖", command=self._cancel_reply_mode, width=2, style="Toolbutton.TButton")
        self.cancel_reply_button.grid(row=0, column=1, sticky="e", padx=(5,0))
        ToolTip(self.cancel_reply_button, "Anuluj odpowiadanie")
        # --- KONIEC NOWYCH ZMIAN ---

        # Ramka podglądu oczekującego załącznika (wiersz 6)
        self.chat_pending_attachment_frame = ttk.Frame(self.chat_messages_panel, style="ChatPendingAttachment.TFrame")
        self.chat_pending_attachment_icon_label = ttk.Label(self.chat_pending_attachment_frame, text="📄", font=("Segoe UI Symbol", 10), style="ChatPendingAttachment.TLabel")
        self.chat_pending_attachment_name_label = ttk.Label(self.chat_pending_attachment_frame, text="", wraplength=200, style="ChatPendingAttachment.TLabel")
        self.remove_pending_attachment_button = ttk.Button(self.chat_pending_attachment_frame, text="✖", command=self._clear_pending_chat_attachment, width=2, style="ChatPendingAttachment.Toolbutton.TButton")
        ToolTip(self.remove_pending_attachment_button, "Usuń załącznik")
        self.chat_pending_attachment_icon_label.pack(side=tk.LEFT, padx=(5,2))
        self.chat_pending_attachment_name_label.pack(side=tk.LEFT, padx=(0,5), expand=True, fill=tk.X)
        self.remove_pending_attachment_button.pack(side=tk.RIGHT, padx=(2,5))
        # Ramka podglądu będzie zarządzana (grid/grid_remove) przez _update_pending_attachment_ui()

        # Ramka dla przycisków Wyślij/Dołącz (wiersz 7)
        chat_action_buttons_frame = ttk.Frame(self.chat_messages_panel)
        chat_action_buttons_frame.grid(row=7, column=0, columnspan=2, pady=5, sticky="ew") # Wiersz 7
        chat_action_buttons_frame.columnconfigure(0, weight=1)
        chat_action_buttons_frame.columnconfigure(1, weight=0)
        # --- NOWE ZMIANY: Dodanie kolumny dla przycisku Emoji ---
        chat_action_buttons_frame.columnconfigure(2, weight=0) # Przycisk Emoji
        # --- KONIEC NOWYCH ZMIAN ---
        
        send_button = ttk.Button(chat_action_buttons_frame, text="Wyślij", command=self._send_chat_message)
        send_button.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        attach_file_icon_path = "icons/attach_16.png" 
        icon_size = (20, 20)
        if os.path.exists(attach_file_icon_path):
            try:
                img = Image.open(attach_file_icon_path).resize(icon_size, resampling)
                self.attach_file_icon = ImageTk.PhotoImage(img)
            except Exception as e:
                logging.error(f"Nie można załadować ikony dołączania pliku ({attach_file_icon_path}): {e}")
        
        if self.attach_file_icon:
            attach_button = ttk.Button(
                chat_action_buttons_frame, 
                text=" Dołącz", 
                image=self.attach_file_icon, 
                compound=tk.LEFT, 
                command=self._select_chat_attachment_dialog,
                style="Toolbutton.TButton", 
                width=8 
            )
            ToolTip(attach_button, "Dołącz plik (maks. 10MB)")
        else: 
            attach_button = ttk.Button(
                chat_action_buttons_frame, 
                text="📎 Dołącz Plik", 
                command=self._select_chat_attachment_dialog,
                width=12 
            )
            ToolTip(attach_button, "Dołącz plik (maks. 10MB)")
        attach_button.grid(row=0, column=1, sticky="e", padx=(5,0)) # Było column 1, sticky="e"
        
        # --- NOWE ZMIANY: Przycisk Emoji ---
        # Użyjemy prostego tekstu jako przycisku, aby uniknąć problemów z ikonami emoji na różnych systemach
        # Można też użyć obrazka .png z buźką, jeśli chcesz.
        self.emoji_button = ttk.Button(
            chat_action_buttons_frame,
            text="😊", # Prosty Unicode emoji
            command=self._open_emoji_picker,
            width=3, # Mały przycisk
            style="Toolbutton.TButton"
        )
        self.emoji_button.grid(row=0, column=2, sticky="e", padx=(5,0)) # Umieszczamy go po prawej od Dołącz
        ToolTip(self.emoji_button, "Wstaw Emoji")
        # --- KONIEC NOWYCH ZMIAN ---

        # Przycisk Wyloguj (wiersz 8)
        ttk.Button(self.chat_messages_panel, text="Wyloguj z Czatu", command=self._chat_logout).grid(row=8, column=0, columnspan=2, pady=(5,10), sticky="ew") # Wiersz 8

        # --- NOWE ZMIANY (Punkt 3.3 - Przycisk "Zmień Serwer" na panelu głównym czatu) ---
        change_server_btn_main_panel = ttk.Button(
            self.chat_messages_panel, 
            text="🌐 Zmień Serwer",
            command=self._go_to_server_selection_from_chat_main, # Metoda, która rozłącza i pokazuje stronę wyboru
            style="Toolbutton.TButton" 
        )
        change_server_btn_main_panel.grid(row=9, column=0, columnspan=2, pady=(2,10), sticky="ew")
        ToolTip(change_server_btn_main_panel, "Wróć do listy serwerów (rozłączy obecne połączenie)")
        
        # Upewnij się, że self.chat_messages_panel ma wystarczająco skonfigurowanych wierszy
        # (już to zrobiliśmy, dodając rowconfigure dla row=9 w poprzednich iteracjach)
        # self.chat_messages_panel.rowconfigure(9, weight=0) 
        # --- KONIEC NOWYCH ZMIAN ---

        # Konfiguracja rozciągania wierszy w chat_messages_panel
        self.chat_messages_panel.rowconfigure(0, weight=0) # Etykieta partnera
        self.chat_messages_panel.rowconfigure(1, weight=0) # Etykieta pisania
        self.chat_messages_panel.rowconfigure(2, weight=0) # Wyszukiwarka wiadomości
        self.chat_messages_panel.rowconfigure(3, weight=1) # Okno wiadomości (elastyczne)
        self.chat_messages_panel.rowconfigure(4, weight=0) # Pole wprowadzania (stałe)
        self.chat_messages_panel.rowconfigure(5, weight=0) # Podgląd cytowanej wiadomości (stałe)
        self.chat_messages_panel.rowconfigure(6, weight=0) # Podgląd załącznika (stałe)
        self.chat_messages_panel.rowconfigure(7, weight=0) # Przyciski akcji (stałe)
        self.chat_messages_panel.rowconfigure(8, weight=0) # Przycisk Wyloguj (stałe)
        
        # --- NOWE ZMIANY: Panel Członków Pokoju ---
        self.chat_room_members_panel = ttk.Frame(self.chat_paned_window, width=150) # Szerokość początkowa
        # Celowo NIE dodajemy go do self.chat_paned_window za pomocą .add() na tym etapie
        # Zostanie dodany dynamicznie, gdy będzie potrzebny.
        
        self.chat_room_members_panel.columnconfigure(0, weight=1)
        self.chat_room_members_panel.rowconfigure(1, weight=1) 

        members_header_label = ttk.Label(self.chat_room_members_panel, text="Członkowie Pokoju:", font=("Segoe UI", 9, "bold"))
        members_header_label.grid(row=0, column=0, padx=5, pady=(5,0), sticky="ew")

        self.room_members_listbox = tk.Listbox(self.chat_room_members_panel, bg="#2a2a2a", fg="lightgray", height=10)
        self.room_members_listbox.grid(row=1, column=0, padx=5, pady=5, sticky="nsew")
        members_list_scrollbar = ttk.Scrollbar(self.chat_room_members_panel, orient="vertical", command=self.room_members_listbox.yview)
        members_list_scrollbar.grid(row=1, column=1, sticky="ns", pady=5)
        self.room_members_listbox.config(yscrollcommand=members_list_scrollbar.set)
        # --- NOWE ZMIANY: Bindowanie prawego kliknięcia do Listboxa członków ---
        self.room_members_listbox.bind("<Button-3>", self._on_room_member_list_right_click)
        # --- KONIEC NOWYCH ZMIAN ---
        # Atrybut do śledzenia, czy panel członków jest aktualnie dodany do PanedWindow
        self._room_members_panel_visible = False 
        # --- KONIEC NOWYCH ZMIAN ---

# W klasie GameLauncher, metoda _open_emoji_picker

    # --- NOWA METODA ---
    def _open_chat_server_settings_dialog(self):
        """Otwiera okno dialogowe do edycji URL serwera czatu."""
        dialog = tk.Toplevel(self.chat_page_frame) # Rodzicem jest strona czatu
        dialog.title("Ustawienia Serwera Czatu")
        dialog.configure(bg=self.settings.get("background", "#1e1e1e"))
        dialog.grab_set()
        dialog.resizable(False, False)
        dialog.transient(self.chat_page_frame)

        # Wyśrodkuj dialog względem chat_page_frame
        self.chat_page_frame.update_idletasks()
        parent_x = self.chat_page_frame.winfo_rootx()
        parent_y = self.chat_page_frame.winfo_rooty()
        parent_w = self.chat_page_frame.winfo_width()
        parent_h = self.chat_page_frame.winfo_height()
        
        dialog_w = 450 # Szerokość okna dialogowego
        dialog_h = 150 # Wysokość okna dialogowego
        
        pos_x = parent_x + (parent_w // 2) - (dialog_w // 2)
        pos_y = parent_y + (parent_h // 2) - (dialog_h // 2)
        dialog.geometry(f"{dialog_w}x{dialog_h}+{pos_x}+{pos_y}")

        # Zawartość dialogu
        content_frame = ttk.Frame(dialog, padding=15)
        content_frame.pack(fill=tk.BOTH, expand=True)
        content_frame.columnconfigure(1, weight=1)

        ttk.Label(content_frame, text="Adres URL Serwera Czatu:").grid(row=0, column=0, padx=5, pady=10, sticky="w")
        
        # Użyj tymczasowej zmiennej dla Entry w dialogu, aby nie modyfikować self.chat_server_url_var
        # jeśli nie zostanie zapisane.
        temp_url_var = tk.StringVar(value=self.local_settings.get("chat_server_url", "http://127.0.0.1:5000"))
        url_entry = ttk.Entry(content_frame, textvariable=temp_url_var, width=45)
        url_entry.grid(row=0, column=1, padx=5, pady=10, sticky="ew")
        url_entry.focus_set()
        url_entry.selection_range(0, tk.END) # Zaznacz cały tekst

        button_frame = ttk.Frame(content_frame)
        button_frame.grid(row=1, column=0, columnspan=2, pady=10, sticky="e")

        def on_save():
            # Przypisz wartość z tymczasowej zmiennej do głównej zmiennej
            self.chat_server_url_var.set(temp_url_var.get()) 
            self._save_chat_server_url() # Wywołaj istniejącą metodę zapisu
            dialog.destroy()

        ttk.Button(button_frame, text="Zapisz", command=on_save).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Anuluj", command=dialog.destroy).pack(side=tk.LEFT)
    # --- KONIEC NOWEJ METODY ---


    def _open_emoji_picker(self):
        """Otwiera szersze, wyśrodkowane okno Toplevel z wyborem emoji i przewijaniem."""
        if hasattr(self, '_emoji_picker_window') and \
           self._emoji_picker_window is not None and \
           self._emoji_picker_window.winfo_exists():
            self._emoji_picker_window.lift()
            self._emoji_picker_window.focus_force()
            # --- NOWE ZMIANY: Ponowne centrowanie przy ponownym otwarciu ---
            parent_for_centering = self.chat_page_frame if hasattr(self, 'chat_page_frame') and self.chat_page_frame.winfo_exists() else self.root
            self._emoji_picker_window.update_idletasks() # Wymuś aktualizację rozmiaru
            win_w = self._emoji_picker_window.winfo_width()
            win_h = self._emoji_picker_window.winfo_height()
            parent_x = parent_for_centering.winfo_rootx()
            parent_y = parent_for_centering.winfo_rooty()
            parent_w = parent_for_centering.winfo_width()
            parent_h = parent_for_centering.winfo_height()
            x = parent_x + (parent_w // 2) - (win_w // 2)
            y = parent_y + (parent_h // 2) - (win_h // 2)
            self._emoji_picker_window.geometry(f"+{x}+{y}")
            # --- KONIEC NOWYCH ZMIAN ---
            return

        parent_window_for_picker = self.chat_page_frame if hasattr(self, 'chat_page_frame') and self.chat_page_frame.winfo_exists() else self.root
        self._emoji_picker_window = tk.Toplevel(parent_window_for_picker)
        self._emoji_picker_window.title("Wybierz Emoji")
        self._emoji_picker_window.configure(bg=self.settings.get("background", "#1e1e1e"))
        self._emoji_picker_window.transient(parent_window_for_picker) 
        
        # --- NOWE ZMIANY: Ustalanie rozmiaru okna emoji i dodawanie Canvas + Scrollbar ---
        emoji_button_width_approx = 35 # Przybliżona szerokość przycisku emoji (w tym mały padding)
        emoji_button_height_approx = 35 # Przybliżona wysokość przycisku emoji
        
        cols = 6 # Zwiększamy liczbę kolumn, np. do 6
        max_rows_visible = 4 # Ile rzędów emoji ma być widocznych bez przewijania
        
        # Paddingi wewnątrz ramki scrollable_emoji_buttons_frame
        inner_padding_x = 2 
        inner_padding_y = 2
        
        # Szerokość i wysokość przycisków z uwzględnieniem wewnętrznego paddingu grid
        button_grid_total_width = cols * (emoji_button_width_approx + 2 * inner_padding_x)
        
        # Szerokość scrollbara (przybliżona)
        scrollbar_width_approx = 20
        
        # Szerokość okna
        picker_width = button_grid_total_width + 2 * 5 + scrollbar_width_approx # 2*5 to padding głównej ramki emoji_canvas
        
        # Wysokość okna
        visible_buttons_height = max_rows_visible * (emoji_button_height_approx + 2 * inner_padding_y)
        picker_height = visible_buttons_height + 2 * 5 # 2*5 to padding głównej ramki emoji_canvas

        # Ustaw minsize, żeby scrollbar miał sens
        self._emoji_picker_window.minsize(picker_width, 100) # Minimalna sensowna wysokość
        # self._emoji_picker_window.geometry(f"{picker_width}x{picker_height}") # Ustaw geometrię
        # Geometry ustawimy po wycentrowaniu

        main_emoji_frame = ttk.Frame(self._emoji_picker_window, style="TFrame")
        main_emoji_frame.pack(fill=tk.BOTH, expand=True)
        main_emoji_frame.rowconfigure(0, weight=1)
        main_emoji_frame.columnconfigure(0, weight=1)

        emoji_canvas = tk.Canvas(main_emoji_frame, bg=self.settings.get("background", "#1e1e1e"), highlightthickness=0)
        emoji_canvas.grid(row=0, column=0, sticky="nsew")

        emoji_scrollbar = ttk.Scrollbar(main_emoji_frame, orient="vertical", command=emoji_canvas.yview)
        emoji_scrollbar.grid(row=0, column=1, sticky="ns")
        emoji_canvas.configure(yscrollcommand=emoji_scrollbar.set)

        self.scrollable_emoji_buttons_frame = ttk.Frame(emoji_canvas, style="TFrame", padding=5)
        scrollable_emoji_frame_id = emoji_canvas.create_window((0, 0), window=self.scrollable_emoji_buttons_frame, anchor="nw")

        def _configure_emoji_canvas(event):
            if emoji_canvas.winfo_exists() and self.scrollable_emoji_buttons_frame.winfo_exists():
                canvas_width = event.width
                emoji_canvas.itemconfig(scrollable_emoji_frame_id, width=canvas_width)
                # Ważne: update_idletasks przed bbox, aby rozmiar wewnętrznej ramki był poprawny
                self.scrollable_emoji_buttons_frame.update_idletasks()
                emoji_canvas.configure(scrollregion=emoji_canvas.bbox("all"))
        
        emoji_canvas.bind("<Configure>", _configure_emoji_canvas)
        self.scrollable_emoji_buttons_frame.bind("<Configure>", lambda e: _configure_emoji_canvas(e) if emoji_canvas.winfo_exists() else None)


        def _on_emoji_mousewheel(event):
            # ... (logika _on_emoji_mousewheel bez zmian) ...
            if emoji_canvas.winfo_exists(): 
                widget_under_cursor = self._emoji_picker_window.winfo_containing(event.x_root, event.y_root) if hasattr(self,'_emoji_picker_window') and self._emoji_picker_window.winfo_exists() else None
                is_emoji_area = False
                curr = widget_under_cursor
                while curr is not None:
                    if curr == emoji_canvas:
                        is_emoji_area = True
                        break
                    if curr == self._emoji_picker_window: 
                        break
                    try: curr = curr.master
                    except tk.TclError: break
                if is_emoji_area:
                    scroll_val = 0
                    if event.num == 5 or event.delta < 0:  
                        scroll_val = 1
                    elif event.num == 4 or event.delta > 0:  
                        scroll_val = -1
                    if scroll_val != 0:
                        view_start, view_end = emoji_canvas.yview()
                        if (scroll_val < 0 and view_start > 0.0001) or \
                           (scroll_val > 0 and view_end < 0.9999):
                            emoji_canvas.yview_scroll(scroll_val, "units")
                            return "break" 
        
        emoji_canvas.bind_all("<MouseWheel>", _on_emoji_mousewheel, add='+')
        # --- KONIEC NOWYCH ZMIAN (Rozmiar i Canvas) ---
        
        # Pozycjonowanie okna - PRZENIESIONE NA KONIEC, PO DODANIU ZAWARTOŚCI
        
        emoji_list = [ # Dużo emoji dla testu przewijania
            "😊", "👍", "❤️", "😂", "😢", "🤔", "🎉", "👋", "🙏", "🥳", "🤩", "😭", "🔥", "💯", "✅", "🌟",
            "💡", "🎈", "🎁", "🎄", "🎃", "👻", "💀", "👽", "🤖", "👾", "💩", "😀", "😃", "😄", "😁", "😆",
            "😅", "🤣", "🙂", "🙃", "😉", "😌", "😍", "🥰", "😘", "😗", "😙", "😚", "😋", "😛", "😝", "😜",
            "🤪", "🤨", "🧐", "🤓", "😎", "🥸", "🤩", "🥳", "😏", "😒", "😞", "😔", "😟", "😕", "🙁", "☹️",
            "😣", "😖", "😫", "😩", "🥺", "😢", "😭", "😤", "😠", "😡", "🤬", "🤯", "😳", "🥵", "🥶", "😱",
            "😨", "😰", "😥", "😓", "🤗", "🤔", "🤭", "🤫", "🤥", "😶", "🫠", "😮", "😯", "😲", "😴", "🤤",
            "😪", "😵", "😵‍💫", "🤐", "🥴", "🤢", "🤮", "🤧", "😷", "🤒", "🤕", "🤑", "🤠", "😈", "👿", "👹",
            "👺", "🤡", " Poole ", " Oggy ", " Ja ", " Jack ", " Markab ", " Joey ", " DeeDee ", " Kot ", " Psy ",
            "🍕", "🍔", "🍟", "🌭", "🍿", "🧂", "🥓", "🥚", "🍳", "🧇", "🥞", "🧈", "🍞", "🥐", "🥨", "🥯"
        ] # Dodano więcej emoji

        current_theme = self.settings.get('theme', 'Dark') 
        all_themes_dict = self.get_all_available_themes() 
        theme_def_val = all_themes_dict.get(current_theme, THEMES.get('Dark', {}))
        emoji_font_color = theme_def_val.get('button_foreground', 'white')
        s = ttk.Style()
        s.configure("Emoji.Toolbutton.TButton", font=("Segoe UI Emoji", 14), foreground=emoji_font_color) # Zwiększono font


        for i, emoji_char in enumerate(emoji_list):
            row, col = divmod(i, cols) # Użyj nowej wartości cols
            btn = ttk.Button(
                self.scrollable_emoji_buttons_frame,
                text=emoji_char,
                command=lambda e=emoji_char: self._insert_emoji(e),
                width=3, 
                style="Emoji.Toolbutton.TButton"
            )
            btn.grid(row=row, column=col, padx=inner_padding_x, pady=inner_padding_y)

        self._emoji_picker_window.bind("<FocusOut>", lambda e: self._close_emoji_picker_if_focus_lost(e))
        # --- NOWE ZMIANY: Ustaw fokus na canvasie, aby kółko myszy od razu działało ---
        emoji_canvas.focus_set() 
        # --- KONIEC NOWYCH ZMIAN ---
        
        # --- NOWE ZMIANY: Aktualizacja scrollregion i centrowanie okna PO dodaniu przycisków ---
        self.scrollable_emoji_buttons_frame.update_idletasks() 
        if emoji_canvas.winfo_exists():
            emoji_canvas.config(scrollregion=emoji_canvas.bbox("all"))

        # Centrowanie okna na rodzicu
        self._emoji_picker_window.update_idletasks() # Wymuś aktualizację rozmiaru okna emoji
        win_w = self._emoji_picker_window.winfo_width()
        win_h = self._emoji_picker_window.winfo_height()
        
        # Jeśli wysokość przekracza założoną picker_height, ogranicz ją
        if win_h > picker_height:
            win_h = picker_height
            self._emoji_picker_window.geometry(f"{win_w}x{win_h}") # Ustaw nową geometrię
            self._emoji_picker_window.update_idletasks() # Ponownie, aby zmiany były uwzględnione

        parent_x = parent_window_for_picker.winfo_rootx()
        parent_y = parent_window_for_picker.winfo_rooty()
        parent_w = parent_window_for_picker.winfo_width()
        parent_h = parent_window_for_picker.winfo_height()
        
        x_pos = parent_x + (parent_w // 2) - (win_w // 2)
        y_pos = parent_y + (parent_h // 2) - (win_h // 2)
        self._emoji_picker_window.geometry(f"+{x_pos}+{y_pos}")
        # --- KONIEC NOWYCH ZMIAN ---
        
    def _close_emoji_picker_if_focus_lost(self, event):
        """Zamyka okno wyboru emoji, jeśli straciło fokus na inny widget POZA tym oknem."""
        # Sprawdź, czy widget, który otrzymał fokus, jest dzieckiem okna emoji
        # Jeśli nie jest, zamknij okno emoji.
        # `event.widget` to widget, który stracił fokus (czyli samo okno emoji lub jego dziecko)
        # `self.root.focus_get()` to widget, który aktualnie ma fokus
        if hasattr(self, '_emoji_picker_window') and self._emoji_picker_window.winfo_exists():
            focused_widget = self.root.focus_get()
            if focused_widget:
                # Sprawdź, czy nowo sfokusowany widget nie jest częścią okna emoji
                is_child = False
                curr = focused_widget
                while curr is not None:
                    if curr == self._emoji_picker_window:
                        is_child = True
                        break
                    try:
                        curr = curr.master
                    except AttributeError: # np. curr jest self.root
                        break
                
                if not is_child:
                    self._emoji_picker_window.destroy()
                    self._emoji_picker_window = None # Wyczyść referencję
            else: # Nic nie ma fokusu (np. kliknięto poza aplikacją)
                self._emoji_picker_window.destroy()
                self._emoji_picker_window = None

    def _insert_emoji(self, emoji_char):
        """Wstawia wybrany znak emoji do pola wprowadzania wiadomości."""
        if hasattr(self, 'chat_input_entry') and self.chat_input_entry.winfo_exists():
            try:
                current_cursor_pos = self.chat_input_entry.index(tk.INSERT)
                self.chat_input_var.set(
                    self.chat_input_var.get()[:current_cursor_pos] +
                    emoji_char +
                    self.chat_input_var.get()[current_cursor_pos:]
                )
                # Ustaw kursor za wstawionym emoji
                self.chat_input_entry.icursor(current_cursor_pos + len(emoji_char))
                self.chat_input_entry.focus_set() # Przywróć fokus do pola wpisywania
            except tk.TclError as e:
                logging.error(f"Błąd TclError podczas wstawiania emoji: {e}")
            except Exception as e:
                logging.exception(f"Nieoczekiwany błąd podczas wstawiania emoji: {e}")

        # Zamknij okno wyboru emoji po wstawieniu
        if hasattr(self, '_emoji_picker_window') and self._emoji_picker_window.winfo_exists():
            self._emoji_picker_window.destroy()
            self._emoji_picker_window = None # Wyczyść referencję


    def _on_room_member_list_right_click(self, event):
        """Wyświetla menu kontekstowe dla klikniętego członka na liście członków pokoju."""
        if not hasattr(self, 'room_members_listbox') or not self.room_members_listbox.winfo_exists():
            return

        clicked_index = self.room_members_listbox.nearest(event.y)
        item_bbox = self.room_members_listbox.bbox(clicked_index)
        if not item_bbox:
            logging.debug("Kliknięto prawym na pustym miejscu panelu członków pokoju.")
            return 
            
        # --- NOWE ZMIANY (Członkowie Pokoju - Zarządzanie Admina ETAP 2/3) ---
        # Pobierz ID i nazwę użytkownika bezpośrednio z przechowywanych danych, jeśli to możliwe.
        # Zakładamy, że _load_and_display_room_members przechowuje listę słowników {'id': ..., 'username': ...}
        # w self._current_room_members_details (trzeba będzie to dodać).
        # Na razie, jeśli to nie jest dostępne, użyjemy starej metody parsowania.
        
        target_user_id = None
        username_from_list = ""

        # Bezpieczne pobranie aktualnie wybranego pokoju (potrzebne do sprawdzenia creator_id)
        active_room_id = None
        if self.active_chat_type == "room" and self.active_chat_partner_id is not None:
            active_room_id = self.active_chat_partner_id
        
        current_room_data = self.chat_rooms.get(active_room_id) if active_room_id else None

        if hasattr(self, '_last_loaded_room_members_details') and \
           current_room_data and \
           clicked_index >= 0 and clicked_index < len(self._last_loaded_room_members_details):
            
            member_detail = self._last_loaded_room_members_details[clicked_index]
            target_user_id = member_detail.get('id')
            username_from_list = member_detail.get('username', "BłądNazwy")
            logging.debug(f"Pobrano dane członka z _last_loaded_room_members_details: ID={target_user_id}, Nick={username_from_list}")
        else: # Fallback na parsowanie, jeśli _last_loaded_room_members_details nie działa
            selected_display_text = self.room_members_listbox.get(clicked_index)
            username_from_list = selected_display_text[2:].strip()
            for uid, udata in self.chat_users.items():
                if udata.get('username') == username_from_list:
                    target_user_id = uid
                    break
            logging.debug(f"Fallback: Parsowano dane członka: ID={target_user_id}, Nick={username_from_list}")

        if target_user_id is None:
            logging.warning(f"Nie można znaleźć ID dla użytkownika '{username_from_list}' z listy członków (kliknięto index: {clicked_index}).")
            return

        if not self.chat_logged_in_user: return

        context_menu_members = tk.Menu(self.room_members_listbox, tearoff=0, background="#2e2e2e", foreground="white")
        is_self_clicked = (target_user_id == self.chat_logged_in_user['user_id'])

        if is_self_clicked:
            context_menu_members.add_command(label=f"{username_from_list} (To Ty)", state=tk.DISABLED)
        else:
            context_menu_members.add_command(
                label=f"Wyślij prywatną wiadomość do {username_from_list}",
                command=lambda uid=target_user_id, uname=username_from_list: self._start_private_chat_from_room_context(uid, uname)
            )

        # Opcje administratora pokoju
        if current_room_data and current_room_data.get('creator_id') == self.chat_logged_in_user['user_id']:
            if not is_self_clicked: # Admin nie może wyrzucić sam siebie przez to menu
                context_menu_members.add_separator()
                context_menu_members.add_command(
                    label=f"Usuń {username_from_list} z pokoju",
                    command=lambda rid=active_room_id, uid_rem=target_user_id, uname_rem=username_from_list: 
                                self._admin_remove_user_from_room_action(rid, uid_rem, uname_rem)
                )
        # --- KONIEC NOWYCH ZMIAN ---

        if context_menu_members.index("end") is not None: 
            context_menu_members.post(event.x_root, event.y_root)

    # --- NOWA METODA (Samodzielne opuszczanie pokoju) ---
    def _confirm_self_leave_room(self, room_id: int, room_name: str):
        """Pyta o potwierdzenie i opcjonalnie nazwę pokoju przed opuszczeniem."""
        if not self.chat_logged_in_user: return

        # --- NOWE ZMIANY (CHAT KLIENT - Usuwanie pokoju przez twórcę) ---
        is_creator_leaving = False
        room_data = self.chat_rooms.get(room_id)
        if room_data and room_data.get('creator_id') == self.chat_logged_in_user['user_id']:
            is_creator_leaving = True
            
        confirmation_message = f"Czy na pewno chcesz opuścić pokój '{room_name}'?"
        if is_creator_leaving:
            confirmation_message += ("\n\n⚠️ Jesteś twórcą tego pokoju. "
                                     "Opuszczenie go spowoduje jego trwałe usunięcie dla wszystkich członków!")
        # --- KONIEC NOWYCH ZMIAN ---

        confirm_first_step = messagebox.askyesno(
            "Opuść Pokój",
            confirmation_message, # Użyj zmodyfikowanej wiadomości
            icon='warning' if is_creator_leaving else 'question', # Inna ikona dla twórcy
            parent=self.chat_page_frame
        )
        if not confirm_first_step:
            return

        # Potwierdzenie przez wpisanie nazwy - pozostaje bez zmian
        entered_name = simpledialog.askstring(
            "Potwierdź Nazwę Pokoju",
            f"Aby potwierdzić, wpisz pełną nazwę pokoju:\n'{room_name}'",
            parent=self.chat_page_frame
        )

        if entered_name is None: 
            return
        if entered_name.strip() != room_name:
            messagebox.showerror("Błędna Nazwa", "Wpisana nazwa nie zgadza się z nazwą pokoju. Operacja anulowana.", parent=self.chat_page_frame)
            return
        
        self._execute_self_leave_room(room_id, room_name) # Wywołanie bez zmian

    def _execute_self_leave_room(self, room_id: int, room_name_for_log: str):
        """Wysyła żądanie opuszczenia pokoju przez zalogowanego użytkownika."""
        user_id_leaving = self.chat_logged_in_user['user_id']
        
        def leave_room_thread():
            try:
                headers = {'Content-Type': 'application/json', 'X-Initiator-User-ID': str(user_id_leaving)}
                # Ciało żądania jest puste lub może zawierać user_id_leaving jako admin_id dla spójności z logiką serwera
                payload = {} # Możemy zostawić puste lub dodać {'admin_id': user_id_leaving}
                                # Jeśli serwer sprawdza `data.get('admin_id')`, to puste payload nie przekaże admin_id.
                                # Jeśli chcemy, by `admin_id_from_request == user_id_to_leave` działało na serwerze,
                                # musimy wysłać `admin_id`.

                response = requests.delete(
                    f"{self.chat_server_url}/rooms/{room_id}/members/{user_id_leaving}", # user_id_leaving to my sami
                    json=payload, # Lub json={'admin_id': user_id_leaving} dla drugiej części warunku na serwerze
                    headers=headers,
                    timeout=10
                )
                response.raise_for_status()
                
                # Sukces - serwer wyśle event 'member_left_room'
                self.root.after(0, lambda rn=room_name_for_log: messagebox.showinfo(
                    "Opuszczono Pokój",
                    f"Pomyślnie opuściłeś pokój '{rn}'.",
                    parent=self.chat_page_frame
                ))
                # Nie ma potrzeby odświeżania tutaj, bo event 'member_left_room' to zrobi
            except requests.exceptions.HTTPError as e_http:
                err_data = e_http.response.json() if e_http.response and e_http.response.content else {}
                error_message = err_data.get('error', f"Błąd serwera (HTTP {e_http.response.status_code})")
                self.root.after(0, lambda msg=error_message: messagebox.showerror(
                    "Błąd Opuszczania Pokoju", msg, parent=self.chat_page_frame
                ))
            except requests.exceptions.RequestException as e_req:
                 self.root.after(0, lambda: messagebox.showerror(
                    "Błąd Sieci", f"Błąd połączenia: {e_req}", parent=self.chat_page_frame
                ))

        threading.Thread(target=leave_room_thread, daemon=True).start()
    # --- KONIEC NOWYCH METOD ---

    # --- NOWA METODA ---
    def _admin_remove_user_from_room_action(self, room_id: int, user_id_to_remove: int, username_to_remove: str):
        """Wywołuje akcję usunięcia użytkownika z pokoju przez admina."""
        if not self.chat_logged_in_user: return

        confirm_msg = (f"Czy na pewno chcesz usunąć użytkownika '{username_to_remove}' (ID: {user_id_to_remove})\n"
                       f"z pokoju (ID: {room_id})?")
        if messagebox.askyesno("Potwierdź Usunięcie Członka", confirm_msg, icon='warning', parent=self.chat_page_frame):
            
            def remove_member_thread():
                try:
                    payload = {"admin_id": self.chat_logged_in_user['user_id']}
                    response = requests.delete(
                        f"{self.chat_server_url}/rooms/{room_id}/members/{user_id_to_remove}",
                        json=payload,
                        timeout=10
                    )
                    response.raise_for_status() # Rzuci wyjątek dla 4xx/5xx
                    
                    # Sukces - serwer wyśle event 'member_removed_from_room',
                    # który powinien odświeżyć listę członków dla wszystkich.
                    # Możemy tu opcjonalnie pokazać komunikat dla admina.
                    self.root.after(0, lambda: messagebox.showinfo(
                        "Usunięto Członka",
                        f"Użytkownik '{username_to_remove}' został pomyślnie usunięty z pokoju.",
                        parent=self.chat_page_frame
                    ))
                    logging.info(f"Admin (ID: {self.chat_logged_in_user['user_id']}) usunął użytkownika {user_id_to_remove} z pokoju {room_id}.")
                    
                    # Odświeżenie listy członków w UI admina (na wypadek gdyby event SocketIO nie doszedł lub dla natychmiastowego efektu)
                    if self.active_chat_type == "room" and self.active_chat_partner_id == room_id:
                        self.root.after(100, self._load_and_display_room_members, room_id)

                except requests.exceptions.HTTPError as e_http:
                    err_data = e_http.response.json() if e_http.response and e_http.response.content else {}
                    error_message = err_data.get('error', f"Błąd serwera (HTTP {e_http.response.status_code})")
                    self.root.after(0, lambda: messagebox.showerror(
                        "Błąd Usuwania Członka", 
                        f"Nie udało się usunąć użytkownika '{username_to_remove}':\n{error_message}",
                        parent=self.chat_page_frame
                    ))
                    logging.error(f"Błąd HTTP podczas usuwania członka {user_id_to_remove} z pokoju {room_id}: {error_message}")
                except requests.exceptions.RequestException as e_req:
                    self.root.after(0, lambda: messagebox.showerror(
                        "Błąd Sieci", 
                        f"Błąd połączenia podczas próby usunięcia członka:\n{e_req}",
                        parent=self.chat_page_frame
                    ))
                    logging.error(f"Błąd sieciowy podczas usuwania członka: {e_req}")

            threading.Thread(target=remove_member_thread, daemon=True).start()
    # --- KONIEC NOWEJ METODY ---

    def _start_private_chat_from_room_context(self, target_user_id: int, target_username: str):
        """Przełącza na czat prywatny z wybranym użytkownikiem."""
        logging.info(f"Próba rozpoczęcia czatu prywatnego z {target_username} (ID: {target_user_id}) z kontekstu pokoju.")

        if not self.chat_logged_in_user:
            return

        if target_user_id == self.chat_logged_in_user['user_id']:
            messagebox.showinfo("Informacja", "Nie możesz rozpocząć czatu sam ze sobą.", parent=self.chat_page_frame)
            return

        # Upewnij się, że użytkownik docelowy istnieje w `self.chat_users` i `self.chat_users_tree`
        target_user_iid = f"{self.CHAT_PREFIX_USER}{target_user_id}"
        if not (target_user_id in self.chat_users and hasattr(self, 'chat_users_tree') and self.chat_users_tree.exists(target_user_iid)):
            messagebox.showerror("Błąd", f"Nie można znaleźć użytkownika '{target_username}' na głównej liście kontaktów.", parent=self.chat_page_frame)
            self._fetch_chat_users() # Odśwież na wszelki wypadek
            return

        # Zapisz bieżący (grupowy) czat, żeby można było do niego wrócić
        # self._last_open_group_chat_id_before_private_switch = self.active_chat_partner_id 
        # Ta zmienna mogłaby być użyta do przycisku "Wróć do pokoju"
        
        # Przełącz typ czatu i partnera
        self.active_chat_type = "user"
        self.active_chat_partner_id = target_user_id
        # Ukryj panel członków pokoju, bo przechodzimy do czatu prywatnego
        if self._room_members_panel_visible:
            try:
                self.chat_paned_window.forget(self.chat_room_members_panel)
            except tk.TclError:
                 logging.warning("TclError przy forget(self.chat_room_members_panel) w _start_private_chat_from_room_context")
            self._room_members_panel_visible = False

        # Ustaw zaznaczenie i fokus na użytkowniku w głównym Treeview kontaktów
        try:
            self.chat_users_tree.selection_set(target_user_iid)
            self.chat_users_tree.focus(target_user_iid)
            self.chat_users_tree.see(target_user_iid) # Upewnij się, że jest widoczny
            
            # Symuluj wybór, aby załadować historię itd. (wywoła _on_chat_user_select)
            # Event_generate jest bezpieczniejszy niż bezpośrednie wywołanie metody
            self.chat_users_tree.event_generate("<<TreeviewSelect>>")
            
            # Aktualizuj etykietę "Czat z:" od razu
            if hasattr(self, 'chat_active_partner_label'):
                self.chat_active_partner_label.config(text=f"Czat z: {target_username}")

        except tk.TclError as e:
            logging.error(f"Błąd TclError podczas programowego wybierania użytkownika '{target_username}': {e}")
            messagebox.showerror("Błąd Nawigacji Czatu", "Nie udało się przełączyć na czat prywatny.", parent=self.chat_page_frame)
        except Exception as e:
            logging.exception(f"Nieoczekiwany błąd w _start_private_chat_from_room_context dla '{target_username}': {e}")

    # --- NOWA METODA POMOCNICZA ---
    def _get_active_server_data(self) -> dict | None:
        """Zwraca słownik danych dla aktywnego serwera lub None."""
        if self.active_chat_server_id and self.chat_servers_list:
            for server_data in self.chat_servers_list:
                if server_data.get("id") == self.active_chat_server_id:
                    return server_data
        elif self.chat_servers_list: # Jeśli active_id nie ma, ale lista jest, weź pierwszy
            self.active_chat_server_id = self.chat_servers_list[0].get("id") # Ustaw pierwszy jako aktywny
            logging.warning("Brak active_chat_server_id, ustawiono pierwszy serwer z listy jako aktywny.")
            return self.chat_servers_list[0]
        return None
    # --- KONIEC NOWEJ METODY ---

    # Nowe metody do blokowania/odblokowywania
    def _block_chat_user(self, user_id_to_block: int, username_to_block: str):
        if not self.chat_logged_in_user: return

        if messagebox.askyesno("Zablokuj Użytkownika", 
                               f"Czy na pewno chcesz zablokować użytkownika '{username_to_block}'?\n"
                               "Nie będziesz mógł wysyłać do niego wiadomości.",
                               icon='warning', parent=self.chat_page_frame):
            
            self.blocked_user_ids.add(user_id_to_block)
            self.local_settings["chat_blocked_user_ids"] = list(self.blocked_user_ids)
            save_local_settings(self.local_settings)
            logging.info(f"Użytkownik {self.chat_logged_in_user['username']} zablokował {username_to_block} (ID: {user_id_to_block}).")
            
            # Prosta "symulacja" wysłania na serwer
            def block_on_server_thread():
                try:
                    # --- NOWE ZMIANY ---
                    payload = {"blocker_id": self.chat_logged_in_user['user_id']}
                    response = requests.post(
                        f"{self.chat_server_url}/users/{user_id_to_block}/block",
                        json=payload, # Wysyłamy kto blokuje
                        headers={'Content-Type': 'application/json'},
                        timeout=5
                    )
                    # --- KONIEC NOWYCH ZMIAN ---
                    if response.status_code == 201 or response.status_code == 200:
                        logging.info(f"Serwer potwierdził zablokowanie użytkownika ID: {user_id_to_block}")
                    else:
                        error_data = response.json() if response.content else {}
                        logging.warning(f"Serwer zwrócił błąd {response.status_code} przy blokowaniu {user_id_to_block}: {error_data.get('error', 'Nieznany błąd')}")
                except requests.RequestException as e_block_req:
                    logging.error(f"Błąd sieciowy przy próbie blokowania użytkownika: {e_block_req}")

            threading.Thread(target=block_on_server_thread, daemon=True).start()
            
            self._update_chat_ui_for_blocked_status() # Odśwież UI, jeśli ten user był aktywny
            self._filter_chat_users() # Odśwież listę kontaktów (może dodać ikonę blokady)

    def _unblock_chat_user(self, user_id_to_unblock: int, username_to_unblock: str):
        if not self.chat_logged_in_user: return

        if user_id_to_unblock in self.blocked_user_ids:
            self.blocked_user_ids.remove(user_id_to_unblock)
            self.local_settings["chat_blocked_user_ids"] = list(self.blocked_user_ids)
            save_local_settings(self.local_settings)
            logging.info(f"Użytkownik {self.chat_logged_in_user['username']} odblokował {username_to_unblock} (ID: {user_id_to_unblock}).")

            # Symulacja wysłania na serwer
            def unblock_on_server_thread():
                try:
                    # --- NOWE ZMIANY ---
                    payload = {"unblocker_id": self.chat_logged_in_user['user_id']}
                    response = requests.delete(
                        f"{self.chat_server_url}/users/{user_id_to_unblock}/block", 
                        json=payload, # Wysyłamy kto odblokowuje
                        headers={'Content-Type': 'application/json'},
                        timeout=5
                    )
                    # --- KONIEC NOWYCH ZMIAN ---
                    if response.status_code == 200 or response.status_code == 204:
                         logging.info(f"Serwer potwierdził odblokowanie użytkownika ID: {user_id_to_unblock}")
                    else:
                        error_data = response.json() if response.content else {}
                        logging.warning(f"Serwer zwrócił błąd {response.status_code} przy odblokowywaniu {user_id_to_unblock}: {error_data.get('error', 'Nieznany błąd')}")
                except requests.RequestException as e_unblock_req:
                    logging.error(f"Błąd sieciowy przy próbie (stub) odblokowania użytkownika: {e_unblock_req}")

            threading.Thread(target=unblock_on_server_thread, daemon=True).start()

            self._update_chat_ui_for_blocked_status() # Odśwież UI
            self._filter_chat_users() # Odśwież listę kontaktów

    # --- NOWA METODA: Obsługa prawego kliknięcia na liście czatu ---
    def _on_chat_list_right_click(self, event):
        item_iid = self.chat_users_tree.identify_row(event.y)
        if not item_iid: return

        # --- ZMIANA: Ustaw selekcję i fokus ZAWSZE, niezależnie od tego czy to ten sam element ---
        # To jest ważne dla logiki, która bazuje na aktualnie zaznaczonym (focused) elemencie
        # nawet jeśli menu kontekstowe jest wołane dla elementu, który jest tylko pod kursorem.
        current_selection = self.chat_users_tree.selection()
        if not current_selection or current_selection[0] != item_iid:
            self.chat_users_tree.selection_set(item_iid) # Ustaw zaznaczenie na kliknięty
        self.chat_users_tree.focus(item_iid) # Ustaw fokus na kliknięty
        # --- KONIEC ZMIANY ---


        context_menu = tk.Menu(self.chat_page_frame, tearoff=0, background="#2e2e2e", foreground="white")
        
        item_type = None
        if item_iid.startswith(self.CHAT_PREFIX_USER):
            item_type = "user"
            user_id_pure = int(item_iid[len(self.CHAT_PREFIX_USER):])
            user_data = self.chat_users.get(user_id_pure)
            username = user_data.get('username', f"ID_{user_id_pure}") if user_data else f"ID_{user_id_pure}"

            context_menu.add_command(label="Rozpocznij czat prywatny", 
                                     command=lambda iid=item_iid: self._initiate_chat_from_context_menu(iid))
            
            # --- NOWE ZMIANY (Blokowanie użytkowników czatu) ---
            if self.chat_logged_in_user and user_id_pure != self.chat_logged_in_user['user_id']: # Nie można blokować samego siebie
                if self._is_user_blocked(user_id_pure):
                    context_menu.add_command(
                        label=f"🔓 Odblokuj {username}",
                        command=lambda uid=user_id_pure, uname=username: self._unblock_chat_user(uid, uname)
                    )
                else:
                    context_menu.add_command(
                        label=f"🚫 Zablokuj {username}",
                        command=lambda uid=user_id_pure, uname=username: self._block_chat_user(uid, uname)
                    )
            # --- KONIEC NOWYCH ZMIAN ---
        elif item_iid.startswith(self.CHAT_PREFIX_ROOM):
            item_type = "room"
            room_id_pure = int(item_iid[len(self.CHAT_PREFIX_ROOM):])
            room_data = self.chat_rooms.get(room_id_pure)
            
            if room_data:
                room_name_for_menu = room_data.get('name', f"Pokój ID {room_id_pure}")
                
                # --- NOWA, BARDZIEJ NIEZAWODNA LOGIKA POKAZYWANIA OPCJI DOŁĄCZ/OPUŚĆ ---
                is_current_user_member = False
                if self.chat_logged_in_user:
                    user_id = self.chat_logged_in_user['user_id']
                    # Sprawdź, czy user_id jest na liście członków pobranej z serwera
                    if user_id in room_data.get('member_ids', []):
                        is_current_user_member = True
                
                if is_current_user_member:
                    # --- NOWE ZMIANY (CHAT KLIENT - Samodzielne opuszczanie pokoju) ---
                    context_menu.add_command(
                        label=f"🚪 Opuść pokój '{room_name_for_menu}'", 
                        command=lambda rid=room_id_pure, rname=room_name_for_menu: self._confirm_self_leave_room(rid, rname)
                    )
                    # --- KONIEC NOWYCH ZMIAN ---
                else:
                    context_menu.add_command(
                        label=f"Dołącz do pokoju '{room_name_for_menu}'", 
                        command=lambda rid=room_id_pure: self._join_room_dialog(rid)
                    )
                # --- KONIEC NOWEJ LOGIKI ---

                # Dodatkowa opcja (zawsze dostępna, jeśli pokój istnieje) - rozpoczęcie czatu/wejście
                context_menu.add_separator()
                context_menu.add_command(label=f"Otwórz czat pokoju '{room_name_for_menu}'",
                                         command=lambda iid_to_select=item_iid: self._initiate_chat_from_context_menu(iid_to_select))

            else:
                context_menu.add_command(label="Błąd: Brak danych pokoju", state=tk.DISABLED)
        else: 
            return 

        if context_menu.index("end") is not None: 
            context_menu.post(event.x_root, event.y_root)

    # --- NOWA METODA POMOCNICZA DO INICJOWANIA CZATU Z MENU KONTEKSTOWEGO ---
    def _initiate_chat_from_context_menu(self, item_iid_to_select: str):
        """
        Wywoływana z menu kontekstowego, aby "wejść" do czatu z użytkownikiem lub pokojem.
        Po prostu generuje event <<TreeviewSelect>>, aby _on_chat_user_select się wykonało.
        """
        if hasattr(self, 'chat_users_tree') and self.chat_users_tree.winfo_exists():
            if self.chat_users_tree.exists(item_iid_to_select):
                # Upewnij się, że element jest zaznaczony i ma fokus PRZED generowaniem eventu
                current_selection = self.chat_users_tree.selection()
                if not current_selection or current_selection[0] != item_iid_to_select:
                    self.chat_users_tree.selection_set(item_iid_to_select)
                self.chat_users_tree.focus(item_iid_to_select)
                self.chat_users_tree.see(item_iid_to_select) # Przewiń do widoku
                
                # Wygeneruj event, aby odpalić _on_chat_user_select
                self.chat_users_tree.event_generate("<<TreeviewSelect>>")
            else:
                logging.warning(f"_initiate_chat_from_context_menu: Item IID '{item_iid_to_select}' nie istnieje w Treeview.")
    # --- KONIEC NOWEJ METODY POMOCNICZEJ ---

    # --- NOWA METODA: Opuszczanie pokoju ---
    # --- ZMODYFIKOWANA METODA ---
    # --- ZMODYFIKOWANA METODA ---
    def _leave_room_action(self, room_id: int):
        if not self.chat_logged_in_user:
            logging.warning("Chat: Próba opuszczenia pokoju bez zalogowanego użytkownika.")
            return

        room_data = self.chat_rooms.get(room_id)
        room_name_for_dialog = room_data.get('name', f"Pokój ID {room_id}") if room_data else f"Pokój ID {room_id}"

        if not messagebox.askyesno("Opuść Pokój", f"Czy na pewno chcesz opuścić pokój '{room_name_for_dialog}'?", parent=self.chat_page_frame):
            return
        
        user_id_leaving = self.chat_logged_in_user['user_id']
        logging.info(f"Chat: Użytkownik {self.chat_logged_in_user['username']} (ID: {user_id_leaving}) próbuje opuścić pokój ID: {room_id}")

        def send_leave_request_thread():
            try:
                # --- NOWA ZMIANA: Usunięcie json={} ---
                # Zmieniamy endpoint na taki, który bierze ID użytkownika z URL,
                # a serwer zakłada, że jeśli nie ma admin_id w payload (którego nie wysyłamy),
                # to user_id_leaving z URL jest tym, kto opuszcza.
                response = requests.delete(
                    f"{self.chat_server_url}/rooms/{room_id}/members/{user_id_leaving}", # user_id_leaving w URL
                    timeout=10
                    # json={} Zostało usunięte, aby uniknąć wysyłania Content-Type: application/json dla pustego ciała
                )
                # --- KONIEC NOWEJ ZMIANY ---
                response.raise_for_status() 
                
                leave_data = response.json()
                self.root.after(0, lambda msg=leave_data.get("message", f"Opuszczono pokój '{room_name_for_dialog}'."), rid=room_id, uid_left=user_id_leaving:
                                self._handle_leave_room_success(msg, rid, uid_left))

            except requests.exceptions.HTTPError as e_http:
                error_msg_title = f"Błąd Opuszczania Pokoju '{room_name_for_dialog}'"
                error_msg_detail = "Nieznany błąd serwera."
                response_text_for_log = "(brak odpowiedzi)"

                if e_http.response is not None:
                    status_code = e_http.response.status_code
                    response_text_for_log = e_http.response.text if e_http.response.text else "(pusta odpowiedź)"
                    try:
                        json_response = e_http.response.json()
                        server_error = json_response.get('error')
                        if server_error:
                            error_msg_detail = f"Serwer: {server_error} (HTTP {status_code})"
                        else:
                            error_msg_detail = f"Błąd HTTP {status_code}. Odpowiedź serwera nie zawierała szczegółów błędu."
                    except json.JSONDecodeError:
                        error_msg_detail = f"Błąd HTTP {status_code}. Odpowiedź serwera nie była w formacie JSON."
                        if len(response_text_for_log) > 100: response_text_for_log = response_text_for_log[:100] + "..."
                        error_msg_detail += f"\nFragment odpowiedzi: {response_text_for_log}"

                logging.error(f"Chat: Błąd HTTP ({status_code if 'status_code' in locals() else 'N/A'}) przy opuszczaniu pokoju {room_id} przez {user_id_leaving}: {error_msg_detail}. Raw response: {response_text_for_log}")
                self.root.after(0, lambda: messagebox.showerror(error_msg_title, error_msg_detail, parent=self.chat_page_frame))
            except requests.exceptions.RequestException as e_req:
                # ... (obsługa błędów sieci bez zmian) ...
                error_message_req = f"Błąd sieci podczas próby opuszczenia pokoju '{room_name_for_dialog}':\n{e_req}"
                self.root.after(0, lambda: messagebox.showerror("Błąd Sieci", error_message_req, parent=self.chat_page_frame))
                logging.error(f"Chat: Błąd sieci podczas opuszczania pokoju {room_id}: {e_req}")
            except Exception as e_generic:
                # ... (obsługa innych błędów bez zmian) ...
                error_message_gen = f"Nieoczekiwany błąd podczas opuszczania pokoju '{room_name_for_dialog}':\n{e_generic}"
                self.root.after(0, lambda: messagebox.showerror("Błąd Krytyczny", error_message_gen, parent=self.chat_page_frame))
                logging.exception(f"Chat: Nieoczekiwany błąd opuszczania pokoju {room_id}: {e_generic}")

        threading.Thread(target=send_leave_request_thread, daemon=True).start()
    # --- KONIEC ZMODYFIKOWANEJ METODY ---

    # --- ZMIENIONA METODA ---
    def _handle_leave_room_success(self, success_message: str, room_id_left: int, user_id_left: int):
        messagebox.showinfo("Sukces", success_message, parent=self.chat_page_frame)
        logging.info(f"Chat: Użytkownik {user_id_left} pomyślnie opuścił pokój ID: {room_id_left} (odpowiedź HTTP).")

        # Upewnij się, że to my opuściliśmy, zanim wykonamy operacje UI dla opuszczającego
        is_self_action = self.chat_logged_in_user and user_id_left == self.chat_logged_in_user['user_id']

        if is_self_action:
            # Krok 1: Poinformuj serwer Socket.IO, że opuszczamy pokój
            if self.sio and self.sio.connected:
                self.sio.emit('leave_specific_room', {'room_id': room_id_left})
                logging.debug(f"Chat: Wysłano 'leave_specific_room' (room: {room_id_left}) do serwera Socket.IO.")
            
            # Krok 2: Zaktualizuj stan wewnętrzny klienta
            # --- NOWE ZMIANY: Upewnij się, że aktualizujemy stan *PRZED* odświeżaniem UI ---
            if self.active_chat_type == "room" and self.active_chat_partner_id == room_id_left:
                self.active_chat_partner_id = self.chat_dashboard_placeholder_id
                self.active_chat_type = "dashboard" # Ustaw typ na dashboard
                self._current_chat_participants = {} 
                logging.debug(f"Zmieniono aktywny czat na Dashboard po opuszczeniu pokoju {room_id_left}.")
            
            # Usunięcie pokoju z listy członkostw (jeśli klient ją gdzieś trzyma lokalnie poza Treeview)
            # - na razie polegamy na `_fetch_chat_users` aby zaktualizować `self.chat_rooms`.
            # --- KONIEC NOWYCH ZMIAN ---
        
        # Krok 3: Zawsze pobierz świeże dane użytkowników/pokojów
        # To powinno odświeżyć listę pokoi po lewej i tagi (np. że nie jesteśmy już członkiem).
        # Wywołaj z małym opóźnieniem, aby dać serwerowi SocketIO czas na przetworzenie `leave_specific_room` (jeśli to istotne dla stanu pokoi)
        # Ale `_fetch_chat_users` uderza w HTTP, więc to powinno być spójne z bazą.
        self.root.after(100, self._fetch_chat_users) 

        # Krok 4: Jeśli to my opuściliśmy I był to nasz aktywny czat, odśwież prawy panel
        if is_self_action and self.active_chat_type == "dashboard": # Sprawdź, czy typ jest już "dashboard"
            logging.debug("Opuszczono aktywny pokój, odświeżanie widoku na dashboard...")
            
            # Wyczyść pole wiadomości i wskaźnik pisania natychmiast
            self._display_chat_message("", "clear") 
            if hasattr(self, 'chat_typing_indicator_label') and self.chat_typing_indicator_label.winfo_exists():
                self.chat_typing_indicator_label.config(text="")

            # Odśwież panel czatu na dashboard po chwili (po tym jak _fetch_chat_users zaktualizuje listę po lewej)
            # To wywołanie ustawi etykietę partnera, pokaże panel członków itp.
            self.root.after(200, lambda: (
                self._show_chat_dashboard(), # Pokaż zawartość dashboardu
                self._update_chat_ui_state(), # Upewnij się, że panele są poprawnie pokazane/ukryte
                                              # To jest kluczowe, aby pokazać chat_main_panel jeśli był ukryty.
                # Ukryj panel członków pokoju, bo dashboard nie ma członków
                self._show_or_hide_room_members_panel(show=False) # Używamy teraz tej funkcji
            ))
        
        # Aktualizuj przycisk "Usuń playlistę" w odtwarzaczu muzyki
        # (Ten wiersz był pomyłką, pochodzi z kontekstu muzyki, tu niepotrzebny)
        # self._update_delete_playlist_button_state()
    # --- KONIEC ZMIENIONEJ METODY ---

    # --- NOWA METODA: Dialog dołączania do pokoju ---
    def _join_room_dialog(self, room_id: int):
        """Wyświetla dialog dołączenia do pokoju, z opcją hasła, jeśli wymagane."""
        if not self.chat_logged_in_user:
            messagebox.showwarning("Czat", "Musisz być zalogowany, aby dołączać do pokoi.", parent=self.chat_page_frame)
            return

        room_data = self.chat_rooms.get(room_id)
        if not room_data:
            messagebox.showerror("Błąd", "Nie znaleziono informacji o tym pokoju.", parent=self.chat_page_frame)
            return

        room_name = room_data.get('name', f"Pokój ID {room_id}")
        requires_password = room_data.get('has_password', False) # Z `room.to_dict()` serwera

        password_to_send = None
        if requires_password:
            password_to_send = simpledialog.askstring(
                "Dołącz do Chronionego Pokoju",
                f"Pokój '{room_name}' jest chroniony hasłem.\nPodaj hasło, aby dołączyć:",
                show="*",
                parent=self.chat_page_frame
            )
            if password_to_send is None: # Użytkownik anulował
                return
            if not password_to_send: # Puste hasło (może być dozwolone przez serwer, ale tu wymagamy)
                 messagebox.showwarning("Brak Hasła", "Hasło nie może być puste.", parent=self.chat_page_frame)
                 return
        else: # Pokój nie wymaga hasła, po prostu potwierdź chęć dołączenia
            if not messagebox.askyesno("Dołącz do Pokoju", f"Czy na pewno chcesz dołączyć do pokoju '{room_name}'?", parent=self.chat_page_frame):
                return

        # Wyślij żądanie dołączenia do serwera
        def send_join_request():
            try:
                payload = {"user_id": self.chat_logged_in_user['user_id']}
                if password_to_send: # Dodaj hasło, jeśli było wymagane i podane
                    payload["password"] = password_to_send
                
                response = requests.post(
                    f"{self.chat_server_url}/rooms/{room_id}/members",
                    json=payload,
                    timeout=10
                )
                response.raise_for_status() # To rzuci wyjątek dla statusów 4xx/5xx
                
                # Sukces
                join_data = response.json()
                self.root.after(0, lambda msg=join_data.get("message", f"Dołączono do pokoju '{room_name}'."), rid=room_id: 
                                self._handle_join_room_success(msg, rid))

            except requests.exceptions.HTTPError as e:
                error_msg = "Błąd serwera."
                if e.response:
                    try: error_msg = e.response.json().get('error', f"Błąd serwera ({e.response.status_code})")
                    except json.JSONDecodeError: error_msg = f"Błąd serwera HTTP ({e.response.status_code})"
                messagebox.showerror("Błąd Dołączania", f"Nie udało się dołączyć do pokoju '{room_name}':\n{error_msg}", parent=self.chat_page_frame)
                logging.error(f"Chat: Błąd dołączania do pokoju {room_id}: {error_msg}")
            except requests.exceptions.RequestException as e:
                messagebox.showerror("Błąd Sieci", f"Nie można połączyć się z serwerem czatu:\n{e}", parent=self.chat_page_frame)
                logging.error(f"Chat: Błąd sieci podczas dołączania do pokoju {room_id}: {e}")

        threading.Thread(target=send_join_request, daemon=True).start()
    # --- KONIEC NOWEJ METODY ---

    # --- NOWA METODA: Obsługa sukcesu dołączenia do pokoju ---
    def _handle_join_room_success(self, success_message: str, room_id_joined: int):
        """Obsługuje UI po pomyślnym dołączeniu do pokoju."""
        messagebox.showinfo("Sukces", success_message, parent=self.chat_page_frame)
        logging.info(f"Chat: Pomyślnie dołączono do pokoju ID: {room_id_joined}")

        if self.sio and self.sio.connected:
            self.sio.emit('join_specific_room', {'room_id': room_id_joined}) 
        
        self._fetch_chat_users()

        self.active_chat_partner_id = room_id_joined
        self.active_chat_type = "room"
        
        item_iid_to_select = f"{self.CHAT_PREFIX_ROOM}{room_id_joined}"
        if hasattr(self, 'chat_users_tree') and self.chat_users_tree.winfo_exists() and self.chat_users_tree.exists(item_iid_to_select):
            self.chat_users_tree.selection_set(item_iid_to_select)
            self.chat_users_tree.see(item_iid_to_select)
            self.chat_users_tree.focus(item_iid_to_select)
            
            # --- ZMIANA: Użyj lambda do poprawnego przekazania chat_type ---
            self.root.after(100, lambda user_id=self.chat_logged_in_user['user_id'], r_id=room_id_joined: 
                            self._load_and_display_chat_history(user_id, r_id, chat_type="room"))
            # --- KONIEC ZMIANY ---
        else: 
            # --- ZMIANA: Użyj lambda do poprawnego przekazania chat_type ---
            self.root.after(100, lambda user_id=self.chat_logged_in_user['user_id'], r_id=room_id_joined: 
                            self._load_and_display_chat_history(user_id, r_id, chat_type="room"))
            # --- KONIEC ZMIANY ---

    # --- Metoda do opuszczania pokoju (Placeholder) ---
    # --- ZASTĄP ISTNIEJĄCY STUB TĄ PEŁNĄ IMPLEMENTACJĄ ---
    def _leave_room_action(self, room_id: int):
        """Obsługuje akcję opuszczenia pokoju przez użytkownika."""
        if not self.chat_logged_in_user:
            # Ten warunek powinien być sprawdzony zanim opcja menu się pojawi,
            # ale dla bezpieczeństwa zostawiamy.
            logging.warning("Chat: Próba opuszczenia pokoju bez zalogowanego użytkownika.")
            return

        room_data = self.chat_rooms.get(room_id)
        room_name_for_dialog = room_data.get('name', f"Pokój ID {room_id}") if room_data else f"Pokój ID {room_id}"

        if not messagebox.askyesno("Opuść Pokój", f"Czy na pewno chcesz opuścić pokój '{room_name_for_dialog}'?", parent=self.chat_page_frame):
            return

        logging.info(f"Chat: Użytkownik {self.chat_logged_in_user['username']} (ID: {self.chat_logged_in_user['user_id']}) próbuje opuścić pokój ID: {room_id}")

        def send_leave_request_thread():
            try:
                user_id_to_remove = self.chat_logged_in_user['user_id']
                # Upewnij się, że endpoint serwera to /rooms/<room_id>/members/<user_id>
                response = requests.delete(
                    f"{self.chat_server_url}/rooms/{room_id}/members/{user_id_to_remove}",
                    timeout=10
                )
                response.raise_for_status() # Rzuci wyjątek dla statusów 4xx/5xx
                
                # Sukces
                leave_data = response.json()
                self.root.after(0, lambda msg=leave_data.get("message", f"Opuszczono pokój '{room_name_for_dialog}'."), rid=room_id:
                                self._handle_leave_room_success(msg, rid))

            except requests.exceptions.HTTPError as e_http:
                error_message = "Błąd serwera podczas opuszczania pokoju."
                if e_http.response is not None:
                    try:
                        error_detail = e_http.response.json().get('error', f"HTTP {e_http.response.status_code}")
                        error_message = f"Nie udało się opuścić pokoju '{room_name_for_dialog}':\n{error_detail}"
                    except json.JSONDecodeError:
                        error_message = f"Nie udało się opuścić pokoju '{room_name_for_dialog}'. Błąd HTTP: {e_http.response.status_code}"
                else: # Brak odpowiedzi serwera
                    error_message = f"Błąd połączenia podczas próby opuszczenia pokoju '{room_name_for_dialog}'."
                
                self.root.after(0, lambda: messagebox.showerror("Błąd Opuszczania Pokoju", error_message, parent=self.chat_page_frame))
                logging.error(f"Chat: Błąd opuszczania pokoju {room_id} dla użytkownika {self.chat_logged_in_user['user_id']}: {error_message}")
            except requests.exceptions.RequestException as e_req:
                error_message = f"Błąd sieci podczas próby opuszczenia pokoju '{room_name_for_dialog}':\n{e_req}"
                self.root.after(0, lambda: messagebox.showerror("Błąd Sieci", error_message, parent=self.chat_page_frame))
                logging.error(f"Chat: Błąd sieci podczas opuszczania pokoju {room_id}: {e_req}")
            except Exception as e_generic:
                error_message = f"Nieoczekiwany błąd podczas opuszczania pokoju '{room_name_for_dialog}':\n{e_generic}"
                self.root.after(0, lambda: messagebox.showerror("Błąd Krytyczny", error_message, parent=self.chat_page_frame))
                logging.exception(f"Chat: Nieoczekiwany błąd opuszczania pokoju {room_id}: {e_generic}")


        threading.Thread(target=send_leave_request_thread, daemon=True).start()
    # --- KONIEC PEŁNEJ IMPLEMENTACJI ---

    # --- NOWE ZMIANY: Tymczasowa metoda stub dla _fetch_room_members_and_store ---
    def _fetch_room_members_and_store(self, room_id: int):
        """
        [TYMCZASOWY STUB] W przyszłości ta metoda będzie pobierać i przechowywać
        listę członków danego pokoju. Na razie tylko loguje.
        """
        logging.debug(f"Chat: [STUB] _fetch_room_members_and_store wywołane dla pokoju ID: {room_id}")
        # Tutaj w przyszłości będzie logika:
        # 1. Wysłanie żądania do serwera: GET /rooms/<room_id>/members
        # 2. Przetworzenie odpowiedzi i zapisanie członków (np. w self.chat_rooms[room_id]['members_details'])
        # 3. Ewentualne odświeżenie UI pokazującego listę członków (np. w bocznym panelu informacji o pokoju).
        # Na razie, aby umożliwić testowanie reszty, nic więcej nie robimy.
        # Możemy ustawić pustą listę, jeśli w przyszłości _display_active_chat_history
        # będzie próbowało na tej podstawie coś robić.
        if room_id in self.chat_rooms:
            self.chat_rooms[room_id].setdefault('members_details', []) # Zapewnij istnienie klucza

        # Po zaimplementowaniu rzeczywistego pobierania, może być potrzebne odświeżenie jakiegoś UI.
        # np. self.root.after(0, self._update_chat_room_members_display)
    # --- KONIEC NOWYCH ZMIAN ---

    # --- NOWE METODY (CHAT GRUPOWY - Etap 1/5) ---
    def _create_room_dialog(self):
        """Otwiera okno dialogowe do tworzenia nowego pokoju czatu (z opcjonalnym hasłem)."""
        if not self.chat_logged_in_user:
            messagebox.showwarning("Czat", "Musisz być zalogowany, aby tworzyć pokoje czatu.", parent=self.chat_page_frame)
            return

        room_dialog = tk.Toplevel(self.chat_page_frame)
        room_dialog.title("Utwórz Nowy Pokój")
        
        # --- NOWE ZMIANY: Centrowanie dialogu ---
        self.root.update_idletasks() # Wymuś aktualizację głównego okna
        parent_x = self.root.winfo_rootx()
        parent_y = self.root.winfo_rooty()
        parent_width = self.root.winfo_width()
        parent_height = self.root.winfo_height()
        
        dialog_width = 510 # Możesz dostosować
        dialog_height = 200 # Możesz dostosować
        
        pos_x = parent_x + (parent_width // 2) - (dialog_width // 2)
        pos_y = parent_y + (parent_height // 2) - (dialog_height // 2)
        room_dialog.geometry(f"{dialog_width}x{dialog_height}+{pos_x}+{pos_y}")
        # --- KONIEC NOWYCH ZMIAN ---
        # --- ZMIANA: Poprawione odwołanie do 'self.settings' zamiast 'self.launcher.settings' ---
        room_dialog.configure(bg=self.settings.get("background", "#1e1e1e"))
        # --- KONIEC ZMIANY ---
        room_dialog.grab_set()
        room_dialog.transient(self.chat_page_frame)
        room_dialog.resizable(False, False)

        ttk.Label(room_dialog, text="Nazwa Pokoju:").grid(row=0, column=0, padx=10, pady=5, sticky="w")
        room_name_var = tk.StringVar()
        room_name_entry = ttk.Entry(room_dialog, textvariable=room_name_var, width=40)
        room_name_entry.grid(row=0, column=1, padx=10, pady=5, sticky="ew")
        room_name_entry.focus_set()

        ttk.Label(room_dialog, text="Hasło (opcjonalnie):").grid(row=1, column=0, padx=10, pady=5, sticky="w")
        room_password_var = tk.StringVar()
        room_password_entry = ttk.Entry(room_dialog, textvariable=room_password_var, show="*", width=40)
        room_password_entry.grid(row=1, column=1, padx=10, pady=5, sticky="ew")
        
        # Checkbox "Pokaż hasło"
        show_password_var = tk.BooleanVar()
        show_password_checkbox = ttk.Checkbutton(room_dialog, text="Pokaż", variable=show_password_var, 
                                                 command=lambda: room_password_entry.config(show="" if show_password_var.get() else "*"))
        show_password_checkbox.grid(row=1, column=2, padx=5, pady=5, sticky="w")

        def create_room_action():
            name = room_name_var.get().strip()
            password = room_password_var.get() # Pobieramy hasło jawnie (serwer zahashuje)

            if not name:
                messagebox.showwarning("Błąd", "Nazwa pokoju nie może być pusta.", parent=room_dialog)
                return
            if not (3 <= len(name) <= 100):
                messagebox.showwarning("Błąd", "Nazwa pokoju musi mieć od 3 do 100 znaków.", parent=room_dialog)
                return

            # Wysłanie żądania do serwera w osobnym wątku
            def send_create_room_request():
                try:
                    payload = {"name": name, "creator_id": self.chat_logged_in_user['user_id']}
                    if password:
                        payload["password"] = password # Dodaj hasło do payloadu, jeśli podano
                    
                    response = requests.post(
                        f"{self.chat_server_url}/rooms",
                        json=payload,
                        timeout=10
                    )
                    response.raise_for_status()

                    data = response.json()
                    # --- ZMIANA: Poprawione odwołanie do 'self.root.after' zamiast 'self.launcher.root.after' ---
                    self.root.after(0, lambda: self._handle_create_room_success(data, room_dialog))
                    # --- KONIEC ZMIANY ---

                except requests.exceptions.HTTPError as e:
                    error_msg = "Nieznany błąd serwera."
                    if e.response and e.response.status_code:
                        try:
                            server_error_data = e.response.json()
                            error_msg = server_error_data.get('error', error_msg)
                            if error_msg == "Room with this name already exists":
                                error_msg = f"Pokój o nazwie '{name}' już istnieje."
                        except json.JSONDecodeError:
                            pass
                    self.launcher.root.after(0, lambda: messagebox.showerror("Błąd Tworzenia Pokoju", error_msg, parent=room_dialog))
                    logging.error(f"Chat: Błąd tworzenia pokoju: {error_msg}")
                except requests.exceptions.RequestException as e:
                    self.launcher.root.after(0, lambda: messagebox.showerror("Błąd Sieci", f"Nie można połączyć się z serwerem czatu:\n{e}", parent=room_dialog))
                    logging.error(f"Chat: Błąd sieci podczas tworzenia pokoju: {e}")

            threading.Thread(target=send_create_room_request, daemon=True).start()

        button_frame = ttk.Frame(room_dialog)
        button_frame.grid(row=2, column=0, columnspan=3, pady=15)
        ttk.Button(button_frame, text="Utwórz", command=create_room_action).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Anuluj", command=room_dialog.destroy).pack(side=tk.LEFT, padx=5)

    def _handle_create_room_success(self, data: dict, dialog_window: tk.Toplevel):
        """Obsługuje sukces utworzenia pokoju i odświeża UI."""
        if dialog_window.winfo_exists():
            dialog_window.destroy()

        messagebox.showinfo("Sukces", f"Pokój '{data['room']['name']}' został pomyślnie utworzony.", parent=self.chat_page_frame)
        logging.info(f"Chat: Pokój '{data['room']['name']}' utworzony i użytkownik dodany jako członek.")
        
        # Odśwież listę pokoi i użytkowników (to wywoła _filter_chat_users, która odświeża Treeview)
        self._fetch_chat_users()

    # --- KONIEC NOWYCH METOD ---

    def _fetch_more_chat_history(self):
        self.chat_history_loading = True
        limit = self.chat_page_size
        before = self.chat_history_before
        
        # --- NOWE ZMIANY: Użyj current_user_id i partner_or_room_id ---
        current_user_id_local = self.chat_logged_in_user['user_id'] # ID zalogowanego użytkownika
        # active_chat_partner_id przechowuje ID pokoju, jeśli active_chat_type to 'room'
        # lub ID partnera, jeśli active_chat_type to 'user'
        partner_or_room_id_local = self.active_chat_partner_id 
        chat_type_local = self.active_chat_type
        # --- KONIEC NOWYCH ZMIAN ---

        def thread_fn():
            try:
                url_path_more = ""
                params_more = {
                    "limit": limit, 
                    "before": before,
                    "user_id": current_user_id_local # Zawsze wysyłamy user_id
                }

                if chat_type_local == "user":
                    url_path_more = f"/messages/{current_user_id_local}/{partner_or_room_id_local}"
                elif chat_type_local == "room":
                    url_path_more = f"/rooms/{partner_or_room_id_local}/messages"
                else:
                    self.root.after(0, lambda: self._display_chat_message("--- Błąd: Nieznany typ chatu (więcej) ---", "error"))
                    self.chat_history_loading = False
                    return
                
                logging.debug(f"Chat: Pobieranie WIĘCEJ historii z {self.chat_server_url}{url_path_more} z parametrami: {params_more}")
                resp = requests.get(
                    f"{self.chat_server_url}{url_path_more}",
                    params=params_more, timeout=10
                )
                resp.raise_for_status()
                data = resp.json()
                old_messages = data["messages"]
                self.chat_history_has_more = data["has_more"]
                self.chat_history_before = data["next_before"]

                if old_messages:
                    # --- NOWE ZMIANY: Użyj partner_or_room_id_local jako klucza ---
                    self.chat_messages[partner_or_room_id_local] = old_messages + self.chat_messages[partner_or_room_id_local]
                    # --- KONIEC NOWYCH ZMIAN ---
                    self._jump_target_message_id = old_messages[-1]['id']
                    # --- NOWE ZMIANY: Użyj partner_or_room_id_local do wyświetlenia ---
                    self.root.after(0, lambda: self._display_active_chat_history(partner_or_room_id_local))
                    # --- KONIEC NOWYCH ZMIAN ---
            except requests.exceptions.HTTPError as http_err_more: # Lepsza obsługa błędów HTTP
                error_content_more = "Nieznany błąd serwera HTTP (więcej)."
                try: error_content_more = http_err_more.response.json().get('error', error_content_more) if http_err_more.response else str(http_err_more)
                except json.JSONDecodeError: error_content_more = str(http_err_more)
                logging.error(f"Chat: Błąd HTTP ({http_err_more.response.status_code if http_err_more.response else 'N/A'}) podczas pobierania więcej historii: {error_content_more}")
                self.root.after(
                    0,
                    lambda err=error_content_more, code=(http_err_more.response.status_code if http_err_more.response else 'N/A'): 
                    self._display_chat_message(f"--- Błąd ładowania więcej historii ({code}): {err} ---", "error")
                )
            except Exception as e:
                logging.exception(f"Chat: Błąd w _fetch_more_chat_history: {e}")
            finally:
                self.chat_history_loading = False
        threading.Thread(target=thread_fn, daemon=True).start()


    def _edit_chat_username_dialog(self):
        """
        Otwiera okno dialogowe do edycji nazwy użytkownika czatu.
        """
        if not self.chat_logged_in_user:
            messagebox.showwarning("Edycja Nazwy", "Musisz być zalogowany do czatu, aby edytować swoją nazwę użytkownika.", parent=self.chat_page_frame)
            return

        edit_dialog = tk.Toplevel(self.chat_page_frame)
        edit_dialog.title("Edytuj Nazwę Użytkownika")
        edit_dialog.configure(bg="#1e1e1e")
        edit_dialog.grab_set()
        edit_dialog.transient(self.chat_page_frame)
        edit_dialog.resizable(False, False)

        # Centrowanie okna
        # --- NOWE ZMIANY ---
        self.root.update_idletasks() # Poprawione wywołanie metody na instancji root
        # --- KONIEC NOWYCH ZMIAN ---
        parent_x = self.chat_page_frame.winfo_rootx()
        parent_y = self.chat_page_frame.winfo_rooty()
        parent_w = self.chat_page_frame.winfo_width()
        parent_h = self.chat_page_frame.winfo_height()
        
        dialog_w = 350
        dialog_h = 150
        pos_x = parent_x + (parent_w // 2) - (dialog_w // 2)
        pos_y = parent_y + (parent_h // 2) - (dialog_h // 2)
        edit_dialog.geometry(f"{dialog_w}x{dialog_h}+{pos_x}+{pos_y}")

        ttk.Label(edit_dialog, text=f"Obecna nazwa: {self.chat_logged_in_user['username']}", font=("Segoe UI", 9, "bold")).pack(pady=(10, 5))
        ttk.Label(edit_dialog, text="Nowa nazwa użytkownika:").pack(pady=(0, 5))

        new_username_var = tk.StringVar(value=self.chat_logged_in_user['username'])
        new_username_entry = ttk.Entry(edit_dialog, textvariable=new_username_var, width=40)
        new_username_entry.pack(padx=10, pady=5)
        new_username_entry.focus_set()

        def save_new_username():
            new_name = new_username_var.get().strip()
            if not new_name:
                messagebox.showwarning("Błąd", "Nazwa użytkownika nie może być pusta.", parent=edit_dialog)
                return
            
            # Lokalna walidacja długości (powtórzona z serwera dla szybszej odpowiedzi)
            if not (3 <= len(new_name) <= 80):
                messagebox.showwarning("Błąd", "Nazwa użytkownika musi mieć od 3 do 80 znaków.", parent=edit_dialog)
                return

            if new_name == self.chat_logged_in_user['username']:
                messagebox.showinfo("Informacja", "Nowa nazwa jest taka sama jak obecna.", parent=edit_dialog)
                edit_dialog.destroy()
                return

            # Wysłanie żądania do serwera w osobnym wątku
            def send_update_request():
                try:
                    response = requests.put(
                        f"{self.chat_server_url}/user/{self.chat_logged_in_user['user_id']}",
                        json={"new_username": new_name},
                        timeout=10
                    )
                    response.raise_for_status() # To rzuci wyjątek dla statusów 4xx/5xx

                    data = response.json()
                    self.root.after(0, lambda: self._handle_username_update_success(data, edit_dialog))

                except requests.exceptions.HTTPError as e:
                    error_msg = "Nieznany błąd serwera."
                    if e.response and e.response.status_code:
                        try:
                            server_error_data = e.response.json()
                            error_msg = server_error_data.get('error', error_msg)
                            if error_msg == "Username already taken by another user":
                                error_msg = f"Nazwa użytkownika '{new_name}' jest już zajęta."
                            elif error_msg == "Username must be between 3 and 80 characters":
                                error_msg = "Nazwa użytkownika musi mieć od 3 do 80 znaków."
                        except json.JSONDecodeError:
                            pass # Błąd JSON decode, użyj domyślnego error_msg
                    self.root.after(0, lambda: messagebox.showerror("Błąd Aktualizacji", error_msg, parent=edit_dialog))
                    logging.error(f"Chat: Błąd aktualizacji nazwy użytkownika: {error_msg}")
                except requests.exceptions.RequestException as e:
                    self.root.after(0, lambda: messagebox.showerror("Błąd Sieci", f"Nie można połączyć się z serwerem czatu:\n{e}", parent=edit_dialog))
                    logging.error(f"Chat: Błąd sieci podczas aktualizacji nazwy użytkownika: {e}")

            threading.Thread(target=send_update_request, daemon=True).start()

        button_frame = ttk.Frame(edit_dialog)
        button_frame.pack(pady=10)
        ttk.Button(button_frame, text="Zapisz", command=save_new_username).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Anuluj", command=edit_dialog.destroy).pack(side=tk.LEFT, padx=5)

    def _handle_username_update_success(self, data: dict, dialog_window: tk.Toplevel):
        """Obsługuje sukces aktualizacji nazwy użytkownika w głównym wątku GUI."""
        if dialog_window.winfo_exists():
            dialog_window.destroy()

        new_username = data.get('new_username')
        if new_username:
            self.chat_logged_in_user['username'] = new_username # Zaktualizuj lokalne dane
            messagebox.showinfo("Sukces", f"Twoja nazwa użytkownika została zmieniona na '{new_username}'.", parent=self.chat_page_frame)
            
            # Odśwież etykietę w UI
            self.chat_current_user_label.config(text=f"Zalogowano jako: {new_username}")
            
            # Odśwież listę użytkowników w Treeview, aby pokazać nową nazwę (jeśli to inni użytkownicy)
            self._fetch_chat_users() # To pobierze zaktualizowaną listę z serwera
            logging.info(f"Chat: Nazwa użytkownika zaktualizowana w UI na '{new_username}'.")
        else:
            messagebox.showerror("Błąd", "Serwer zwrócił sukces, ale brak nowej nazwy użytkownika.", parent=self.chat_page_frame)

    def _confirm_delete_chat_account(self):
        """
        Inicjuje proces usuwania konta czatu, wyświetlając prośbę o potwierdzenie
        i podanie hasła.
        """
        if not self.chat_logged_in_user:
            messagebox.showwarning("Usuń Konto", "Musisz być zalogowany do czatu, aby usunąć konto.", parent=self.settings_page_frame)
            return

        current_username = self.chat_logged_in_user.get('username', 'Twoje konto')

        # Krok 1: Potwierdzenie usunięcia
        confirm_first_step = messagebox.askyesno(
            "Potwierdź Usunięcie Konta",
            f"Czy na pewno chcesz trwale usunąć konto użytkownika '{current_username}'?\n\n"
            "Tej operacji nie można cofnąć! Wszystkie Twoje dane związane z czatem "
            "(np. lista kontaktów, unikalny identyfikator użytkownika) zostaną usunięte z serwera.\n\n"
            "Wiadomości, które wysłałeś/odebrałeś, mogą pozostać w historii czatu innych użytkowników, "
            "ale będą powiązane z usuniętym kontem.\n\n"
            "Kontynuować?",
            icon='warning',
            parent=self.settings_page_frame
        )

        if not confirm_first_step:
            return

        # Krok 2: Prośba o podanie hasła do potwierdzenia
        password_confirmation = simpledialog.askstring(
            "Potwierdź Hasło",
            "Aby potwierdzić usunięcie konta, podaj swoje hasło:",
            show='*', # Ukryj wpisywane znaki
            parent=self.settings_page_frame
        )

        if not password_confirmation: # Użytkownik anulował lub nic nie wpisał
            messagebox.showwarning("Usuwanie Anulowane", "Usuwanie konta zostało anulowane (brak podania hasła).", parent=self.settings_page_frame)
            return

        # Uruchomienie żądania usunięcia w osobnym wątku
        logging.info(f"Chat: Wysyłanie żądania usunięcia konta dla użytkownika ID: {self.chat_logged_in_user['user_id']}.")
        
        def send_delete_request():
            try:
                response = requests.delete(
                    f"{self.chat_server_url}/user/{self.chat_logged_in_user['user_id']}",
                    json={"password": password_confirmation},
                    timeout=10
                )
                response.raise_for_status() # Rzuci wyjątek dla statusów 4xx/5xx

                data = response.json()
                self.root.after(0, lambda: self._handle_account_deletion_response(data, None))

            except requests.exceptions.HTTPError as e:
                error_msg = "Nieznany błąd serwera."
                if e.response and e.response.status_code:
                    try:
                        server_error_data = e.response.json()
                        error_msg = server_error_data.get('error', error_msg)
                        if error_msg == "Incorrect password":
                            error_msg = "Podane hasło jest nieprawidłowe."
                        # Można dodać więcej specyficznych komunikatów
                    except json.JSONDecodeError:
                        pass
                self.root.after(0, lambda: self._handle_account_deletion_response(None, error_msg))
                logging.error(f"Chat: Błąd usuwania konta: {error_msg}")
            except requests.exceptions.RequestException as e:
                self.root.after(0, lambda: self._handle_account_deletion_response(None, f"Błąd sieci: {e}"))
                logging.error(f"Chat: Błąd sieci podczas usuwania konta: {e}")

        threading.Thread(target=send_delete_request, daemon=True).start()

    def _handle_account_deletion_response(self, data: dict | None, error_message: str | None):
        """
        Obsługuje odpowiedź serwera po próbie usunięcia konta.
        Wywoływana w głównym wątku GUI.
        """
        if error_message:
            messagebox.showerror("Błąd Usuwania Konta", error_message, parent=self.settings_page_frame)
            return

        if data and data.get('message') == "User account deleted successfully":
            messagebox.showinfo("Sukces", "Twoje konto czatu zostało pomyślnie usunięte.", parent=self.settings_page_frame)
            logging.info("Chat: Konto użytkownika pomyślnie usunięte, wylogowywanie.")
            self._chat_logout() # Wyloguj użytkownika po sukcesie
            # Po wylogowaniu _chat_logout powinien już czyścić lokalne dane i UI.
        else:
            messagebox.showerror("Błąd Usuwania Konta", "Nieoczekiwana odpowiedź serwera podczas usuwania konta.", parent=self.settings_page_frame)

    # --- NOWE ZMIANY (CHAT KLIENT - Odpowiadanie) ---
    def _update_reply_preview_ui(self):
        """
        Aktualizuje UI podglądu cytowanej wiadomości.
        Jeśli _current_reply_message_data jest ustawione, pokazuje ramkę i jej zawartość.
        W przeciwnym razie ukrywa ramkę.
        """
        if not (hasattr(self, 'chat_reply_preview_frame') and self.chat_reply_preview_frame.winfo_exists()):
            return

        if self._current_reply_message_data:
            sender_name = self._current_reply_message_data.get('sender_username', 'Nieznany')
            content_preview = self._current_reply_message_data.get('content', '')
            attachment_name = self._current_reply_message_data.get('attachment_original_filename')

            # Utwórz skróconą treść do wyświetlenia
            display_text = f"Odpowiadasz do {sender_name}: "
            if content_preview:
                display_text += content_preview[:50]
                if len(content_preview) > 50: display_text += "..."
            elif attachment_name:
                display_text += f"[Załącznik: {attachment_name}]"
            else:
                display_text += "[Wiadomość bez treści]"

            self.reply_preview_label.config(text=display_text)
                        # Tutaj umieść pady i padx dla ramki:
            self.chat_reply_preview_frame.grid(row=5, column=0, columnspan=2, sticky="ew", padx=10, pady=(5,5))
            
            # Dostosuj tło ramki podglądu
            theme_def = self.get_all_available_themes().get(self.settings.get('theme', 'Dark'), THEMES['Dark'])
            reply_preview_bg = theme_def.get('entry_background', '#282828')
            reply_preview_fg = theme_def.get('foreground', 'white')
            # --- NOWE ZMIANY (CHAT KLIENT - Odpowiadanie) ---
            reply_preview_border_color = theme_def.get('tree_heading', '#3e3e3e') # Kolor ramki
            
            self.chat_reply_preview_frame.config(
                background=reply_preview_bg,
                highlightbackground=reply_preview_border_color, # Kolor ramki gdy nie ma focusu
                highlightcolor=reply_preview_border_color,      # Kolor ramki gdy ma focus
                highlightthickness=1 # Grubość ramki highlight
            )
            # Etykieta wewnątrz ramki podglądu odpowiedzi (to jest ttk.Label)
            self.reply_preview_label.config(background=reply_preview_bg, foreground=reply_preview_fg)
            # --- KONIEC NOWYCH ZMIAN ---
            
            # Wyczyść zawartość pola Entry
            self.chat_input_var.set("") # Wyczyść pole po włączeniu trybu odpowiadania
            self.chat_input_entry.focus_set() # Ustaw fokus

        else:
            self.chat_reply_preview_frame.grid_remove() # Ukryj ramkę
            
        # Zaktualizuj pady górnego pola input, aby nie było podwójnego pady.
        if hasattr(self, 'chat_input_entry') and self.chat_input_entry.winfo_exists():
            if self._current_reply_message_data or self._pending_chat_attachment:
                self.chat_input_entry.grid_configure(pady=(0,5)) # Mniejsze pady, jeśli coś jest nad nim
            else:
                self.chat_input_entry.grid_configure(pady=5) # Normalne pady

    # --- KONIEC NOWYCH ZMIAN (CHAT KLIENT - Odpowiadanie) ---

    # --- NOWE ZMIANY (CHAT KLIENT - Odpowiadane) ---
    def _cancel_reply_mode(self):
        """Anuluje tryb odpowiadania na wiadomość."""
        self._current_reply_message_data = None
        logging.info("Chat: Anulowano tryb odpowiadania.")
        self._update_reply_preview_ui() # Odśwież UI, aby ukryć podgląd

    # --- KONIEC NOWYCH ZMIAN (CHAT KLIENT - Odpowiadane) ---

    def _parse_text_for_links(self, text_content):
        """
        Analizuje tekst w poszukiwaniu linków URL.
        Zwraca listę krotek: (fragment_tekstu, typ_segmentu),
        gdzie typ_segmentu to "text" lub "link".
        """
        # Bardzo prosty regex do wykrywania URL. Można go znacznie ulepszyć.
        # Ten regex łapie http://, https:// oraz www. (z opcjonalnym / na końcu)
        # UWAGA: Ten regex jest uproszczony i może nie łapać wszystkich poprawnych URL
        # ani poprawnie obsługiwać wszystkich przypadków brzegowych (np. URL w nawiasach).
        url_pattern = re.compile(
            r'((?:https?://|www\.)[^\s<>"\'(){}|\\^`]+(?:[^\s<>"\'(){}|\\^`\.])?)'
            # Wyjaśnienie regexu:
            # (?:https?://|www\.)  - Zaczyna się od http://, https:// lub www.
            # [^\s<>"\'(){}|\\^`]+ - Jeden lub więcej znaków, które nie są spacją ani niektórymi znakami specjalnymi
            # (?:[^\s<>"\'(){}|\\^`\.])? - Opcjonalny ostatni znak, który nie jest kropką (aby uniknąć łapania kropki na końcu zdania)
            # Całość w grupie przechwytującej (...)
        )
        
        segments = []
        last_end = 0
        for match in url_pattern.finditer(text_content):
            start, end = match.span()
            link_url = match.group(1)

            # Dodaj tekst przed linkiem (jeśli jest)
            if start > last_end:
                segments.append((text_content[last_end:start], "text"))
            
            # Dodaj link
            segments.append((link_url, "link"))
            last_end = end
        
        # Dodaj tekst po ostatnim linku (jeśli jest)
        if last_end < len(text_content):
            segments.append((text_content[last_end:], "text"))
            
        if not segments and text_content: # Jeśli nie znaleziono linków, ale jest tekst
             segments.append((text_content, "text"))

        return segments

    def _create_chat_message_tags_if_needed(self):
        """Pomocnicza metoda do jednorazowego tworzenia tagów dla wiadomości czatu."""
        if hasattr(self, '_chat_message_tags_created') and self._chat_message_tags_created:
            return

        # Definicje tagów dla stylów tekstu i linków
        theme_def = self.get_all_available_themes().get(self.settings.get('theme', 'Dark'), THEMES['Dark'])
        
        # Dla zwykłego tekstu w dymkach (jeśli nie używamy tk.Label dla tekstu)
        # self.chat_message_display.tag_config("my_message_text_tag", foreground=theme_def.get('link_foreground', 'lightblue'))
        # self.chat_message_display.tag_config("other_message_text_tag", foreground=theme_def.get('foreground', 'lightgreen'))
        
        # Dla linków
        link_fg_color = theme_def.get('link_foreground', 'lightblue') # Kolor z motywu
        self.chat_message_display.tag_config("chat_link_tag", 
                                             foreground=link_fg_color, 
                                             underline=True)
        self.chat_message_display.tag_bind("chat_link_tag", "<Enter>", 
                                           lambda e: self.chat_message_display.config(cursor="hand2"))
        self.chat_message_display.tag_bind("chat_link_tag", "<Leave>", 
                                           lambda e: self.chat_message_display.config(cursor=""))
        # Bindowanie kliknięcia do otwierania linku będzie dodawane dynamicznie


        # Ustawienia tagów dla wyrównania dymków (jak poprzednio)
        # Możemy to zrefaktoryzować do _on_chat_display_resize
        # bubble_margin_percent = 0.15 # np. 15% marginesu z jednej strony
        # chat_width = self.chat_message_display.winfo_width()
        # if chat_width < 50: chat_width = 500 # Domyślna szerokość, jeśli widget jeszcze nie ma rozmiaru
        # l_margin = int(chat_width * bubble_margin_percent)
        # r_margin = 10 

        # self.chat_message_display.tag_config("my_message_bubble_align_tag", 
        #                                      justify='left', # Tekst w dymku od lewej
        #                                      lmargin1=r_margin, # Mały lewy margines dla dymka
        #                                      rmargin1=l_margin)  # Duży prawy margines dla dymka (dymek po lewej)
        # self.chat_message_display.tag_config("other_message_bubble_align_tag", 
        #                                      justify='left', # Tekst w dymku od lewej
        #                                      lmargin1=l_margin,  # Duży lewy margines dla dymka
        #                                      rmargin1=r_margin)   # Mały prawy margines dla dymka (dymek po prawej)


        setattr(self, '_chat_message_tags_created', True)


    def _check_and_mark_read(self):
        """
        Jeżeli masz otwarty chat z partnerem, jesteś na dole scrolla i
        jesteś **na karcie czatu**, to wyślij potwierdzenia odczytu.
        """
        # --- NOWE ZMIANY (CHAT GRUPOWY - Etap 2/5 - Zmiana 4/5) ---
        # Tylko dla prywatnych czatów, nie grup
        if self.active_chat_type != "user": 
            return
        # --- KONIEC NOWYCH ZMIAN ---
        active_partner_id = self.active_chat_partner_id
        # 1) Tylko gdy to nie dashboard i to faktyczny partner
        if not active_partner_id or active_partner_id == self.chat_dashboard_placeholder_id:
            return

        # 2) Tylko gdy jesteśmy **na stronie czatu**
        if getattr(self, 'current_frame', None) != self.chat_page_frame:
            logging.debug("ChatReadCheck: Nie na stronie czatu, pomijam oznaczanie.")
            return

        # 3) Opcjonalnie: Tylko gdy okno aplikacji ma fokus (bardziej zaawansowane, na razie pomińmy)
        # if not self.root.focus_displayof():
        #     logging.debug("ChatReadCheck: Okno launchera nie ma fokusu, pomijam.")
        #     return

        # 4) Tylko gdy scroll jest na dole (lub blisko)
        if hasattr(self, 'chat_message_display') and self.chat_message_display.winfo_exists():
            # Sprawdź, czy scrollbar faktycznie jest potrzebny (czy zawartość jest większa niż widok)
            # To zapobiegnie oznaczaniu jako przeczytane, jeśli wszystkie wiadomości mieszczą się na ekranie
            # bez scrollowania, a użytkownik jeszcze nie doszedł na sam dół (chociaż w tym przypadku
            # warunek yview()[1] < 0.99 może nie być spełniony od razu)
            # Można by to rozbudować o sprawdzanie, czy ostatnia wiadomość jest w ogóle widoczna.
            # Na razie zostawiamy prostsze yview().
            
            # yview_info = self.chat_message_display.yview()
            # logging.debug(f"ChatReadCheck: yview info: {yview_info}")
            # if yview_info[1] < 0.99 and yview_info[1] < yview_info[0] + (yview_info[1]-yview_info[0]) + 0.01 : # Trochę tolerancji
            # (yview_info[1] - yview_info[0]) to widoczna część, yview_info[1] to dolna krawędź widocznej części.

            # Spróbujmy prościej: Jeśli dolna krawędź widocznego obszaru jest blisko końca całkowitej zawartości
            if self.chat_message_display.yview()[1] < 0.95: # Użyjmy np. 0.95 zamiast 0.99 dla większej tolerancji
                logging.debug("ChatReadCheck: Scroll nie jest na dole, pomijam oznaczanie.")
                return
        else: # Jeśli widget nie istnieje, nie rób nic
            return

        # W tym momencie faktycznie użytkownik powinien widzieć najnowsze wiadomości
        messages_from_partner_to_mark = []
        my_user_id = self.chat_logged_in_user['user_id']

        # Przeglądamy wiadomości dla AKTYWNEGO partnera
        for msg_data in self.chat_messages.get(active_partner_id, []):
            # Interesują nas wiadomości WYSŁANE przez partnera DO NAS
            # i które JESZCZE nie zostały oznaczone jako przeczytane przez nas na serwerze
            if msg_data.get('sender_id') == active_partner_id and \
               msg_data.get('receiver_id') == my_user_id and \
               not msg_data.get('is_read_by_receiver', False): # `is_read_by_receiver` w tym kontekście znaczy "przeczytane przeze mnie"
                messages_from_partner_to_mark.append(msg_data.get('id'))
        
        if not messages_from_partner_to_mark:
            # logging.debug(f"ChatReadCheck: Brak nowych wiadomości od partnera {active_partner_id} do oznaczenia.")
            return
            
        if not self.sio or not self.sio.connected:
            logging.warning("ChatReadCheck: Brak połączenia z SIO, nie można wysłać potwierdzeń.")
            return

        try:
            logging.info(f"ChatReadCheck: Wysyłanie mark_messages_as_read dla ID: {messages_from_partner_to_mark} (czytelnik: {my_user_id})")
            self.sio.emit('mark_messages_as_read', {
                'message_ids': messages_from_partner_to_mark,
                'reader_id': my_user_id
            })
            
            # Optymistyczna aktualizacja lokalnego stanu - oznaczamy je jako "przeczytane przez odbiorcę (czyli nas)"
            # To jest ważne, aby przy następnym wywołaniu _check_and_mark_read nie wysyłać ich ponownie,
            # zanim serwer zdąży odpowiedzieć i zaktualizować nasz widok przez `message_read_update`
            # (które de facto nie jest używane do aktualizacji wskaźnika "oko" dla wiadomości OD PARTNERA,
            # bo "oko" jest tylko dla naszych wysłanych wiadomości).
            for msg_id_marked in messages_from_partner_to_mark:
                for i, msg_in_hist in enumerate(self.chat_messages.get(active_partner_id, [])):
                    if msg_in_hist.get('id') == msg_id_marked:
                        self.chat_messages[active_partner_id][i]['is_read_by_receiver'] = True # Oznaczamy, że my jako odbiorca przeczytaliśmy
                        break
            
            # Odświeżenie UI nie jest tu bezpośrednio potrzebne, bo nie dodajemy "oka" do wiadomości partnera.
            # Jednak jeśli usuwamy np. licznik nieprzeczytanych wiadomości z listy użytkowników, to tutaj
            # byłoby miejsce na odświeżenie tego licznika dla `active_partner_id`.
            # Na razie zakładamy, że licznik jest kasowany w `_on_chat_user_select`.

        except Exception as e:
            logging.error(f"ChatReadCheck: Błąd podczas wysyłania mark_messages_as_read: {e}")



    # --- NOWE METODY dla wyszukiwania wiadomości w czacie ---
    def _on_chat_message_search_change(self, *args):
        """Wywoływane przy zmianie tekstu w polu wyszukiwania wiadomości."""
        # Użyjemy prostego debounce, aby nie odświeżać przy każdej literze
        if hasattr(self, '_chat_msg_search_timer'):
            self.root.after_cancel(self._chat_msg_search_timer)
        
        # Jeśli pole wyszukiwania jest puste, a _last_chat_message_search_term też było puste,
        # nie rób nic, aby uniknąć niepotrzebnego odświeżania przy czyszczeniu pustego pola.
        current_search_term = self.chat_message_search_var.get().lower().strip()
        if not current_search_term and not getattr(self, '_last_chat_message_search_term', ''):
            return
            
        self._last_chat_message_search_term = current_search_term # Zapamiętaj ostatni termin

        self._chat_msg_search_timer = self.root.after(400, self._apply_chat_message_filter)

    def _clear_chat_message_search(self):
        """Czyści pole wyszukiwania wiadomości i odświeża widok."""
        self.chat_message_search_var.set("")
        # _on_chat_message_search_change zostanie wywołane automatycznie przez trace,
        # co spowoduje odświeżenie przez _apply_chat_message_filter.

    def _apply_chat_message_filter(self):
        """
        Filtruje i ponownie wyświetla historię czatu na podstawie
        terminu w self.chat_message_search_var.
        """
        if self.active_chat_partner_id is None or self.active_chat_partner_id == self.chat_dashboard_placeholder_id:
            # Nie filtruj, jeśli nie ma aktywnego czatu z użytkownikiem lub jest dashboard
            self._display_active_chat_history(self.active_chat_partner_id) # Wyświetl standardowo (np. dashboard)
            return

        logging.debug(f"Aplikowanie filtru wiadomości dla: {self.chat_message_search_var.get()}")
        # Po prostu wywołaj _display_active_chat_history, która teraz będzie zawierać logikę filtrowania
        self._display_active_chat_history(self.active_chat_partner_id)
        

    # --- NOWE ZMIANY (CHAT - Wysyłanie plików) ---
    def _select_and_upload_chat_file(self):
        """
        Otwiera dialog wyboru pliku, a następnie próbuje przesłać wybrany plik
        na serwer czatu. Po pomyślnym przesłaniu, wysyła wiadomość czatu
        z informacją o załączniku.
        """
        if not self.chat_logged_in_user or not self.sio or not self.sio.connected or not self.chat_authenticated:
            messagebox.showwarning("Czat", "Musisz być zalogowany i połączony z serwerem, aby wysyłać pliki.", parent=self.chat_page_frame)
            return
        if self.active_chat_partner_id is None or self.active_chat_partner_id == self.chat_dashboard_placeholder_id:
            messagebox.showwarning("Czat", "Wybierz partnera czatu, do którego chcesz wysłać plik.", parent=self.chat_page_frame)
            return

        # Otwórz dialog wyboru pliku
        filepath = filedialog.askopenfilename(
            title="Wybierz plik do wysłania",
            parent=self.chat_page_frame # Ustaw rodzica dla modalności
        )

        if not filepath:
            logging.debug("Chat: Anulowano wybór pliku do wysłania.")
            return

        # Sprawdź rozmiar pliku przed wysłaniem
        try:
            file_size_bytes = os.path.getsize(filepath)
            # MAX_FILE_SIZE_MB jest zdefiniowane w chat_server.py, ale możemy tu mieć własny limit
            # lub pobierać go z konfiguracji w przyszłości. Na razie hardkodujemy podobny.
            client_max_file_size_mb = 10
            if file_size_bytes > client_max_file_size_mb * 1024 * 1024:
                messagebox.showerror(
                    "Błąd Pliku",
                    f"Wybrany plik jest zbyt duży (maks. {client_max_file_size_mb} MB).",
                    parent=self.chat_page_frame
                )
                return
        except OSError as e:
            logging.error(f"Chat: Nie można odczytać rozmiaru pliku '{filepath}': {e}")
            messagebox.showerror("Błąd Pliku", f"Nie można odczytać pliku:\n{filepath}", parent=self.chat_page_frame)
            return

        logging.info(f"Chat: Wybrano plik do wysłania: {filepath}")

        # Pokaż okno postępu (proste, indeterminate)
        # Możesz stworzyć bardziej zaawansowane okno postępu dla plików, jeśli chcesz
        upload_progress_window = tk.Toplevel(self.chat_page_frame)
        upload_progress_window.title("Przesyłanie Pliku...")
        upload_progress_window.geometry("300x100")
        upload_progress_window.resizable(False, False)
        upload_progress_window.grab_set() # Zablokuj interakcję z oknem czatu
        
        ttk.Label(upload_progress_window, text=f"Przesyłanie: {os.path.basename(filepath)}").pack(pady=10)
        progress_bar_upload = ttk.Progressbar(upload_progress_window, mode='indeterminate', length=250)
        progress_bar_upload.pack(pady=5)
        progress_bar_upload.start(20)
        upload_progress_window.update()

        # --- NOWE ZMIANY: Przekazanie otwartego pliku do wątku ---
        try:
            # Otwieramy plik TUTAJ, ale NIE używamy 'with'
            file_object = open(filepath, 'rb') 
            
            # Przygotuj dane do wysłania, przekazując otwarty obiekt pliku
            files_payload = {
                'file': (
                    os.path.basename(filepath), 
                    file_object, # <-- Przekazujemy otwarty obiekt pliku
                    mimetypes.guess_type(filepath)[0] or 'application/octet-stream'
                )
            }
            
            # Wyślij plik w osobnym wątku, przekazując obiekt pliku do zamknięcia
            upload_thread = threading.Thread(
                target=self._upload_file_thread,
                args=(files_payload, upload_progress_window, file_object), # <-- Dodajemy file_object jako argument
                daemon=True
            )
            upload_thread.start()

        except FileNotFoundError: # Dodano obsługę FileNotFoundError
            logging.error(f"Chat: Nie znaleziono pliku do wysłania: {filepath}")
            messagebox.showerror("Błąd Pliku", f"Nie znaleziono pliku:\n{filepath}", parent=self.chat_page_frame)
            if upload_progress_window.winfo_exists():
                upload_progress_window.destroy()
        except Exception as e:
            logging.error(f"Chat: Błąd przygotowania pliku do wysłania: {e}")
            messagebox.showerror("Błąd Wysyłania", f"Nie można przygotować pliku do wysłania:\n{e}", parent=self.chat_page_frame)
            if upload_progress_window.winfo_exists():
                upload_progress_window.destroy()
            # Jeśli plik został otwarty, a wystąpił inny błąd, upewnij się, że jest zamknięty
            if 'file_object' in locals() and file_object and not file_object.closed:
                file_object.close()
        # --- KONIEC NOWYCH ZMIAN ---

    # --- NOWE ZMIANY: Dodanie argumentu file_to_close i jego obsługa ---
    def _upload_file_thread(self, files_payload, progress_window_ref, file_to_close=None):
        """
        Funkcja działająca w osobnym wątku, odpowiedzialna za wysłanie pliku
        i obsługę odpowiedzi. Zamyka przekazany obiekt pliku po zakończeniu.
        """
        try:
            response = requests.post(
                f"{self.chat_server_url}/upload_file",
                files=files_payload, 
                timeout=60 
            )
            response.raise_for_status() 
            
            upload_data = response.json() 
            if progress_window_ref.winfo_exists():
                 progress_window_ref.destroy() 
            self.root.after(0, self._handle_file_upload_response, upload_data, None)

        except requests.exceptions.RequestException as e:
            error_message = f"Błąd sieci podczas wysyłania pliku: {e}"
            logging.error(error_message)
            if progress_window_ref.winfo_exists(): progress_window_ref.destroy()
            self.root.after(0, self._handle_file_upload_response, None, error_message)
        except Exception as e:
            error_message = f"Nieoczekiwany błąd podczas wysyłania pliku: {e}"
            logging.exception(error_message) 
            if progress_window_ref.winfo_exists(): progress_window_ref.destroy()
            self.root.after(0, self._handle_file_upload_response, None, error_message)
        finally:
            # Zawsze próbuj zamknąć przekazany obiekt pliku
            if file_to_close and not file_to_close.closed:
                try:
                    file_to_close.close()
                    logging.debug(f"Chat: Zamknięto obiekt pliku po wysłaniu/błędzie.")
                except Exception as e_close:
                    logging.error(f"Chat: Błąd podczas zamykania obiektu pliku: {e_close}")
    # --- KONIEC NOWYCH ZMIAN ---


    def _handle_file_upload_response(self, upload_data, error_message):
        """
        Obsługuje odpowiedź z serwera po próbie wysłania pliku.
        Wywoływana w głównym wątku przez self.root.after().
        """
        if error_message:
            messagebox.showerror("Błąd Wysyłania Pliku", error_message, parent=self.chat_page_frame)
            return

        if upload_data and upload_data.get("attachment_server_filename"):
            logging.info(f"Chat: Plik pomyślnie przesłany: {upload_data}")
            
            # Wyślij wiadomość Socket.IO z informacją o załączniku
            # Treść tekstowa może być pusta, jeśli wysyłamy tylko plik
            message_content_with_file = self.chat_input_var.get().strip()
            # Opcjonalnie: dodaj informację o pliku do treści, jeśli jest pusta
            if not message_content_with_file:
                message_content_with_file = f"[Plik: {upload_data.get('attachment_original_filename', 'plik')}]"
            
            try:
                self.sio.emit('private_message', {
                    'sender_id': self.chat_logged_in_user['user_id'],
                    'receiver_id': self.active_chat_partner_id,
                    'content': message_content_with_file, # Treść wiadomości
                    'attachment_server_filename': upload_data.get('attachment_server_filename'),
                    'attachment_original_filename': upload_data.get('attachment_original_filename'),
                    'attachment_mimetype': upload_data.get('attachment_mimetype')
                })
                self.chat_input_var.set("") # Wyczyść pole wprowadzania po wysłaniu wiadomości (jeśli była tam treść)
                self._send_typing_stop_event() 
            except Exception as e:
                messagebox.showerror("Błąd Wysyłania Wiadomości", f"Plik został przesłany, ale nie udało się wysłać wiadomości czatu:\n{e}", parent=self.chat_page_frame)
                logging.error(f"Chat: Błąd podczas emitowania wiadomości z załącznikiem: {e}")
        else:
            # Powinno być obsłużone przez error_message, ale na wszelki wypadek
            messagebox.showerror("Błąd Wysyłania Pliku", "Otrzymano nieprawidłową odpowiedź z serwera po wysłaniu pliku.", parent=self.chat_page_frame)
            logging.error(f"Chat: Nieprawidłowa odpowiedź serwera po wysłaniu pliku: {upload_data}")
    # --- KONIEC NOWYCH ZMIAN (CHAT - Wysyłanie plików) ---

    # --- NOWE ZMIANY (CHAT) ---
    def _chat_login(self):
        email = self.chat_email_var.get().strip()
        password = self.chat_password_var.get()
        
        if not email or not password:
            messagebox.showerror("Błąd Logowania", "E-mail i hasło są wymagane.", parent=self.chat_page_frame)
            return

        try:
            response = requests.post(
                f"{self.chat_server_url}/login", 
                json={"email": email, "password": password},
                timeout=10
            )
            response.raise_for_status() # To rzuci wyjątek dla statusów 4xx/5xx
            
            data = response.json()
            self.chat_logged_in_user = {'user_id': data['user_id'], 'username': data['username']}
            messagebox.showinfo("Sukces", f"Zalogowano jako: {self.chat_logged_in_user['username']}", parent=self.chat_page_frame)
            logging.info(f"Chat: Użytkownik {self.chat_logged_in_user['username']} zalogowany.")
            
            # --- NOWE ZMIANY (CHAT) ---
            # Zapisz dane logowania TYLKO, jeśli "Zapamiętaj dane logowania" jest zaznaczone
            if self.chat_remember_me_var.get():
                self.local_settings["chat_email"] = email
                self.local_settings["chat_password"] = password 
            else: # Jeśli nie zaznaczono "Zapamiętaj", upewnij się, że nie ma ich w local_settings
                self.local_settings.pop("chat_email", None)
                self.local_settings.pop("chat_password", None)
            
            save_local_settings(self.local_settings) # Zapisz stan local_settings
            # --- KONIEC NOWYCH ZMIAN (CHAT) ---

            self._connect_to_chat_server() # Spróbuj połączyć się z SocketIO
            self._update_chat_ui_state()
            
        except requests.exceptions.HTTPError as e:
            # --- NOWE ZMIANY ---
            error_msg = "Nieznany błąd logowania."
            if e.response and e.response.status_code:
                try:
                    server_error_data = e.response.json()
                    error_msg = server_error_data.get('error', 'Nieznany błąd serwera.')
                    # Mapowanie kodów błędów na bardziej przyjazne komunikaty, jeśli potrzebne
                    if error_msg == "Invalid email format":
                        error_msg = "Nieprawidłowy format adresu e-mail."
                    elif error_msg == "Email not registered":
                        error_msg = "Podany adres e-mail nie jest zarejestrowany."
                    elif error_msg == "Incorrect password":
                        error_msg = "Nieprawidłowe hasło."
                except json.JSONDecodeError:
                    error_msg = f"Serwer zwrócił błąd HTTP {e.response.status_code}, ale bez JSONa."
            else:
                error_msg = f"Błąd połączenia z serwerem: {e}"
            
            messagebox.showerror("Błąd Logowania", error_msg, parent=self.chat_page_frame)
            logging.error(f"Chat: Błąd logowania: {error_msg}")
            # --- KONIEC NOWYCH ZMIAN ---
        except requests.exceptions.RequestException as e:
            messagebox.showerror("Błąd Sieci", f"Nie można połączyć się z serwerem czatu:\n{e}", parent=self.chat_page_frame)
            logging.error(f"Chat: Błąd sieci podczas logowania: {e}")

    # --- NOWE ZMIANY (CHAT) ---
    # Zmodyfikuj _on_remember_me_toggle i _on_auto_login_toggle, aby zapisywały do aktywnego serwera
    def _on_remember_me_toggle(self):
        active_server_data = self._get_active_server_data()
        if not active_server_data: return

        remember_me = self.chat_remember_me_var.get()
        active_server_data["remember_credentials"] = remember_me
        
        if remember_me: # Jeśli zaznaczono, zapisz aktualne dane z pól do tego serwera
            active_server_data.setdefault("credentials", {})
            active_server_data["credentials"]["email"] = self.chat_email_var.get()
            active_server_data["credentials"]["password"] = self.chat_password_var.get() # Nadal plain/zaszyfrowane
        else: # Jeśli odznaczono, wyczyść dane dla tego serwera i odznacz auto-login
            active_server_data.get("credentials", {}).clear()
            active_server_data["auto_login_to_server"] = False
            self.chat_auto_login_var.set(False)
            
        self.local_settings["chat_servers"] = self.chat_servers_list
        save_local_settings(self.local_settings)
        logging.info(f"Chat: 'Zapamiętaj dane' dla serwera '{active_server_data.get('name')}' ustawiono na: {remember_me}")

    def _on_auto_login_toggle(self):
        active_server_data = self._get_active_server_data()
        if not active_server_data: return

        auto_login = self.chat_auto_login_var.get()
        active_server_data["auto_login_to_server"] = auto_login
        
        if auto_login: # Jeśli włączono auto-login, upewnij się, że "zapamiętaj" jest też włączone
            active_server_data["remember_credentials"] = True
            self.chat_remember_me_var.set(True)
            # Upewnij się, że dane są zapisane, jeśli jeszcze nie były
            if not active_server_data.get("credentials", {}).get("email"):
                 active_server_data.setdefault("credentials", {})
                 active_server_data["credentials"]["email"] = self.chat_email_var.get()
                 active_server_data["credentials"]["password"] = self.chat_password_var.get()

        self.local_settings["chat_servers"] = self.chat_servers_list
        save_local_settings(self.local_settings)
        logging.info(f"Chat: 'Auto-logowanie' dla serwera '{active_server_data.get('name')}' ustawiono na: {auto_login}")
    # --- KONIEC NOWYCH ZMIAN (CHAT) ---

    def _chat_register(self):
        username = self.chat_username_var.get().strip()
        email = self.chat_email_var.get().strip()
        password = self.chat_password_var.get()

        if not username or not email or not password:
            messagebox.showerror("Błąd Rejestracji", "Nazwa użytkownika, e-mail i hasło są wymagane.", parent=self.chat_page_frame)
            return

        try:
            response = requests.post(
                f"{self.chat_server_url}/register", 
                json={"username": username, "email": email, "password": password},
                timeout=10
            )
            response.raise_for_status()
            
            data = response.json()
            messagebox.showinfo("Sukces", f"Użytkownik {username} zarejestrowany. Możesz się teraz zalogować.", parent=self.chat_page_frame)
            logging.info(f"Chat: Użytkownik {username} zarejestrowany.")
            
            # Po rejestracji, opcjonalnie automatycznie zaloguj lub zachęć do logowania
            # self.chat_email_var.set(email)
            # self.chat_password_var.set(password)
            # self._chat_login() # Automatyczne logowanie po rejestracji
            
        except requests.exceptions.HTTPError as e:
            # --- NOWE ZMIANY ---
            error_msg = "Nieznany błąd rejestracji."
            if e.response and e.response.status_code:
                try:
                    server_error_data = e.response.json()
                    error_msg = server_error_data.get('error', 'Nieznany błąd serwera.')
                    # Mapowanie kodów błędów na bardziej przyjazne komunikaty
                    if error_msg == "Invalid email format":
                        error_msg = "Nieprawidłowy format adresu e-mail."
                    elif error_msg == "Username already taken":
                        error_msg = "Nazwa użytkownika jest już zajęta."
                    elif error_msg == "Email already registered":
                        error_msg = "Podany adres e-mail jest już zarejestrowany."
                except json.JSONDecodeError:
                    error_msg = f"Serwer zwrócił błąd HTTP {e.response.status_code}, ale bez JSONa."
            else:
                error_msg = f"Błąd połączenia z serwerem: {e}"
            
            messagebox.showerror("Błąd Rejestracji", error_msg, parent=self.chat_page_frame)
            logging.error(f"Chat: Błąd rejestracji: {error_msg}")
            # --- KONIEC NOWYCH ZMIAN ---
        except requests.exceptions.RequestException as e:
            messagebox.showerror("Błąd Sieci", f"Nie można połączyć się z serwerem czatu:\n{e}", parent=self.chat_page_frame)
            logging.error(f"Chat: Błąd sieci podczas rejestracji: {e}")


    def _chat_logout(self):
        if self.sio and self.sio.connected:
            self.sio.disconnect()
            logging.info("Chat: Klient SocketIO rozłączony.")
        
        self.chat_logged_in_user = None
        self.chat_connected_to_server = False
        self.chat_authenticated = False
        # self.chat_users = {} # Możemy zostawić, żeby nie pobierać od nowa, jeśli user szybko się połączy
        # self.active_chat_partner_id = None # Zostawmy, żeby po ponownym zalogowaniu spróbował przywrócić
        # self.chat_messages = {} # Możemy zostawić
        
        # --- NOWE ZMIANY: Warunkowe usuwanie danych logowania ---
        # Usuwaj dane logowania z local_settings tylko, jeśli "Zapamiętaj mnie" jest ODZNACZONE.
        # Jeśli jest zaznaczone, zachowaj je.
        if not self.chat_remember_me_var.get(): # Sprawdź aktualny stan checkboxa
            self.local_settings.pop("chat_email", None)
            self.local_settings.pop("chat_password", None)
            logging.info("Chat: Usunięto dane logowania z local_settings (Zapamiętaj mnie było odznaczone).")
        else:
            logging.info("Chat: Zachowano dane logowania w local_settings (Zapamiętaj mnie było zaznaczone).")
        # --- KONIEC NOWYCH ZMIAN ---
        
        # Zawsze zapisuj stan checkboxów
        self.local_settings["chat_remember_me"] = self.chat_remember_me_var.get()
        self.local_settings["chat_auto_login"] = self.chat_auto_login_var.get()
        save_local_settings(self.local_settings)

        # messagebox.showinfo("Wylogowano", "Wylogowano z czatu.", parent=self.chat_page_frame) # Komunikat jest opcjonalny
        logging.info("Chat: Wylogowano użytkownika (stan UI zostanie zaktualizowany).")
        self._update_chat_ui_state()

    # --- NOWE ZMIANY (CHAT) ---
    def _on_chat_display_resize(self, event=None):
        """
        Dostosowuje marginesy w tk.Text, aby wiadomości miały 'dymki'
        dla różnych rozmiarów okna, ALE TERAZ TYLKO Z BIAŁYMI ODSTĘPAMI.
        """
        if not hasattr(self, 'chat_message_display') or not self.chat_message_display.winfo_exists():
            return
        
        display_width = self.chat_message_display.winfo_width()
        if display_width < 100: # Minimalna sensowna szerokość
            return 

        # --- NOWE ZMIANY ---
        # Używamy szerokiego marginesu po stronie, GDZIE NIE MA TEKSTU, 
        # aby zasymulować "krótki" dymek.
        # Minimalny stały margines dla estetyki (tekst nie przykleja się do krawędzi okna)
        fixed_text_margin = 10 

        # Maksymalny proporcjonalny margines, który tworzy "dymek"
        # Będzie to % szerokości okna wiadomości.
        proportional_gap = int(display_width * 0.35) # Np. 35% szerokości
        min_proportional_gap = 100 # Minimalne oddalenie wiadomości od przeciwległej krawędzi

        # Margines z lewej dla moich wiadomości (push to right)
        # Będzie to lmargin1 i lmargin2. Prawy margines jest stały i mały (fixed_text_margin)
        my_left_indent = max(min_proportional_gap, proportional_gap) 

        # Margines z prawej dla wiadomości od innych (push to left)
        # Będzie to rmargin. Lewy margines jest stały i mały (fixed_text_margin)
        other_right_indent = max(min_proportional_gap, proportional_gap)


        # Zastosuj obliczone marginesy do tagów
        # Tag "my_message_tag": tekst wyrównany do prawej, lewy margines odpycha tekst od lewej strony okna
        # po obliczeniu my_left_indent i other_right_indent
        # Twoje wiadomości: bubble przy prawej krawędzi, szerokość = widget_width - (fixed + proportional)
        self.chat_message_display.tag_config("my_message_tag",
            lmargin1=fixed_text_margin,   # mały odstęp od lewej
            lmargin2=fixed_text_margin,
            rmargin=my_left_indent        # duży odstęp od prawej
        )

        # Wiadomości innych: bubble przy lewej, szerokość = widget_width - (proportional + fixed)
        self.chat_message_display.tag_config("other_message_tag",
            lmargin1=other_right_indent,  # duży odstęp od lewej
            lmargin2=other_right_indent,
            rmargin=fixed_text_margin     # mały odstęp od prawej
        )

        # ====== NOWE: skalowanie zapisanych kontenerów ======
        if hasattr(self, "_chat_bubble_containers"):
            for cont in list(self._chat_bubble_containers):
                if cont.winfo_exists():
                    cont.configure(width=display_width)
                    # po zmianie szerokości policz wysokość, żeby nie znikł
                    cont.update_idletasks()
                    cont.configure(height=cont.winfo_reqheight())
                else:
                    # usuwamy z listy, jeśli kontener został zniszczony
                    self._chat_bubble_containers.remove(cont)
        # ====== KONIEC NOWE ======
        # --- KONIEC NOWYCH ZMIAN ---

    def _update_chat_ui_state(self):
        """
        Aktualizuje, który panel (logowania czy czatu) jest widoczny, 
        oraz status połączenia i początkowy widok czatu.
        """
        if self.chat_logged_in_user and self.chat_connected_to_server and self.chat_authenticated:
            self.chat_auth_panel.grid_remove() 
            self.chat_main_panel.grid(row=0, column=0, sticky="nsew")
            
            if hasattr(self, 'chat_current_user_label') and self.chat_current_user_label.winfo_exists():
                username = self.chat_logged_in_user.get('username', 'Nieznany')
                self.chat_current_user_label.config(text=f"Zalogowano jako: {username}")
            
            self.chat_connection_status_label.config(text="Status: Połączono", foreground="lightgreen")
            
            # --- NOWE ZMIANY: Wywołaj _fetch_chat_users TUTAJ ---
            # Po pomyślnym uwierzytelnieniu, pobierz dane użytkowników i pokoi.
            # Dopiero po tym można odświeżyć dashboard i listę kontaktów.
            self._fetch_chat_users() 
            # Po `_fetch_chat_users` -> `_filter_chat_users`
            # A jeśli `active_chat_partner_id` jest `chat_dashboard_placeholder_id`, to odświeży dashboard.
            # To jest sekwencja, która powinna zadziałać.
            # `_fetch_chat_users` samo wywołuje `_filter_chat_users` po pobraniu danych.

            # Upewnij się, że dashboard jest wyświetlony, jeśli to pierwszy raz,
            # lub jeśli nie ma zapamiętanego ostatniego czatu.
            # `show_chat_page` ustawia `self.active_chat_partner_id` na dashboard.
            if self.active_chat_partner_id == self.chat_dashboard_placeholder_id:
                 self.root.after(50, self._show_chat_dashboard) # Małe opóźnienie na pobranie użytkowników

            self._update_send_button_state() # Upewnij się, że przycisk "Wyślij" jest aktywny
            # --- KONIEC NOWYCH ZMIAN ---
            
        else: # Nie jesteśmy w pełni zalogowani/połączeni
            self.chat_main_panel.grid_remove() 
            self.chat_auth_panel.grid(row=0, column=0, sticky="nsew")
            self.chat_connection_status_label.config(text="Status: Rozłączono", foreground="red")
            if hasattr(self, 'chat_current_user_label') and self.chat_current_user_label.winfo_exists():
                self.chat_current_user_label.config(text="Zalogowano jako: Nieznany")
            # Wyczyść dane czatu na wypadek, gdyby były
            self.chat_users = {}
            self.chat_rooms = {}
            self.online_users.clear()
            if hasattr(self, 'chat_users_tree'): self.chat_users_tree.delete(*self.chat_users_tree.get_children())
            self._update_send_button_state() # Przycisk Wyślij powinien być nieaktywny
            
    # --- KONIEC NOWYCH ZMIAN (CHAT) ---


    def _is_user_blocked(self, user_id_to_check: int) -> bool:
        """Sprawdza, czy użytkownik o podanym ID jest na liście zablokowanych."""
        return user_id_to_check in self.blocked_user_ids

    def _update_chat_ui_for_blocked_status(self):
        """Aktualizuje UI czatu (pole wprowadzania, komunikat) w zależności od statusu blokady aktywnego partnera."""
        if not (hasattr(self, 'chat_input_entry') and self.chat_input_entry.winfo_exists()):
            return
        
        # Inicjalizuj label blokady, jeśli nie istnieje
        if not hasattr(self, 'chat_block_status_label'):
            self.chat_block_status_label = ttk.Label(
                self.chat_messages_panel, 
                text="", 
                font=("Segoe UI", 9, "italic"), 
                foreground="orange",
                anchor="w"
            )
            # Celowo nie umieszczamy go w gridzie od razu

        is_currently_blocked = False
        if self.active_chat_type == "user" and self.active_chat_partner_id is not None:
            if self._is_user_blocked(self.active_chat_partner_id):
                is_currently_blocked = True

        if is_currently_blocked:
            self.chat_input_entry.config(state=tk.DISABLED)
            self.chat_input_var.set("") 
            self.chat_block_status_label.config(text=f"Zablokowałeś tego użytkownika. Odblokuj, aby wysyłać wiadomości.")
            # Umieść label blokady nad polem input, a pod panelem wiadomości
            self.chat_block_status_label.grid(row=4, column=0, columnspan=2, sticky="ew", padx=10, pady=(2,0))
            # Reszta elementów przesuwa się w dół
            self.chat_input_entry.grid_configure(row=5)
            # Ramka podglądu cytowanej wiadomości (jeśli istnieje)
            if hasattr(self, 'chat_reply_preview_frame') and self.chat_reply_preview_frame.winfo_exists():
                 self.chat_reply_preview_frame.grid_configure(row=6)
            # Ramka podglądu oczekującego załącznika (jeśli istnieje)
            if hasattr(self, 'chat_pending_attachment_frame') and self.chat_pending_attachment_frame.winfo_exists():
                self.chat_pending_attachment_frame.grid_configure(row=7)
            # Ramka przycisków akcji
            if hasattr(self, 'chat_action_buttons_frame') and self.chat_action_buttons_frame.winfo_exists():
                self.chat_action_buttons_frame.grid_configure(row=8)
            # Przycisk wylogowania
            # (zakładamy, że masz referencję do niego, np. self.chat_logout_button)
            if hasattr(self, 'chat_logout_button') and self.chat_logout_button.winfo_exists(): # Znajdź i przesuń przycisk wylogowania
                 self.chat_logout_button.grid_configure(row=9)
            
        else: # Użytkownik nie jest zablokowany lub to nie czat prywatny
            self.chat_block_status_label.grid_remove() # Ukryj label blokady

            # Przywróć standardowe pozycje widgetów
            # Okno wiadomości powinno być zawsze na row=3, gdy nie ma statusu blokady
            # self.chat_message_display.grid_configure(row=3) # Nie ruszamy tego, bo jest zarządzane wyżej
            # self.messages_scrollbar.grid_configure(row=3)

            self.chat_input_entry.grid_configure(row=4)
            if hasattr(self, 'chat_reply_preview_frame') and self.chat_reply_preview_frame.winfo_exists():
                 self.chat_reply_preview_frame.grid_configure(row=5)
            if hasattr(self, 'chat_pending_attachment_frame') and self.chat_pending_attachment_frame.winfo_exists():
                 self.chat_pending_attachment_frame.grid_configure(row=6) # Miejsce na attachment
            if hasattr(self, 'chat_action_buttons_frame') and self.chat_action_buttons_frame.winfo_exists():
                 self.chat_action_buttons_frame.grid_configure(row=7)
            if hasattr(self, 'chat_logout_button') and self.chat_logout_button.winfo_exists():
                 self.chat_logout_button.grid_configure(row=8)

            # Upewnij się, że chat_input_entry jest aktywne, jeśli inne warunki na to pozwalają
            send_possible = (self.chat_logged_in_user and
                             self.chat_connected_to_server and
                             self.chat_authenticated and
                             (self.active_chat_type == "user" or self.active_chat_type == "room") and
                             self.active_chat_partner_id != self.chat_dashboard_placeholder_id)
            self.chat_input_entry.config(state=tk.NORMAL if send_possible else tk.DISABLED)

        # --- NOWE ZMIANY: Zawsze aktualizuj UI załącznika na końcu ---
        # To zapewni, że ramka załącznika jest poprawnie ukryta, jeśli nie ma załącznika
        self._update_pending_attachment_ui()
        self._update_reply_preview_ui() # I podgląd odpowiedzi też
        # --- KONIEC NOWYCH ZMIAN ---
        
        # Zawsze aktualizuj stan przycisku Wyślij
        self._update_send_button_state()

    # --- NOWE ZMIANY (CHAT KLIENT - Edycja wiadomości) ---
    def _on_message_edited_event(self, updated_message_data: dict):
        """
        Aktualizuje lokalną historię wiadomości po edycji i odświeża widok.
        """
        edited_message_id = updated_message_data.get('id')
        if not edited_message_id:
            logging.error("Chat: Otrzymano event edycji wiadomości bez ID.")
            return

        # Zaktualizuj lokalną kopię historii
        message_updated_in_local_history = False
        for partner_id, messages_list in self.chat_messages.items():
            for i, msg_data_local in enumerate(messages_list):
                if msg_data_local.get('id') == edited_message_id:
                    # Zamień stary słownik wiadomości na nowy, zaktualizowany
                    self.chat_messages[partner_id][i] = updated_message_data
                    message_updated_in_local_history = True
                    logging.info(f"Chat: Lokalnie zaktualizowano wiadomość ID {edited_message_id}.")
                    break
            if message_updated_in_local_history:
                break

        # Jeśli zaktualizowano stan lokalny i dotyczy to aktywnego czatu, odśwież widok
        if message_updated_in_local_history and self.active_chat_partner_id == partner_id:
            logging.debug(f"Chat: Wiadomość ID {edited_message_id} była w aktywnym czacie, odświeżanie.")
            # Wymuś ponowne wyświetlenie historii aktywnego czatu
            setattr(self, '_force_history_reload_for_partner', True) # Flaga wymuszająca przeładowanie
            self._display_active_chat_history(self.active_chat_partner_id)
    # --- KONIEC NOWYCH ZMIAN (CHAT KLIENT - Edycja wiadomości) ---
# W klasie GameLauncher, metoda _filter_chat_users()
    def _filter_chat_users(self):
        search_term = self.chat_user_search_var.get().lower().strip()
        
        if not hasattr(self, 'chat_users_tree') or not self.chat_users_tree.winfo_exists():
            logging.error("Chat: _filter_chat_users - Treeview nie istnieje lub nie jest widoczny.")
            return
        
        self.chat_users_tree.delete(*self.chat_users_tree.get_children()) 
        
        self.chat_users_tree.insert("", 0, iid=self.chat_dashboard_placeholder_id, 
                                    values=("💬 Panel Główny Czatu", ""), tags=("system_header_tag", "dashboard_placeholder")) 
        
        users_header_iid = "section_users_header"
        self.chat_users_tree.insert("", "end", iid=users_header_iid,
                                    values=("👤 Użytkownicy", ""), tags=("system_header_tag",))

        users_matching_filter_found = False
        if self.chat_logged_in_user:
            # --- NOWE ZMIANY ---
            logging.debug(f"Chat Filter: Filtering users. self.online_users: {self.online_users}. All known chat users: {list(self.chat_users.keys())}. Self ID: {self.chat_logged_in_user['user_id']}")
            # --- KONIEC NOWYCH ZMIAN ---
            for user_id, user_info in sorted(self.chat_users.items(), key=lambda item: item[1].get('username', '').lower()):
                if user_id == self.chat_logged_in_user['user_id']: 
                    continue

                username = user_info.get('username', f"ID_{user_id}")
                username_lower = username.lower()

                if search_term in username_lower:
                    tags = ["user_chat_item"] 
                    display_name_with_status = username 

                    if user_id in self.online_users:
                        tags.append("user_online_tag") 
                        display_name_with_status = f"{username} (online)"
                    else:
                        tags.append("user_offline_tag") 
                        display_name_with_status = f"{username} (offline)"
                    
                    unread_count = self.unread_messages_count.get(user_id, 0)
                    if unread_count > 0: 
                        tags.append("new_message_tag") 
                        unread_count_str = str(unread_count) 
                    else:
                        unread_count_str = ""

                    self.chat_users_tree.insert(users_header_iid, "end", iid=f"{self.CHAT_PREFIX_USER}{user_id}", 
                                                values=(display_name_with_status, unread_count_str),
                                                tags=tuple(tags))
                    users_matching_filter_found = True
            
            if not users_matching_filter_found and search_term:
                self.chat_users_tree.insert(users_header_iid, "end", iid="no_users_results", values=("Brak użytkowników", ""), tags=("system_header_tag",))
        elif search_term:
            self.chat_users_tree.insert(users_header_iid, "end", iid="no_users_results_not_logged_in", values=("Zaloguj się, aby wyszukać", ""), tags=("system_header_tag",))



        # Sekcja Pokoje Grupowe (pozostaje bez większych zmian w tej iteracji)
        rooms_header_iid = "section_rooms_header"
        self.chat_users_tree.insert("", "end", iid=rooms_header_iid, 
                                    values=("🏢 Pokoje Grupowe", ""), tags=("system_header_tag",))

        rooms_matching_filter_found = False
        for room_id, room_info in sorted(self.chat_rooms.items(), key=lambda item: item[1]['name'].lower()):
            room_name = room_info.get('name', f"Pokój ID_{room_id}")
            room_name_lower = room_name.lower()
            if search_term in room_name_lower:
                tags = ["room_chat_item"]
                unread_count_room_str = "" # Placeholder
                
                self.chat_users_tree.insert(rooms_header_iid, "end", iid=f"{self.CHAT_PREFIX_ROOM}{room_id}", 
                                            values=(room_name, unread_count_room_str), tags=tuple(tags))
                rooms_matching_filter_found = True
        if not rooms_matching_filter_found and search_term:
            self.chat_users_tree.insert(rooms_header_iid, "end", values=("Brak pokoi grupowych", ""), tags=("system_header_tag",))
            # --- KONIEC NOWYCH ZMIAN ---
        
        # ... (reszta kodu przywracania zaznaczenia) ...

        item_to_select_id = None
        # Sprawdź, czy self.active_chat_type jest ustawione
        if self.active_chat_partner_id and self.active_chat_type: 
            if self.active_chat_type == "user":
                item_to_select_id = f"{self.CHAT_PREFIX_USER}{self.active_chat_partner_id}"
            elif self.active_chat_type == "room":
                item_to_select_id = f"{self.CHAT_PREFIX_ROOM}{self.active_chat_partner_id}"
            elif self.active_chat_type == "dashboard":
                item_to_select_id = self.chat_dashboard_placeholder_id
        
        if item_to_select_id and self.chat_users_tree.exists(item_to_select_id):
            self.chat_users_tree.selection_set(item_to_select_id)
            self.chat_users_tree.see(item_to_select_id)
            self.chat_users_tree.focus(item_to_select_id)
        elif self.chat_users_tree.exists(self.chat_dashboard_placeholder_id): # Domyślny wybór na dashboard, jeśli nie ma nic innego
            self.chat_users_tree.selection_set(self.chat_dashboard_placeholder_id)
            self.chat_users_tree.focus(self.chat_dashboard_placeholder_id)
            # Zresetuj active_chat_partner_id i type, jeśli nie można było ustawić focusu
            self.active_chat_partner_id = self.chat_dashboard_placeholder_id
            self.active_chat_type = "dashboard"


        # self.chat_users_tree.event_generate("<<TreeviewSelect>>") # Lepiej, żeby user sam kliknął po załadowaniu

    # --- NOWE ZMIANY (CHAT) ---
    def _reset_chat_search_field(self):
        """Resetuje pole wyszukiwania użytkowników czatu."""
        self.chat_user_search_var.set("")
        # Możesz opcjonalnie przenieść tutaj fokus, jeśli chcesz.
        # self.chat_user_search_entry.focus_set()
    # --- KONIEC NOWYCH ZMIAN (CHAT) ---

    # --- NOWE ZMIANY (CHAT) ---
    def _connect_to_chat_server(self):
        if self.sio and self.sio.connected:
            logging.info("Chat: Klient SocketIO już połączony.")
            return

        # --- NOWE ZMIANY ---
        if not self.chat_logged_in_user: # Poprawiona nazwa atrybutu
        # --- KONIEC NOWYCH ZMIAN ---

            logging.warning("Chat: Brak zalogowanego użytkownika, nie można połączyć z SocketIO.")
            return

        logging.info(f"Chat: Próba połączenia z SocketIO na {self.chat_server_url}...")
        self.sio = socketio.Client(
            reconnection=True,
            reconnection_attempts=0,   # 0 = nieskończoność
            reconnection_delay=2,      # pierwsza próba po 2s
            reconnection_delay_max=10
        )
        self.sio.eio.ping_interval = 60
        self.sio.eio.ping_timeout = 120


        # --- NOWE ZMIANY (Członkowie Pokoju - Zarządzanie Admina ETAP 2/3) ---
        @self.sio.event
        def member_removed_from_room(data):
            room_id_event = data.get('room_id')
            removed_user_id_event = data.get('removed_user_id')
            removed_username_event = data.get('removed_username', 'Nieznany')
            admin_username_event = data.get('admin_username', 'Admin')

            logging.info(f"Chat Event: Użytkownik '{removed_username_event}' (ID: {removed_user_id_event}) "
                         f"został usunięty z pokoju {room_id_event} przez '{admin_username_event}'.")

            # Jeśli to my zostaliśmy usunięci z aktywnie otwartego pokoju
            if self.chat_logged_in_user and removed_user_id_event == self.chat_logged_in_user['user_id'] and \
               self.active_chat_type == "room" and self.active_chat_partner_id == room_id_event:
                
                self.root.after(0, lambda: messagebox.showwarning(
                    "Usunięto z Pokoju",
                    f"Zostałeś usunięty z pokoju '{self.chat_rooms.get(room_id_event, {}).get('name', f'ID {room_id_event}')}' "
                    f"przez administratora '{admin_username_event}'.",
                    parent=self.chat_page_frame
                ))
                # --- NOWA ZMIANA: Resetuj chat ---
                self._reset_to_chat_dashboard()
                # --- KONIEC NOWEJ ZMIANY ---
            
            # Niezależnie od tego, kto został usunięty, odśwież listę członków, jeśli ten pokój jest aktywny
            elif self.active_chat_type == "room" and self.active_chat_partner_id == room_id_event:
                self.root.after(50, self._load_and_display_room_members, room_id_event)
                self.root.after(100, lambda: self._display_chat_message(
                    f"--- Użytkownik '{removed_username_event}' został usunięty z pokoju przez {admin_username_event}. ---", 
                    "system"
                ))
            
            # Zawsze odśwież główne drzewo kontaktów i dane pokoi (aby zaktualizować listę członków w self.chat_rooms)
            # --- NOWA ZMIANA: Wołaj _fetch_chat_users która woła _fetch_chat_rooms ---
            self.root.after(150, self._fetch_chat_users)
            # --- KONIEC NOWEJ ZMIANY ---

        # --- NOWE ZMIANY (CHAT) ---
        @self.sio.event
        def user_online(data):
            user_id = data.get('user_id')
            if user_id:
                # --- NOWE ZMIANY ---
                logging.info(f"Chat: RECEIVED 'user_online' for User ID: {user_id}. Current self.online_users: {self.online_users}")
                if user_id not in self.online_users:
                    self.online_users.add(user_id)
                    logging.info(f"Chat: ADDED {user_id} to self.online_users. New state: {self.online_users}")
                    self.root.after(0, self._refresh_chat_dashboard_if_visible)
                    self.root.after(0, self._filter_chat_users) # Wymuś odświeżenie Treeview
                # --- KONIEC NOWYCH ZMIAN ---

        @self.sio.event
        def user_offline(data):
            user_id = data.get('user_id')
            if user_id and user_id in self.online_users:
                # --- NOWE ZMIANY ---
                self.online_users.remove(user_id)
                logging.info(f"Chat: REMOVED {user_id} from self.online_users. New state: {self.online_users}")
                self.root.after(0, self._refresh_chat_dashboard_if_visible)
                self.root.after(0, self._filter_chat_users) # Wymuś odświeżenie Treeview
                # --- KONIEC NOWYCH ZMIAN ---

        # --- NOWE ZMIANY (Obsługa eventu o zmianie statusu bana) ---
        @self.sio.event
        def account_status_changed(data):
            is_now_banned = data.get('banned', False)
            reason = data.get('reason', '')
            
            if is_now_banned:
                logging.warning(f"Chat Event: Twoje konto zostało zbanowane. Powód: {reason}")
                self.root.after(0, lambda r=reason: messagebox.showwarning(
                    "Konto Zablokowane",
                    f"Twoje konto czatu zostało zablokowane przez administratora.\nPowód: {r}\n\nZostaniesz wylogowany z czatu.",
                    parent=self.chat_page_frame if hasattr(self, 'chat_page_frame') else self.root
                ))
                # Wymuś wylogowanie i rozłączenie SocketIO po stronie klienta
                self.root.after(100, self._chat_logout) # _chat_logout już powinno obsłużyć disconnect
            else: # Zostałeś odbanowany
                logging.info(f"Chat Event: Twoje konto zostało odblokowane. Powód: {reason}")
                self.root.after(0, lambda r=reason: messagebox.showinfo(
                    "Konto Odblokowane",
                    f"Twoje konto czatu zostało odblokowane.\n{r}",
                    parent=self.chat_page_frame if hasattr(self, 'chat_page_frame') else self.root
                ))
                # Klient nie musi nic specjalnego robić, przy następnym logowaniu będzie mógł wejść.
                # Jeśli był wylogowany, _chat_logout już ustawił odpowiedni stan UI.
        # --- KONIEC NOWYCH ZMIAN ---

        @self.sio.event
        def online_users_list(data):
            online_ids_received = data.get('online_users', [])
            # --- NOWE ZMIANY ---
            logging.info(f"Chat: RECEIVED 'online_users_list': {online_ids_received}. Current self.online_users (before processing): {self.online_users}")
            
            # Tworzymy nowy zbiór na podstawie otrzymanej listy, aby uniknąć problemów z modyfikacją podczas iteracji
            new_online_set = set(online_ids_received)
            
            # Dodaj swoje własne ID do listy online (jeśli jest uwierzytelniony)
            if self.chat_logged_in_user and self.chat_authenticated:
                new_online_set.add(self.chat_logged_in_user['user_id'])
                logging.debug(f"Chat: Added self ({self.chat_logged_in_user['user_id']}) to new_online_set.")
            
            # Zaktualizuj self.online_users, tylko jeśli nowy zbiór jest inny od obecnego
            if self.online_users != new_online_set:
                self.online_users = new_online_set # Całkowicie nadpisz zbiór
                logging.info(f"Chat: self.online_users FINAL STATE after 'online_users_list': {self.online_users}")
                # Po masowej aktualizacji, odśwież dashboard i listę kontaktów
                self.root.after(0, self._refresh_chat_dashboard_if_visible)
                self.root.after(0, self._filter_chat_users)
            else:
                logging.debug("Chat Event: 'online_users_list' - self.online_users unchanged.")
            # --- KONIEC NOWYCH ZMIAN ---

        # --- NOWE ZMIANY (OBSŁUGA EVENTÓW CZATU GRUPOWEGO) ---
        # --- NOWE ZMIANY (CHAT KLIENT - Odświeżanie listy pokoi) ---
        @self.sio.event
        def new_room_created(data):
            new_room_data = data.get('room')
            if new_room_data:
                room_id = new_room_data.get('id')
                room_name = new_room_data.get('name', 'Nowy Pokój')
                logging.info(f"Chat Event: Nowy pokój utworzony na serwerze: '{room_name}' (ID: {room_id})")
                
                # Dodaj nowy pokój do lokalnego słownika self.chat_rooms
                self.chat_rooms[room_id] = new_room_data
                
                # Odśwież listę użytkowników/pokoi w Treeview
                # _filter_chat_users zostanie wywołane przez _fetch_chat_users,
                # ale możemy też odświeżyć bezpośrednio _filter_chat_users, jeśli _fetch_chat_users jest zbyt ciężkie.
                # Na razie _fetch_chat_users (które pobiera też pokoje) wydaje się ok.
                self.root.after(0, self._fetch_chat_users) 
                
                # Opcjonalnie: Pokaż powiadomienie o nowym pokoju, jeśli nie jest to nasz pokój
                if self.chat_logged_in_user and new_room_data.get('creator_id') != self.chat_logged_in_user['user_id']:
                    # Można dodać subtelniejsze powiadomienie
                    # messagebox.showinfo("Nowy Pokój", f"Nowy pokój czatu został utworzony: '{room_name}'", parent=self.chat_page_frame)
                    pass
        # --- KONIEC NOWYCH ZMIAN ---

        # --- NOWY EVENT HANDLER (Samodzielne opuszczanie pokoju) ---
        @self.sio.event
        def member_left_room(data):
            """
            Obsługuje event informujący, że członek (być może my) opuścił pokój.
            Data: {'room_id': ..., 'user_id': ..., 'username': ...}
            """
            room_id_event = data.get('room_id')
            left_user_id = data.get('user_id')
            left_username = data.get('username', 'Nieznany')

            logging.info(f"Chat Event: Użytkownik '{left_username}' (ID: {left_user_id}) opuścił pokój {room_id_event}.")

            # Jeśli to my opuściliśmy aktywnie otwarty pokój
            if self.chat_logged_in_user and left_user_id == self.chat_logged_in_user['user_id'] and \
               self.active_chat_type == "room" and self.active_chat_partner_id == room_id_event:
                
                self.root.after(0, lambda: messagebox.showinfo(
                    "Opuściłeś Pokój",
                    f"Opuściłeś pokój '{self.chat_rooms.get(room_id_event, {}).get('name', f'ID {room_id_event}')}'.",
                    parent=self.chat_page_frame
                ))
                self._reset_to_chat_dashboard() # Przełącz na dashboard
            
            # Niezależnie, odśwież listę członków, jeśli ten pokój jest aktywny (u innych)
            elif self.active_chat_type == "room" and self.active_chat_partner_id == room_id_event:
                self.root.after(50, self._load_and_display_room_members, room_id_event)
                self.root.after(100, lambda: self._display_chat_message(
                    f"--- Użytkownik '{left_username}' opuścił pokój. ---", 
                    "system"
                ))
            
            # Zawsze odśwież dane pokoi (aby zaktualizować member_ids w self.chat_rooms)
            self.root.after(150, self._fetch_chat_users) 
        # --- KONIEC NOWEGO EVENT HANDLERA ---

        # --- NOWE ZMIANY (CHAT KLIENT - Usuwanie pokoju przez twórcę) ---
        @self.sio.event
        def room_deleted_by_creator(data):
            """
            Obsługuje event informujący, że pokój został usunięty przez twórcę.
            Data: {'room_id': ..., 'room_name': ..., 'creator_id': ..., 'creator_username': ...}
            """
            deleted_room_id = data.get('room_id')
            deleted_room_name = data.get('room_name', 'Nieznany pokój')
            creator_username_who_deleted = data.get('creator_username', 'Twórca')

            logging.info(f"Chat Event: Pokój '{deleted_room_name}' (ID: {deleted_room_id}) "
                         f"został usunięty przez twórcę '{creator_username_who_deleted}'.")

            # Usuń pokój z lokalnego słownika
            if deleted_room_id in self.chat_rooms:
                del self.chat_rooms[deleted_room_id]
                logging.debug(f"Usunięto pokój ID {deleted_room_id} z lokalnego self.chat_rooms.")

            # Jeśli usunięty pokój był aktywnym czatem, przełącz na dashboard
            if self.active_chat_type == "room" and self.active_chat_partner_id == deleted_room_id:
                self.root.after(0, lambda: messagebox.showinfo(
                    "Pokój Usunięty",
                    f"Pokój '{deleted_room_name}', w którym byłeś, został usunięty przez twórcę ({creator_username_who_deleted}).",
                    parent=self.chat_page_frame
                ))
                self._reset_to_chat_dashboard() # Przełącza widok i ukrywa panel członków
            else:
                # Jeśli nie był to aktywny czat, ale użytkownik mógł być jego członkiem,
                # po prostu wyświetl informację (jeśli okno czatu jest widoczne)
                if self.current_frame == self.chat_page_frame:
                     self.root.after(0, lambda: messagebox.showinfo(
                        "Pokój Usunięty",
                        f"Pokój '{deleted_room_name}', którego byłeś członkiem, "
                        f"został usunięty przez twórcę ({creator_username_who_deleted}).",
                        parent=self.chat_page_frame
                    ))
            
            # Zawsze odśwież listę kontaktów (pokoi/użytkowników) w Treeview
            self.root.after(100, self._fetch_chat_users) # To pociągnie _filter_chat_users
        # --- KONIEC NOWYCH ZMIAN ---

        # --- NOWE ZMIANY: Event dla usuniętej wiadomości ---
        @self.sio.event
        def message_deleted_successfully(data): # Nazwa eventu taka sama jak na serwerze
            """Odebrano potwierdzenie usunięcia wiadomości."""
            logging.debug(f"Chat: Odebrano event 'message_deleted_successfully': {data}")
            self.root.after(0, self._on_message_deleted_event, data)
        
        @self.sio.event
        def message_delete_failed(data): # Nazwa eventu taka sama jak na serwerze
            """Odebrano informację o nieudanym usunięciu."""
            logging.debug(f"Chat: Odebrano event 'message_delete_failed': {data}")
            self.root.after(0, self._on_message_deleted_event, data) # Możemy użyć tej samej funkcji obsługi
        # --- KONIEC NOWYCH ZMIAN ---

        # --- NOWE ZMIANY: Event informujący, że nasza wiadomość została przeczytana ---
        @self.sio.event
        def message_read_update(data):
            """
            Odebrano informację od serwera, że wiadomość (którą my wysłaliśmy)
            została przeczytana przez odbiorcę.
            Data: {'message_id': ..., 'read_by_user_id': ..., 'is_read': True}
            """
            message_id = data.get('message_id')
            is_read = data.get('is_read', False)
            
            logging.debug(f"Chat: Odebrano 'message_read_update' dla wiadomości ID {message_id}, is_read={is_read}")

            if message_id and is_read:
                # Zaktualizuj status tej wiadomości w naszej lokalnej historii (self.chat_messages)
                # To jest ważne, aby przy ponownym renderowaniu historii (np. po przełączeniu czatu)
                # status "przeczytane" był poprawnie wyświetlany.
                message_updated_in_local_history = False
                for partner, messages_list in self.chat_messages.items():
                    for i, msg_data_local in enumerate(messages_list):
                        if msg_data_local.get('id') == message_id:
                            # Upewnijmy się, że to wiadomość WYSŁANA przez nas
                            if msg_data_local.get('sender_id') == self.chat_logged_in_user['user_id']:
                                if msg_data_local.get('is_read_by_receiver') != True:
                                    self.chat_messages[partner][i]['is_read_by_receiver'] = True
                                    message_updated_in_local_history = True
                                    logging.info(f"Chat: Zaktualizowano lokalny status 'is_read_by_receiver' dla wiadomości ID {message_id}")
                                break # Znaleziono wiadomość
                    if message_updated_in_local_history:
                        break 
                
                # Jeśli aktualnie wyświetlamy czat, w którym jest ta wiadomość, odśwież widok,
                # aby pokazać wskaźnik "przeczytane".
                # Sprawdzamy self.active_chat_partner_id - jeśli jest to odbiorca tej wiadomości, odśwież.
                if message_updated_in_local_history: # Tylko jeśli faktycznie zaktualizowaliśmy lokalny stan
                     # Partner to odbiorca wiadomości, którą MY wysłaliśmy
                     partner_of_this_message = data.get('read_by_user_id') 
                     if self.active_chat_partner_id == partner_of_this_message:
                          logging.debug(f"Chat: Wiadomość ID {message_id} była w aktywnym czacie, odświeżanie.")
                          # Wymuś ponowne wyświetlenie historii aktywnego czatu
                          # Użyj _force_history_reload_for_partner, aby _on_chat_user_select wiedziało, że ma przeładować
                          setattr(self, '_force_history_reload_for_partner', True)
                          self._display_active_chat_history(self.active_chat_partner_id)
        # --- KONIEC NOWYCH ZMIAN ---

        # Definicja event handlerów
        # Definicja event handlerów
        @self.sio.event
        def connect():
            self.chat_connected_to_server = True
            logging.info("Chat: Połączono z serwerem SocketIO.")
            self.root.after(0, lambda: self.chat_connection_status_label.config(text="Status: Połączono", foreground="lightgreen"))
            # --- NOWE ZMIANY ---
            # Wyślij uwierzytelnienie dopiero PO aktualizacji UI połączenia
            # i po małym opóźnieniu, aby UI zdążyło się ustabilizować.
            self.root.after(100, lambda: self.sio.emit('authenticate', {'user_id': self.chat_logged_in_user['user_id']}))
            # --- KONIEC NOWYCH ZMIAN ---

        @self.sio.event
        def disconnect():
            self.chat_connected_to_server = False
            self.chat_authenticated = False
            logging.warning("Chat: Rozłączono z serwerem SocketIO.")
            # --- NOWE ZMIANY ---
            self.root.after(0, lambda: self.chat_connection_status_label.config(text="Status: Rozłączono", foreground="red"))
            # --- KONIEC NOWYCH ZMIAN ---
            self.root.after(0, lambda: self._display_chat_message("--- Rozłączono z serwerem czatu ---", "system"))
            self.root.after(0, self._update_chat_ui_state)

        @self.sio.event
        def authenticated(data):
            self.chat_authenticated = True
            logging.info(f"Chat: Uwierzytelniono na serwerze SocketIO jako {data.get('username')}.")
            self.root.after(0, lambda: self._display_chat_message(f"--- Uwierzytelniono jako {data.get('username')} ---", "system"))
            self.root.after(0, self._update_chat_ui_state) # To wywoła _fetch_chat_users i _filter_chat_users
            
            # --- NOWE ZMIANY ---
            # Poinformuj serwer, że chcesz dostać aktualną listę online (jeśli tego nie robi server.py automatycznie po uwierzytelnieniu)
            # W obecnej wersji `chat_server.py` to jest już robione w `handle_authentication`
            # `emit('online_users_list', {'online_users': online_users_ids_at_connect})`
            # więc ta linia może być zbędna, ale nie zaszkodzi.
            # self.sio.emit('request_online_users_list') # Zakładając, że serwer ma taki event handler
            # --- KONIEC NOWYCH ZMIAN ---

        @self.sio.event
        def authentication_failed(data):
            logging.error(f"Chat: Uwierzytelnianie SocketIO nieudane: {data.get('message')}")
            self.root.after(0, lambda: self._display_chat_message(f"--- Błąd uwierzytelniania: {data.get('message')} ---", "system"))
            self.sio.disconnect() # Rozłącz, jeśli uwierzytelnianie się nie powiodło

        @self.sio.event
        def private_message_sent(data):
            # Wiadomość, którą wysłaliśmy, została potwierdzona przez serwer
            logging.info(f"Chat: Wysłano wiadomość prywatną do {data.get('receiver_id')}.")
            # --- NOWE ZMIANY: Określ typ na podstawie obecności receiver_id ---
            message_type_context = "private" if data.get('receiver_id') is not None else "unknown"
            self.root.after(0, lambda d=data, mt=message_type_context: self._add_message_to_history(d, is_sent_by_me=True, message_context=mt))
            # --- KONIEC NOWYCH ZMIAN ---

        @self.sio.event
        def private_message_received(data):
            # Otrzymano nową wiadomość prywatną
            logging.info(f"Chat: Otrzymano wiadomość prywatną od {data.get('sender_username')}.")
            # --- NOWE ZMIANY: Określ typ na podstawie obecności receiver_id ---
            message_type_context = "private" if data.get('receiver_id') is not None else "unknown"
            self.root.after(0, lambda d=data, mt=message_type_context: self._add_message_to_history(d, is_sent_by_me=False, message_context=mt))
            # --- KONIEC NOWYCH ZMIAN ---

        # --- NOWE ZMIANY: Handlery dla wiadomości grupowych ---
        @self.sio.event
        def group_message_sent(data):
            """Odebrano potwierdzenie, że nasza wiadomość grupowa została wysłana."""
            logging.info(f"Chat: Wysłano wiadomość grupową do pokoju ID {data.get('room_id')}.")
            # `message_context` będzie 'group', bo to event dla wiadomości grupowych
            self.root.after(0, lambda d=data: self._add_message_to_history(d, is_sent_by_me=True, message_context="group"))

        @self.sio.event
        def group_message_received(data):
            """Odebrano nową wiadomość grupową od innego użytkownika."""
            logging.info(f"Chat: Otrzymano wiadomość grupową od {data.get('sender_username')} w pokoju ID {data.get('room_id')}.")
            # `message_context` będzie 'group'
            self.root.after(0, lambda d=data: self._add_message_to_history(d, is_sent_by_me=False, message_context="group"))
        # --- KONIEC NOWYCH ZMIAN ---

        @self.sio.event
        def message_error(data):
            logging.error(f"Chat: Błąd wiadomości: {data.get('message')}")
            self.root.after(0, lambda: self._display_chat_message(f"--- Błąd wiadomości: {data.get('message')} ---", "error"))

        # --- NOWE ZMIANY (CHAT KLIENT - Edycja wiadomości) ---
        @self.sio.event
        def message_edited_successfully(data):
            """
            Odebrano zaktualizowane dane wiadomości po edycji.
            Data zawiera pełny słownik wiadomości.
            """
            logging.debug(f"Chat: Odebrano 'message_edited_successfully': {data}")
            self.root.after(0, self._on_message_edited_event, data)

        @self.sio.event
        def message_edit_failed(data):
            """Odebrano informację o nieudanej edycji wiadomości."""
            logging.warning(f"Chat: Odebrano 'message_edit_failed': {data}")
            message_id = data.get('message_id', 'Nieznane')
            error_msg = data.get('error', 'Nieznany błąd.')
            self.root.after(0, lambda: messagebox.showerror("Błąd Edycji Wiadomości", f"Nie udało się edytować wiadomości ID {message_id}:\n{error_msg}", parent=self.chat_page_frame))
        # --- KONIEC NOWYCH ZMIAN (CHAT KLIENT - Edycja wiadomości) ---

        # --- NOWE ZMIANY (CHAT) ---
        @self.sio.event
        def typing_update(data):
            sender_id = data.get('sender_id')
            is_typing = data.get('is_typing')
            
            # Zaktualizuj status pisania dla tego użytkownika
            self.typing_status[sender_id] = is_typing
            
            # Odśwież wskaźnik pisania TYLKO jeśli ten użytkownik jest aktywnym partnerem
            if sender_id == self.active_chat_partner_id:
                self.root.after(0, self._update_typing_indicator)
            
            # W przyszłości: wizualna sygnalizacja pisania na liście użytkowników
        # --- KONIEC NOWYCH ZMIAN (CHAT) ---

        # Uruchom połączenie w osobnym wątku, aby nie blokować GUI
        try:
            threading.Thread(target=self.sio.connect, args=(self.chat_server_url,), daemon=True).start()
        except Exception as e:
            logging.error(f"Chat: Błąd uruchomienia wątku połączenia SocketIO: {e}")
            self.root.after(0, lambda: messagebox.showerror("Błąd Połączenia Czatu", f"Nie można uruchomić połączenia SocketIO:\n{e}", parent=self.chat_page_frame))


    # --- NOWE ZMIANY (CHAT) ---
    def _update_typing_indicator(self):
        """Aktualizuje tekst wskaźnika pisania na podstawie self.typing_status."""
        if not hasattr(self, 'chat_typing_indicator_label') or not self.chat_typing_indicator_label.winfo_exists():
            return

        # Sprawdź, czy aktywny partner czatu pisze
        partner_id = self.active_chat_partner_id
        is_partner_typing = self.typing_status.get(partner_id, False)

        if is_partner_typing:
            partner_username = self.chat_users.get(partner_id, {}).get('username', "Nieznany")
            self.chat_typing_indicator_label.config(text=f"{partner_username} pisze...", foreground="gray")
        else:
            self.chat_typing_indicator_label.config(text="", foreground="gray") # Wyczyść tekst

    def _on_chat_input_key_press(self, event=None):
        """Wywoływana przy każdym klawiszu — deleguje logikę po zaktualizowaniu StringVar."""
        if not self.chat_logged_in_user or not self.sio or not self.sio.connected or not self.chat_authenticated:
            return
        # --- NOWE ZMIANY (CHAT GRUPOWY - Etap 2/5 - Zmiana 4/5) ---
        # Upewnij się, że aktywny czat jest użytkownikiem lub pokojem
        if not (self.active_chat_type == "user" or self.active_chat_type == "room"):
            return
        # --- KONIEC NOWYCH ZMIAN ---

        if self.active_chat_partner_id is None or self.active_chat_partner_id == self.chat_dashboard_placeholder_id:
            return

        self.root.after_idle(self._handle_typing_start_logic)

    def _handle_typing_start_logic(self):
        """Właściwa logika uruchamiana po zaktualizowaniu pola tekstowego."""
        current_text = self.chat_input_var.get()
        # --- NOWE ZMIANY (CHAT GRUPOWY - Etap 2/5 - Zmiana 4/5) ---
        # Sygnalizowanie pisania tylko w chatach prywatnych (bo do grup byłoby problematyczne)
        if self.active_chat_type != "user":
            self._typing_sent_flag = False # Upewnij się, że flaga jest zresetowana, by nie wysyłać stop
            return
        # --- KONIEC NOWYCH ZMIAN ---

        if current_text == "":
            return

        if self._typing_timeout_timer:
            self.root.after_cancel(self._typing_timeout_timer)
            self._typing_timeout_timer = None

        if not self._typing_sent_flag:
            try:
                self.sio.emit('typing_start', {
                    'sender_id': self.chat_logged_in_user['user_id'],
                    'receiver_id': self.active_chat_partner_id
                })
                self._typing_sent_flag = True
                logging.debug("Chat: Emitting typing_start.")
            except Exception as e:
                logging.error(f"Chat: Błąd emitowania typing_start: {e}")
                self._typing_sent_flag = False

        self._typing_timeout_timer = self.root.after(1500, self._check_typing_status_timeout)



    def _check_typing_status_timeout(self):
        """Wywoływane po 1.5s bez aktywności — wysyła typing_stop niezależnie od fokusów."""
        self._send_typing_stop_event()


    def _send_typing_stop_event(self):
        """Wysyła event 'typing_stop' do serwera."""
        if self._typing_sent_flag and self.sio and self.sio.connected:
            try:
                self.sio.emit('typing_stop', {
                    'sender_id': self.chat_logged_in_user['user_id'],
                    'receiver_id': self.active_chat_partner_id
                })
                logging.debug("Chat: Emitting typing_stop.")
            except Exception as e:
                logging.error(f"Chat: Błąd emitowania typing_stop: {e}")
            finally:
                self._typing_sent_flag = False

    # --- NOWE ZMIANY (CHAT - Obsługa oczekującego załącznika) ---
    def _select_chat_attachment_dialog(self):
        """Otwiera dialog wyboru pliku i ustawia go jako oczekujący załącznik."""
        if not self.chat_logged_in_user: # Podstawowe sprawdzenie
            return

        filepath = filedialog.askopenfilename(
            title="Wybierz plik do dołączenia",
            parent=self.chat_page_frame
        )
        if not filepath:
            return

        # Wstępna walidacja rozmiaru (jak poprzednio w _select_and_upload_chat_file)
        try:
            file_size_bytes = os.path.getsize(filepath)
            client_max_file_size_mb = 10 
            if file_size_bytes > client_max_file_size_mb * 1024 * 1024:
                messagebox.showerror("Błąd Pliku", f"Wybrany plik jest zbyt duży (maks. {client_max_file_size_mb} MB).", parent=self.chat_page_frame)
                return
        except OSError as e:
            messagebox.showerror("Błąd Pliku", f"Nie można odczytać pliku:\n{filepath}\n{e}", parent=self.chat_page_frame)
            return
            
        original_filename = os.path.basename(filepath)
        self._pending_chat_attachment = {
            'filepath': filepath,
            'original_filename': original_filename
        }
        logging.info(f"Chat: Wybrano plik do załączenia (oczekujący): {original_filename}")
        self._update_pending_attachment_ui()

    def _clear_pending_chat_attachment(self):
        """Usuwa oczekujący załącznik."""
        self._pending_chat_attachment = None
        self._update_pending_attachment_ui()
        logging.info("Chat: Usunięto oczekujący załącznik.")

    def _update_pending_attachment_ui(self):
        """Aktualizuje UI podglądu oczekującego załącznika."""
        if not (hasattr(self, 'chat_pending_attachment_frame') and self.chat_pending_attachment_frame.winfo_exists()):
            return

        if self._pending_chat_attachment:
            original_filename = self._pending_chat_attachment.get('original_filename', 'plik')
            # Prosta ikona na podstawie nazwy (można rozbudować o mimetype jeśli mamy)
            file_icon = "📄" 
            if original_filename.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp')):
                file_icon = "🖼️"
            
            self.chat_pending_attachment_icon_label.config(text=file_icon)
            self.chat_pending_attachment_name_label.config(text=original_filename)
            
            # Pokaż ramkę
            self.chat_pending_attachment_frame.grid(row=5, column=0, columnspan=2, sticky="ew", padx=10, pady=(2,2)) # Wstawia do wiersza 5
        else:
            # Ukryj ramkę
            self.chat_pending_attachment_frame.grid_remove()


# game_launcher.py

    def _on_chat_user_select(self, event=None):
        selected_item_id_tuple = self.chat_users_tree.selection()
        
        if not selected_item_id_tuple:
            current_focus = self.chat_users_tree.focus()
            if current_focus:
                selected_item_id_tuple = (current_focus,)
            else:
                if self.active_chat_partner_id != self.chat_dashboard_placeholder_id or self.active_chat_type != "dashboard":
                    self.active_chat_partner_id = self.chat_dashboard_placeholder_id
                    self.active_chat_type = "dashboard"
                    if hasattr(self, 'chat_users_tree') and self.chat_users_tree.winfo_exists():
                        try:
                            self.chat_users_tree.selection_set(self.chat_dashboard_placeholder_id)
                            self.chat_users_tree.focus(self.chat_dashboard_placeholder_id)
                        except tk.TclError: pass
                    self._display_active_chat_history(None) # Celowo None, aby wyczyścić i pokazać dashboard
                    if hasattr(self, 'chat_active_partner_label'):
                         self.chat_active_partner_label.config(text="Panel Główny Czatu")
                    self._show_chat_dashboard() 
                    # --- NOWE ZMIANY ---
                    # Ukryj panel członków, jeśli dashboard jest aktywny
                    if self._room_members_panel_visible:
                        try:
                            self.chat_paned_window.forget(self.chat_room_members_panel)
                        except tk.TclError:
                            logging.warning("TclError przy forget(self.chat_room_members_panel) w _on_chat_user_select dla dashboardu")
                        self._room_members_panel_visible = False
                    # --- KONIEC NOWYCH ZMIAN ---
                return

        selected_iid_str = selected_item_id_tuple[0]

        if selected_iid_str == self.chat_dashboard_placeholder_id:
            if self.active_chat_partner_id == self.chat_dashboard_placeholder_id and self.active_chat_type == "dashboard":
                logging.debug("Chat: Dashboard already selected and active.")
                return

            self.active_chat_partner_id = self.chat_dashboard_placeholder_id
            self.active_chat_type = "dashboard"
            self._display_chat_message("", "clear") 
            if hasattr(self, 'chat_active_partner_label'):
                self.chat_active_partner_label.config(text="Panel Główny Czatu")
            self._show_chat_dashboard()
            self._cancel_reply_mode()
            self._last_open_chat_partner_id = self.chat_dashboard_placeholder_id
            if hasattr(self, 'chat_typing_indicator_label'): self.chat_typing_indicator_label.config(text="")
            self._update_send_button_state()
            logging.debug(f"Chat: Switched to Dashboard view. Active partner: {self.active_chat_partner_id}, type: {self.active_chat_type}")
            
            # --- NOWE ZMIANY ---
            # Ukryj panel członków dla dashboardu
            if self._room_members_panel_visible:
                try:
                    self.chat_paned_window.forget(self.chat_room_members_panel)
                except tk.TclError:
                     logging.warning("TclError przy forget(self.chat_room_members_panel) w _on_chat_user_select dla dashboardu (2)")
                self._room_members_panel_visible = False
            # --- NOWA ZMIANA: Użyj _show_or_hide_room_members_panel ---
            self._show_or_hide_room_members_panel(show=False)
            # --- KONIEC NOWEJ ZMIANY ---
            return 

        non_selectable_iids = ["section_users_header", "section_rooms_header", 
                               "no_users_results", "no_rooms_results",
                               "no_users_results_not_logged_in"]
        if selected_iid_str in non_selectable_iids:
            logging.debug(f"Chat: Clicked on a non-selectable header or placeholder: {selected_iid_str}. Ignoring.")
            if hasattr(self, 'chat_users_tree') and self.chat_users_tree.winfo_exists() and self.chat_users_tree.exists(self.chat_dashboard_placeholder_id):
                 self.chat_users_tree.selection_set(self.chat_dashboard_placeholder_id)
                 self.chat_users_tree.focus(self.chat_dashboard_placeholder_id)
            return 

        try:
            chat_partner_id_pure = None
            chat_type_detected = None

            if selected_iid_str.startswith(self.CHAT_PREFIX_USER):
                chat_partner_id_pure = int(selected_iid_str[len(self.CHAT_PREFIX_USER):])
                chat_type_detected = "user"
                # --- NOWA ZMIANA: Ukryj panel członków dla użytkownika ---
                self._show_or_hide_room_members_panel(show=False)
                # --- KONIEC NOWEJ ZMIANY ---
            elif selected_iid_str.startswith(self.CHAT_PREFIX_ROOM):
                chat_partner_id_pure = int(selected_iid_str[len(self.CHAT_PREFIX_ROOM):])
                chat_type_detected = "room"
                # --- NOWA ZMIANA: Pokaż panel członków dla pokoju ---
                self._show_or_hide_room_members_panel(show=True)
                if chat_partner_id_pure is not None:
                    self._load_and_display_room_members(chat_partner_id_pure)
                # --- KONIEC NOWEJ ZMIANY ---
            else:
                # Jeśli doszliśmy tutaj, to IID jest nieznany, co jest błędem.
                logging.error(f"Chat: UNEXPECTED - Unrecognized selection IID '{selected_iid_str}' that was not a header or dashboard.")
                raise ValueError("Unrecognized chat item IID (post-checks).")

            # ... (reszta Twojej logiki z poprzedniej wersji, czyli od `if chat_partner_id_pure == self.chat_logged_in_user['user_id']...` w dół,
            #      pozostaje bez zmian, bo wydawała się już poprawna) ...

            if chat_partner_id_pure == self.chat_logged_in_user['user_id'] and chat_type_detected == "user":
                 self.root.after(0, lambda: self._display_chat_message("Nie możesz rozmawiać sam ze sobą!", "error"))
                 if self.active_chat_partner_id:
                      current_selection_iid = None
                      if self.active_chat_type == "user": current_selection_iid = f"{self.CHAT_PREFIX_USER}{self.active_chat_partner_id}"
                      elif self.active_chat_type == "room": current_selection_iid = f"{self.CHAT_PREFIX_ROOM}{self.active_chat_partner_id}"
                      else: current_selection_iid = self.chat_dashboard_placeholder_id
                      if self.chat_users_tree.exists(current_selection_iid): self.chat_users_tree.selection_set(current_selection_iid)
                 return
                
            should_reload_history = (
                chat_partner_id_pure != self.active_chat_partner_id or
                chat_type_detected != self.active_chat_type or
                getattr(self, '_force_history_reload_for_partner', False)
            )
            
            if hasattr(self, '_force_history_reload_for_partner'): self._force_history_reload_for_partner = False

            self.active_chat_partner_id = chat_partner_id_pure
            self.active_chat_type = chat_type_detected 
            self._last_active_chat_type_selected = chat_type_detected

            partner_display_name = ""
            if self.active_chat_type == "user":
                partner_display_name = self.chat_users.get(self.active_chat_partner_id, {}).get('username', f"Użytkownik ID_{self.active_chat_partner_id}")
                # self._update_chat_partner_details(self.active_chat_partner_id) # _update_chat_partner_details jest teraz puste
            elif self.active_chat_type == "room":
                partner_display_name = self.chat_rooms.get(self.active_chat_partner_id, {}).get('name', f"Pokój ID_{self.active_chat_partner_id}")
                # self._fetch_room_members_and_store(self.active_chat_partner_id) # to teraz będzie w _load_and_display_room_members

            if hasattr(self, 'chat_active_partner_label'):
                self.chat_active_partner_label.config(text=f"Czat z: {partner_display_name}")

            if should_reload_history:
                self._load_and_display_chat_history(self.chat_logged_in_user['user_id'], self.active_chat_partner_id, chat_type=self.active_chat_type)
            else:
                # Jeśli nie przeładowujemy historii, a zmieniono na grupę, nadal musimy załadować członków.
                # To już jest robione wyżej. Jeśli to ten sam pokój, `_load_and_display_room_members` może zdecydować, czy odświeżyć.
                self.root.after(50, self._check_and_mark_read)

            self._clear_new_message_notification(self.active_chat_partner_id, chat_type=self.active_chat_type)
            self._last_open_chat_partner_id = self.active_chat_partner_id 
            if hasattr(self, 'chat_typing_indicator_label'): self._update_typing_indicator()
            self._cancel_reply_mode()
            self._update_send_button_state()
            
        except ValueError as e: # Błąd konwersji ID lub nieznany IID
            logging.warning(f"Chat: Błąd podczas przetwarzania wyboru '{selected_iid_str}': {e}")
            self.active_chat_partner_id = self.chat_dashboard_placeholder_id
            self.active_chat_type = "dashboard"
            if hasattr(self, 'chat_users_tree') and self.chat_users_tree.winfo_exists():
                try:
                    self.chat_users_tree.selection_set(self.chat_dashboard_placeholder_id)
                    self.chat_users_tree.focus(self.chat_dashboard_placeholder_id)
                except tk.TclError: pass
            if hasattr(self, 'chat_active_partner_label'):
                self.chat_active_partner_label.config(text="Panel Główny Czatu")
            self._display_chat_message(f"--- Błąd: Problem z wyborem ({selected_iid_str}). ---", "error")
            # --- NOWE ZMIANY ---
            # Upewnij się, że panel członków jest ukryty w razie błędu
            if self._room_members_panel_visible:
                try:
                    self.chat_paned_window.forget(self.chat_room_members_panel)
                except tk.TclError:
                    logging.warning("TclError przy forget(self.chat_room_members_panel) w obsłudze błędu _on_chat_user_select")
                self._room_members_panel_visible = False
            # --- KONIEC NOWYCH ZMIAN ---
            # --- NOWA ZMIANA: Upewnij się, że panel członków jest ukryty w razie błędu ---
            self._show_or_hide_room_members_panel(show=False)
            # --- KONIEC NOWEJ ZMIANY ---
    
    def _reset_to_chat_dashboard(self):
        """Bezpiecznie przełącza widok czatu na panel główny (dashboard)."""
        self.active_chat_partner_id = self.chat_dashboard_placeholder_id
        self.active_chat_type = "dashboard"
        if hasattr(self, 'chat_users_tree') and self.chat_users_tree.winfo_exists():
            try:
                self.chat_users_tree.selection_set(self.chat_dashboard_placeholder_id)
                self.chat_users_tree.focus(self.chat_dashboard_placeholder_id)
            except tk.TclError:
                logging.warning("TclError podczas resetowania do dashboardu (chat_users_tree).")
        
        if hasattr(self, 'chat_active_partner_label'):
            self.chat_active_partner_label.config(text="Panel Główny Czatu")
        
        self._show_chat_dashboard() # Wyświetla zawartość dashboardu
        
        if self._room_members_panel_visible: # Ukryj panel członków
            try:
                self.chat_paned_window.forget(self.chat_room_members_panel)
            except tk.TclError:
                logging.warning("TclError podczas ukrywania panelu członków przy resecie do dashboardu.")
            self._room_members_panel_visible = False
        
        self._cancel_reply_mode() # Anuluj tryb odpowiedzi, jeśli był aktywny
        self._update_send_button_state() # Zaktualizuj stan przycisku wysyłania


    # --- Zmodyfikowana metoda _load_and_display_room_members ---
    def _load_and_display_room_members(self, room_id: int):
        """
        Wypełnia listbox self.room_members_listbox członkami danego pokoju.
        Teraz przechowuje pełne dane w self._last_loaded_room_members_details.
        """
        if not hasattr(self, 'room_members_listbox') or not self.room_members_listbox.winfo_exists():
            logging.error("_load_and_display_room_members: Listbox członków pokoju nie istnieje.")
            return
            
        self.room_members_listbox.delete(0, tk.END) 
        self._last_loaded_room_members_details = [] # Wyczyść poprzednie dane

        room_data = self.chat_rooms.get(room_id)
        if not room_data:
            logging.warning(f"Brak danych dla pokoju ID {room_id} w self.chat_rooms.")
            self.room_members_listbox.insert(tk.END, "(Błąd: Brak danych pokoju)")
            return

        member_ids = room_data.get('member_ids', [])
        if not member_ids:
            self.room_members_listbox.insert(tk.END, "(Brak członków)")
            return

        current_user_id = self.chat_logged_in_user['user_id'] if self.chat_logged_in_user else None
        # --- NOWE ZMIANY (Członkowie Pokoju - Zarządzanie Admina ETAP 2/3) ---
        room_creator_id = room_data.get('creator_id') # Pobierz ID twórcy pokoju
        # --- KONIEC NOWYCH ZMIAN ---

        for user_id_member in member_ids:
            user_info = self.chat_users.get(user_id_member)
            username = user_info.get('username', f"ID_{user_id_member}") if user_info else f"ID_{user_id_member}"
            
            is_online = user_id_member in self.online_users
            is_self = user_id_member == current_user_id
            is_creator = user_id_member == room_creator_id # Sprawdź, czy to twórca

            prefix = ""
            if is_self: prefix = "⭐ "  # Gwiazdka dla siebie (najwyższy priorytet wizualny)
            elif is_creator: prefix = "👑 " # Korona dla twórcy pokoju (jeśli nie jest to self)
            elif is_online: prefix = "🟢 "
            else: prefix = "⚪ " 
                
            display_entry_text = f"{prefix}{username}"
            
            # Kolejność sortowania: Ty, Twórca (jeśli nie Ty), Online, Offline, Alfabetycznie
            sort_key_1_self = 0 if is_self else 1
            sort_key_2_creator = 0 if is_creator else 1
            sort_key_3_online = 0 if is_online else 1
            
            self._last_loaded_room_members_details.append({
                'id': user_id_member, 
                'username': username,
                'display_text': display_entry_text,
                '_sort_keys': (sort_key_1_self, sort_key_2_creator, sort_key_3_online, username.lower())
            })
            
        self._last_loaded_room_members_details.sort(key=lambda x: x['_sort_keys']) 

        for member_detail in self._last_loaded_room_members_details:
            self.room_members_listbox.insert(tk.END, member_detail['display_text'])
            
        logging.info(f"Załadowano i posortowano {len(self._last_loaded_room_members_details)} członków dla pokoju ID {room_id}.")

    # --- NOWE ZMIANY (Naprawiono brak metody) ---
    def _update_chat_partner_details(self, partner_id_to_update: int):
        """
        Placeholder: W przyszłości może aktualizować szczegóły partnera, 
        jeśli nie są w pełni załadowane. Na razie nie robi nic.
        """
        # logging.debug(f"Chat: _update_chat_partner_details wywołane dla ID: {partner_id_to_update}")
        pass 
    # --- KONIEC NOWYCH ZMIAN ---

    def _refresh_chat_dashboard_if_visible(self):
        """Jeśli wyświetlony jest placeholder panelu głównego, odrysuj listę online."""
        if self.active_chat_partner_id == self.chat_dashboard_placeholder_id:
            self._show_chat_dashboard()

    def _show_or_hide_room_members_panel(self, show: bool):
        """Pokazuje lub ukrywa panel członków pokoju w PanedWindow."""
        if not hasattr(self, 'chat_paned_window') or not self.chat_paned_window.winfo_exists() or \
           not hasattr(self, 'chat_room_members_panel') or not self.chat_room_members_panel.winfo_exists():
            logging.warning("_show_or_hide_room_members_panel: Wymagane widgety (PanedWindow/MembersPanel) nie istnieją.")
            return

        panel_already_visible = self._room_members_panel_visible # lub sprawdź z self.chat_paned_window.panes()
                                                              # Bezpieczniej jest użyć flagi, którą sami ustawiamy

        if show and not panel_already_visible:
            try:
                # Sprawdź, czy pane jest już dodane (na wszelki wypadek, jeśli _room_members_panel_visible jest False, a panel jest)
                # Ta część jest trochę bardziej skomplikowana, jeśli chcemy być super ostrożni.
                # Najprościej jest założyć, że _room_members_panel_visible jest poprawne.
                panes_in_window = self.chat_paned_window.panes()
                is_really_there = False
                for pane_widget_path in panes_in_window:
                    if self.chat_room_members_panel.winfo_pathname(self.chat_room_members_panel.winfo_id()) == pane_widget_path:
                         is_really_there = True; break
                
                if not is_really_there:
                    self.chat_paned_window.add(self.chat_room_members_panel, weight=1) # Ustaw wagę
                    logging.debug("Pokazano panel członków pokoju (dodano do PanedWindow).")
                else:
                    logging.debug("Panel członków pokoju jest już w PanedWindow, nie dodawano ponownie.")
                self._room_members_panel_visible = True
            except tk.TclError as e_add:
                logging.error(f"TclError podczas dodawania panelu członków: {e_add}")
        elif not show and panel_already_visible:
            try:
                self.chat_paned_window.forget(self.chat_room_members_panel)
                logging.debug("Ukryto panel członków pokoju (usunięto z PanedWindow).")
                self._room_members_panel_visible = False
            except tk.TclError as e_forget:
                logging.warning(f"TclError podczas ukrywania panelu członków (może już nie istniał w PanedWindow): {e_forget}")
                self._room_members_panel_visible = False # Na wszelki wypadek zresetuj flagę

    def _show_chat_dashboard(self):
        """Wyświetla zawartość panelu głównego czatu (Dashboard)."""
        self._display_chat_message("", "clear") 
        # --- NOWE ZMIANY: Aktualizacja etykiety i ukrycie panelu członków ---
        if hasattr(self, 'chat_active_partner_label'):
            self.chat_active_partner_label.config(text="Panel Główny Czatu")
        if hasattr(self, 'chat_typing_indicator_label'):
            self.chat_typing_indicator_label.config(text="")
        
        self._show_or_hide_room_members_panel(show=False) # Dashboard nie ma członków do wyświetlenia

        self._rendered_chat_partner_id = self.chat_dashboard_placeholder_id # Ustaw, że dashboard jest renderowany
        # --- KONIEC NOWYCH ZMIAN ---

        self._display_chat_message("--- Panel Główny Czatu ---", "system")
        self._display_chat_message("Witaj w Czat! Wybierz użytkownika lub pokój z listy, aby rozpocząć rozmowę.", "system")
        self._display_chat_message("", "normal") 
        self._display_chat_message("--- Aktywni użytkownicy ---", "system")

        active_users_displayed = False
        if not self.chat_logged_in_user:
            logging.warning("Chat Dashboard: Próba wyświetlenia aktywnych użytkowników bez zalogowanego użytkownika.")
            self._display_chat_message("Zaloguj się, aby zobaczyć aktywnych użytkowników.", "system")
            return

        # --- NOWE ZMIANY ---
        logging.debug(f"Chat Dashboard: Rendering active users. self.online_users: {self.online_users}, self.chat_users keys: {list(self.chat_users.keys())}")
        # --- KONIEC NOWYCH ZMIAN ---

        for user_id in sorted(list(self.online_users)): 
            if user_id == self.chat_logged_in_user['user_id']:
                continue

            user_info = self.chat_users.get(user_id) 
            if user_info: 
                username = user_info.get('username', f"ID_{user_id}")
                self._display_chat_message(f"• {username} (online)", "other_message") 
                active_users_displayed = True
            else:
                logging.warning(f"Chat Dashboard: Brak user_info dla online user_id: {user_id}. Pomijanie.")
        
        if not active_users_displayed:
            self._display_chat_message("Brak innych użytkowników online.", "system")

    def _display_chat_messages_from_history(self, partner_id):
        """
        Wyświetla wiadomości z self.chat_messages dla aktywnego partnera czatu.
        Wywoływana PO pobraniu historii z serwera.
        """
        # Sprawdź, czy użytkownik nadal jest aktywnym partnerem czatu
        if partner_id != self.active_chat_partner_id:
            logging.debug(f"Chat: Partner czatu zmieniony na {self.active_chat_partner_id}, nie wyświetlam historii dla {partner_id}.")
            return # Nie wyświetlaj, jeśli użytkownik w międzyczasie zmienił czat

        self._display_chat_message("", "clear") # Wyczyść okno ponownie

        messages_for_current_chat = self.chat_messages.get(partner_id, [])
        
        if messages_for_current_chat:
            self._display_chat_message(f"--- Początek czatu z {self.chat_users.get(partner_id, {}).get('username')} ---", "system")
            for msg_data in messages_for_current_chat:
                sender_id = msg_data.get('sender_id')
                content = msg_data.get('content')
                timestamp = datetime.datetime.fromisoformat(msg_data.get('timestamp')).strftime('%H:%M')
                
                if sender_id == self.chat_logged_in_user['user_id']:
                    self._display_chat_message(f"[{timestamp}] Ja: {content}", "my_message")
                else:
                    sender_username = self.chat_users.get(sender_id, {}).get('username', f"ID_{sender_id}")
                    self._display_chat_message(f"[{timestamp}] {sender_username}: {content}", "other_message")
            self._display_chat_message(f"--- Koniec czatu z {self.chat_users.get(partner_id, {}).get('username')} ---", "system")
        else:
            self._display_chat_message(f"--- Brak historii czatu z {self.chat_users.get(partner_id, {}).get('username')} ---", "system")


    # --- ZMIANY W _display_chat_message dla obsługi załączników ---
# W klasie GameLauncher

    # --- ZMIANY W _display_chat_message dla obsługi załączników ---
    # --- ZMIANY W _display_chat_message dla obsługi załączników ---
# W klasie GameLauncher

# W klasie GameLauncher

    def _display_chat_message(self, message_text_with_timestamp, msg_type="normal",
                              attachment_data=None, message_id=None,
                              is_read_by_receiver=False,
                              sender_id_for_read_status_check=None,
                              replied_to_message_preview=None, # Istniejący parametr
                              message_data=None): # --- NOWE ZMIANY: Dodaj pełne dane wiadomości ---
        """
        Renderuje jedną wiadomość w oknie czatu z opcjonalnymi załącznikami i cytatem.
        """
        # Utwórz tagi do linków tylko raz
        self._create_chat_message_tags_if_needed()
        # Brak widgetu? wyjdź
        if not hasattr(self, 'chat_message_display') or not self.chat_message_display.winfo_exists():
            return
        self.chat_message_display.config(state=tk.NORMAL)
        # Clear
        if msg_type == "clear":
            self.chat_message_display.delete("1.0", tk.END)
            self._chat_bubble_containers = []
            self.chat_message_display.config(state=tk.DISABLED)
            return

        line_container = None
        bubble_container = None

        if msg_type in ("my_message", "other_message"):
            theme = self.get_all_available_themes().get(self.settings.get('theme','Dark'), THEMES['Dark'])
            bubble_bg = "#004e92" if msg_type == "my_message" else "#2e2e2e"
            text_fg = theme.get('link_foreground','lightblue') if msg_type == "my_message" else theme.get('foreground','lightgreen')
            line_bg = self.chat_message_display.cget('bg')
            line_container = tk.Frame(self.chat_message_display, bg=line_bg)
            bubble_container = tk.Frame(line_container, bg=bubble_bg, padx=8, pady=4,
                                       relief="solid", borderwidth=1)
            # --- NOWE ZMIANY ---
            if message_id is not None:
                self._rendered_message_widgets[message_id] = bubble_container # Zapisz referencję do dymka
                bubble_container._original_bg = bubble_bg # Zapisz oryginalny kolor tła do resetu
                # Dodaj to samo do wewnętrznych ramek i labelek w dymku
                bubble_container._bubble_children_colors = {}
            # --- KONIEC NOWYCH ZMIAN ---

            # Bind right-click on bubble
            bubble_container.bind(
                "<Button-3>",
                lambda e, msg_id=message_id, cont=bubble_container: self._show_chat_message_context_menu(e, msg_id, cont)
            )
            if not hasattr(self, '_chat_bubble_containers'):
                self._chat_bubble_containers = []
            self._chat_bubble_containers.append(bubble_container)
            if message_id is not None:
                bubble_container._chat_message_id = message_id

            content_frame = tk.Frame(bubble_container, bg=bubble_bg)
            content_frame.pack(fill=tk.X, expand=True)
            # --- NOWE ZMIANY ---
            if message_id is not None:
                bubble_container._bubble_children_colors[content_frame] = content_frame.cget('bg')
            # --- KONIEC NOWYCH ZMIAN ---

            # Cytat (replied_to_message_preview)
            if replied_to_message_preview:
                q_bg = theme.get('entry_background','#3a3a3a')
                q_fg = theme.get('foreground','gray')
                q_border = theme.get('tree_heading','#555555')
                quote = tk.Frame(content_frame, bg=q_bg, bd=1, relief="solid",
                                 highlightbackground=q_border, highlightcolor=q_border, highlightthickness=1)
                quote.pack(fill=tk.X, anchor='w', pady=(0,5))
                # --- NOWE ZMIANY ---
                if message_id is not None:
                    bubble_container._bubble_children_colors[quote] = quote.cget('bg')
                # --- KONIEC NOWYCH ZMIAN ---
                q_text = replied_to_message_preview.get('content') or replied_to_message_preview.get('attachment_original_filename','[Załącznik]')
                
                # Użyj tk.Label, aby można było kontrolować kursor i bindowanie
                quote_label = tk.Label(quote,
                          text=f"\"{q_text[:50]}{'...' if len(q_text)>50 else ''}\"",
                          wraplength=300, justify=tk.LEFT,
                          font=("Segoe UI",8,"italic"), background=q_bg, foreground=q_fg,
                          cursor="hand2") # Kursor ręki
                quote_label.pack(fill=tk.X)
                # --- NOWE ZMIANY ---
                if message_id is not None:
                    bubble_container._bubble_children_colors[quote_label] = quote_label.cget('bg')
                
                # Bind kliknięcia do funkcji przeskoku
                quote_label.bind("<Button-1>", 
                                 lambda e, target_msg_id=replied_to_message_preview.get('id'): self._jump_to_message(target_msg_id))
                # --- KONIEC NOWYCH ZMIAN ---

            # Tekst z linkami
            if message_text_with_timestamp:
                seg_frame = tk.Frame(content_frame, bg=bubble_bg)
                seg_frame.pack(fill=tk.X, pady=(0,3))
                # --- NOWE ZMIANY ---
                if message_id is not None:
                    bubble_container._bubble_children_colors[seg_frame] = seg_frame.cget('bg')
                # --- KONIEC NOWYCH ZMIAN ---
                for txt, typ in self._parse_text_for_links(message_text_with_timestamp):
                    if typ == 'link':
                        lbl = tk.Label(seg_frame, text=txt, fg=theme.get('link_foreground','lightblue'),
                                       bg=bubble_bg, cursor='hand2', font=("Segoe UI",9,'underline'))
                        lbl.pack(side=tk.LEFT)
                        # --- NOWE ZMIANY ---
                        if message_id is not None:
                            bubble_container._bubble_children_colors[lbl] = lbl.cget('bg')
                        # --- KONIEC NOWYCH ZMIAN ---
                        lbl.bind("<Button-1>", lambda e, url=txt: webbrowser.open(url if url.startswith('http') else 'http://'+url))
                        lbl.bind(
                            "<Button-3>",
                            lambda e, msg_id=message_id, cont=bubble_container: self._show_chat_message_context_menu(e, msg_id, cont)
                        )
                    else:
                        lbl = tk.Label(seg_frame, text=txt, fg=text_fg, bg=bubble_bg,
                                       font=("Segoe UI",9))
                        lbl.pack(side=tk.LEFT)
                        # --- NOWE ZMIANY ---
                        if message_id is not None:
                            bubble_container._bubble_children_colors[lbl] = lbl.cget('bg')
                        # --- KONIEC NOWYCH ZMIAN ---
                        lbl.bind(
                            "<Button-3>",
                            lambda e, msg_id=message_id, cont=bubble_container: self._show_chat_message_context_menu(e, msg_id, cont)
                        )
            
            # --- NOWE ZMIANY: Dodaj status "edytowano", jeśli data edycji jest dostępna ---
            if message_data and message_data.get('edited_at'):
                edited_indicator_frame = tk.Frame(content_frame, bg=bubble_bg)
                edited_indicator_frame.pack(fill=tk.X, anchor='e', pady=(0,0), padx=(0,0))
                # --- NOWE ZMIANY ---
                if message_id is not None:
                    bubble_container._bubble_children_colors[edited_indicator_frame] = edited_indicator_frame.cget('bg')
                # --- KONIEC NOWYCH ZMIAN ---
                edited_label = ttk.Label(edited_indicator_frame, text="(edytowano)",
                                         font=("Segoe UI", 7, "italic"),
                                         foreground=theme.get('chart_axis_color', 'gray'),
                                         background=bubble_bg)
                edited_label.pack(side=tk.RIGHT, anchor='se', padx=(0,0), pady=(0,0))
                # --- NOWE ZMIANY ---
                if message_id is not None:
                    bubble_container._bubble_children_colors[edited_label] = edited_label.cget('bg')
                # --- KONIEC NOWYCH ZMIAN ---
                edited_label.bind(
                    "<Button-3>",
                    lambda e, msg_id=message_id, cont=bubble_container: self._show_chat_message_context_menu(e, msg_id, cont)
                )
            # --- KONIEC NOWYCH ZMIAN ---



        # Załączniki
        if attachment_data and bubble_container:
            fn = attachment_data.get('server_filename')
            orig = attachment_data.get('original_filename','plik')
            mimetype = attachment_data.get('attachment_mimetype','application/octet-stream')
            attach_bg = bubble_container.cget('bg')
            theme = self.get_all_available_themes().get(self.settings.get('theme','Dark'), THEMES['Dark'])
            link_color = theme.get('link_foreground','lightblue')

            attach_frame = tk.Frame(bubble_container, bg=attach_bg)
            attach_frame.pack(fill=tk.X, anchor='w', pady=(3,0))
            # --- NOWE ZMIANY ---
            if message_id is not None:
                bubble_container._bubble_children_colors[attach_frame] = attach_frame.cget('bg')
            # --- KONIEC NOWYCH ZMIAN ---
            # Bind right-click on attachment
            attach_frame.bind(
                "<Button-3>",
                lambda e, msg_id=message_id, cont=bubble_container: self._show_chat_message_context_menu(e, msg_id, cont)
            )

            if mimetype.startswith('image/'):
                preview = tk.Label(attach_frame, text='Ładowanie podglądu...', bg=attach_bg)
                preview.pack(anchor='w', padx=5, pady=(5,0))
                # --- NOWE ZMIANY ---
                if message_id is not None:
                    bubble_container._bubble_children_colors[preview] = preview.cget('bg')
                # --- KONIEC NOWYCH ZMIAN ---
                threading.Thread(
                    target=self._load_and_display_chat_image_thumbnail,
                    args=(f"{self.chat_server_url}/download_file/{fn}", preview, f"chat_img_{message_id}"),
                    daemon=True
                ).start()
                # link do oryginału
                link = tk.Label(attach_frame, text=f"Pobierz oryginał: {orig}",
                                fg=link_color, bg=attach_bg, cursor='hand2', font=("Segoe UI",8,'underline'))
                link.pack(anchor='w', padx=5, pady=(2,0))
                # --- NOWE ZMIANY ---
                if message_id is not None:
                    bubble_container._bubble_children_colors[link] = link.cget('bg')
                # --- KONIEC NOWYCH ZMIAN ---
                link.bind("<Button-1>", lambda e, url=f"{self.chat_server_url}/download_file/{fn}": webbrowser.open(url))
                link.bind(
                    "<Button-3>",
                    lambda e, msg_id=message_id, cont=bubble_container: self._show_chat_message_context_menu(e, msg_id, cont)
                )
            else:
                info = tk.Frame(attach_frame, bg=attach_bg)
                info.pack(fill=tk.X)
                # --- NOWE ZMIANY ---
                if message_id is not None:
                    bubble_container._bubble_children_colors[info] = info.cget('bg')
                # --- KONIEC NOWYCH ZMIAN ---
                icon = tk.Label(info, text='📄', bg=attach_bg)
                icon.pack(side=tk.LEFT, padx=(0,5))
                # --- NOWE ZMIANY ---
                if message_id is not None:
                    bubble_container._bubble_children_colors[icon] = icon.cget('bg')
                # --- KONIEC NOWYCH ZMIAN ---
                link = tk.Label(info, text=orig, fg=link_color, bg=attach_bg, cursor='hand2', font=("Segoe UI",9,'underline'))
                link.pack(side=tk.LEFT)
                # --- NOWE ZMIANY ---
                if message_id is not None:
                    bubble_container._bubble_children_colors[link] = link.cget('bg')
                # --- KONIEC NOWYCH ZMIAN ---
                link.bind("<Button-1>", lambda e, url=f"{self.chat_server_url}/download_file/{fn}": webbrowser.open(url))
                link.bind(
                    "<Button-3>",
                    lambda e, msg_id=message_id, cont=bubble_container: self._show_chat_message_context_menu(e, msg_id, cont)
                )

        # Wstawianie dymka lub tekstu
        if line_container and bubble_container:
            pos = tk.LEFT if msg_type=='my_message' else tk.RIGHT
            bubble_container.pack(side=pos, padx=5, pady=2)
            self.chat_message_display.insert(tk.END, '\n')
            # --- NOWE ZMIANY ---
            if message_id is not None: # Zapisz referencję również do line_container
                line_container._chat_message_id = message_id
                self._rendered_message_widgets[message_id] = line_container # Użyj line_container jako głównej referencji do okna
                line_container._original_bg = line_bg # Zapisz oryginalne tło
                line_container._bubble_children_colors = bubble_container._bubble_children_colors # Przekaż info o kolorach dzieci
            # --- KONIEC NOWYCH ZMIAN ---
            self.chat_message_display.window_create(tk.END, window=line_container)
            self.chat_message_display.insert(tk.END, '\n\n')
        elif msg_type == 'system':
            self.chat_message_display.insert(tk.END, f"{message_text_with_timestamp}\n", 'system_tag')
        elif msg_type == 'error':
            self.chat_message_display.insert(tk.END, f"[BŁĄD] {message_text_with_timestamp}\n", 'error_tag')
        else:
            self.chat_message_display.insert(tk.END, f"{message_text_with_timestamp}\n")

        # Wskaźnik przeczytania
        if msg_type=='my_message' and is_read_by_receiver and bubble_container:
            rd = tk.Label(bubble_container, text='👁️', bg=bubble_bg, fg=text_fg)
            rd.pack(side=tk.RIGHT, anchor='se', padx=(0,1), pady=(1,0))
            # --- NOWE ZMIANY ---
            if message_id is not None:
                bubble_container._bubble_children_colors[rd] = rd.cget('bg')
            # --- KONIEC NOWYCH ZMIAN ---

        self.chat_message_display.config(state=tk.DISABLED)


    def _on_message_read_update(self, data): # Upewnij się, że nazwa jest poprawna i bindowana
        """
        Odebrano informację od serwera, że wiadomość (którą my wysłaliśmy)
        została przeczytana przez odbiorcę.
        Data: {'message_id': ..., 'read_by_user_id': ..., 'is_read': True}
        """
        message_id_that_was_read = data.get('message_id')
        is_read_status = data.get('is_read', False)
        # read_by_user_id to ID partnera, który przeczytał naszą wiadomość
        partner_who_read_id = data.get('read_by_user_id') 
        
        logging.debug(f"Chat: Odebrano 'message_read_update' dla wiadomości ID {message_id_that_was_read}, is_read={is_read_status} by user {partner_who_read_id}")

        if message_id_that_was_read and is_read_status:
            message_updated_locally = False
            # Iteruj po WSZYSTKICH parach w self.chat_messages, bo nie wiemy, do której rozmowy należy ta wiadomość,
            # dopóki nie znajdziemy message_id. Partnerem dla tej wiadomości będzie `partner_who_read_id`.
            for partner_key_in_history, messages_list_local in self.chat_messages.items():
                # Sprawdź, czy ta lista wiadomości jest z partnerem, który właśnie przeczytał wiadomość
                if partner_key_in_history == partner_who_read_id: # partner_key_in_history to ID partnera (odbiorcy tej wiadomości)
                    for i, msg_data_item in enumerate(messages_list_local):
                        if msg_data_item.get('id') == message_id_that_was_read:
                            # Sprawdź, czy to my byliśmy nadawcą tej wiadomości
                            if msg_data_item.get('sender_id') == self.chat_logged_in_user['user_id']:
                                if not msg_data_item.get('is_read_by_receiver', False): # Tylko jeśli jeszcze nie był oznaczony
                                    self.chat_messages[partner_key_in_history][i]['is_read_by_receiver'] = True
                                    message_updated_locally = True
                                    logging.info(f"Chat: Lokalnie zaktualizowano status 'przeczytane' dla wiadomości ID {message_id_that_was_read}.")
                                break 
                    if message_updated_locally:
                        break
            
            # Jeśli zaktualizowano stan lokalny i dotyczy to aktywnego czatu, odśwież widok
            if message_updated_locally and self.active_chat_partner_id == partner_who_read_id:
                logging.debug(f"Chat: Odświeżanie aktywnego czatu z {self.active_chat_partner_id} po aktualizacji statusu przeczytania.")
                # Flaga _force_history_reload_for_partner może nie być tutaj konieczna,
                # ponieważ _display_active_chat_history samo w sobie czyta z zaktualizowanego self.chat_messages
                self._display_active_chat_history(self.active_chat_partner_id)

    # --- NOWE ZMIANY (CHAT - Usuwanie wiadomości) ---
    def _show_chat_message_context_menu(self, event, message_id, message_bubble_container):
        """
        Wyświetla menu kontekstowe dla klikniętej wiadomości czatu.
        `message_bubble_container` to widget tk.Frame reprezentujący dymek.
        """
        if message_id is None:
            return

        context_menu = tk.Menu(self.chat_page_frame, tearoff=0, background="#2e2e2e", foreground="white")

        # Pobierz dane wiadomości, aby sprawdzić, czy to nasza wiadomość
        message_data = None
        current_user_id = self.chat_logged_in_user['user_id']
        for partner_id, messages_list in self.chat_messages.items():
            for msg in messages_list:
                if msg.get('id') == message_id:
                    message_data = msg
                    break
            if message_data: break

        if not message_data:
            logging.warning(f"Błąd: Nie znaleziono danych dla wiadomości ID {message_id} w menu kontekstowym.")
            return

        # Opcja "Edytuj wiadomość" (tylko dla naszych wiadomości)
        if message_data.get('sender_id') == current_user_id:
            context_menu.add_command(
                label="Edytuj wiadomość",
                command=lambda msg_data_to_edit=message_data: self._edit_chat_message_dialog(msg_data_to_edit)
            )
        # --- NOWE ZMIANY (CHAT KLIENT - Odpowiadanie): Dodanie opcji Odpowiedz ---
        context_menu.add_command(
            label="Odpowiedz",
            command=lambda msg_data_to_reply=message_data: self._set_reply_mode(msg_data_to_reply)
        )
        context_menu.add_separator() # Separator po opcjach edycji/usuwania/odpowiadania
        # --- KONIEC NOWYCH ZMIAN ---

        context_menu.add_command(
            label="Usuń wiadomość",
            command=lambda msg_id_to_del=message_id: self._confirm_and_delete_chat_message(msg_id_to_del)
        )
        context_menu.add_separator()
        context_menu.add_command(label="Kopiuj tekst", command=lambda content=message_data.get('content', ''): self.root.clipboard_clear() or self.root.clipboard_append(content))

        context_menu.post(event.x_root, event.y_root)

    # --- NOWE ZMIANY (CHAT KLIENT - Edycja wiadomości) ---
    def _edit_chat_message_dialog(self, message_data_to_edit: dict):
        """
        Otwiera okno dialogowe do edycji treści wiadomości.
        """
        message_id = message_data_to_edit.get('id')
        original_content = message_data_to_edit.get('content', '')
        sender_username = message_data_to_edit.get('sender_username', 'Ty')
        
        edit_dialog = tk.Toplevel(self.chat_page_frame)
        edit_dialog.title(f"Edytuj Wiadomość (ID: {message_id})")
        edit_dialog.configure(bg="#1e1e1e")
        edit_dialog.grab_set()
        edit_dialog.transient(self.chat_page_frame) # Okno dialogowe zależne od strony czatu
        
        # Centrowanie okna edycji
        self.root.update_idletasks() # Wymuś aktualizację wymiarów
        parent_x = self.chat_page_frame.winfo_rootx()
        parent_y = self.chat_page_frame.winfo_rooty()
        parent_w = self.chat_page_frame.winfo_width()
        parent_h = self.chat_page_frame.winfo_height()
        
        dialog_w = 400
        dialog_h = 200
        pos_x = parent_x + (parent_w // 2) - (dialog_w // 2)
        pos_y = parent_y + (parent_h // 2) - (dialog_h // 2)
        edit_dialog.geometry(f"{dialog_w}x{dialog_h}+{pos_x}+{pos_y}")
        edit_dialog.resizable(False, False)

        ttk.Label(edit_dialog, text=f"Edytujesz wiadomość od {sender_username}:", font=("Segoe UI", 9, "bold")).pack(pady=(10,5))

        # Pole tekstowe do edycji
        edit_text_frame = ttk.Frame(edit_dialog)
        edit_text_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        edit_text_frame.columnconfigure(0, weight=1)
        edit_text_frame.rowconfigure(0, weight=1)

        edit_text_widget = tk.Text(edit_text_frame, height=5, wrap=tk.WORD, relief=tk.FLAT)
        edit_text_widget.insert("1.0", original_content)
        edit_text_widget.grid(row=0, column=0, sticky="nsew")
        edit_text_widget.config(background=ttk.Style().lookup('TEntry', 'fieldbackground'), foreground=ttk.Style().lookup('TEntry', 'foreground'))
        
        edit_text_scroll = ttk.Scrollbar(edit_text_frame, orient="vertical", command=edit_text_widget.yview)
        edit_text_scroll.grid(row=0, column=1, sticky="ns")
        edit_text_widget.config(yscrollcommand=edit_text_scroll.set)
        
        edit_text_widget.focus_set() # Ustaw fokus na polu edycji
        edit_text_widget.mark_set(tk.INSERT, "1.0") # Ustaw kursor na początku
        edit_text_widget.see(tk.INSERT) # Upewnij się, że kursor jest widoczny

        def save_edited_message():
            new_content = edit_text_widget.get("1.0", tk.END).strip()
            if not new_content:
                messagebox.showwarning("Błąd", "Treść wiadomości nie może być pusta.", parent=edit_dialog)
                return

            if self.sio and self.sio.connected and self.chat_logged_in_user:
                logging.info(f"Chat: Wysyłanie żądania edycji wiadomości ID {message_id} z nową treścią: '{new_content[:50]}...'")
                self.sio.emit('edit_message', {
                    'message_id': message_id,
                    'new_content': new_content,
                    'editor_user_id': self.chat_logged_in_user['user_id']
                })
                edit_dialog.destroy()
            else:
                messagebox.showerror("Błąd Połączenia", "Brak połączenia z serwerem czatu. Nie można edytować wiadomości.", parent=edit_dialog)

        button_frame = ttk.Frame(edit_dialog)
        button_frame.pack(pady=10)
        ttk.Button(button_frame, text="Zapisz Edycję", command=save_edited_message).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Anuluj", command=edit_dialog.destroy).pack(side=tk.LEFT, padx=5)
    # --- KONIEC NOWYCH ZMIAN (CHAT KLIENT - Edycja wiadomości) ---

    def _confirm_and_delete_chat_message(self, message_id_to_delete):
        """Pyta o potwierdzenie i wysyła żądanie usunięcia wiadomości."""
        if message_id_to_delete is None:
            return

        # Tutaj można dodać logikę pobierania treści wiadomości po ID dla lepszego potwierdzenia,
        # ale na razie proste potwierdzenie.
        if messagebox.askyesno(
            "Potwierdź Usunięcie", 
            "Czy na pewno chcesz usunąć tę wiadomość?\nTej operacji nie można cofnąć.",
            parent=self.chat_page_frame, # Ustaw rodzica dla okna dialogowego
            icon='warning'
        ):
            if self.sio and self.sio.connected and self.chat_logged_in_user:
                logging.info(f"Chat: Wysyłanie żądania usunięcia wiadomości o ID: {message_id_to_delete}")
                self.sio.emit('delete_message', {
                    'message_id': message_id_to_delete,
                    'deleter_user_id': self.chat_logged_in_user['user_id'] # Przesyłamy ID usuwającego dla weryfikacji na serwerze
                })
            else:
                messagebox.showerror("Błąd Połączenia", "Nie można usunąć wiadomości. Brak połączenia z serwerem lub nie jesteś zalogowany.", parent=self.chat_page_frame)

    # Metoda do obsługi potwierdzenia usunięcia wiadomości z serwera
    # Będzie bindowana do eventu SocketIO
    def _on_message_deleted_event(self, data):
        """
        Wywoływana, gdy serwer potwierdzi usunięcie wiadomości lub zgłosi błąd.
        Data powinna zawierać: {'success': True/False, 'message_id': ID_usuniętej, 
                                'room_id': (opcjonalnie, ID pokoju), 'error': (opcjonalnie)}
        """
        message_id_deleted = data.get('message_id')
        success = data.get('success', False)
        error_msg_server = data.get('error')
        # --- NOWE ZMIANY (CHAT KLIENT - Poprawka usuwania wiadomości grupowych) ---
        deleted_in_room_id = data.get('room_id') # ID pokoju, jeśli to wiadomość grupowa
        # --- KONIEC NOWYCH ZMIAN ---

        if success:
            logging.info(f"Chat: Serwer potwierdził usunięcie wiadomości ID: {message_id_deleted} (Pokój: {deleted_in_room_id if deleted_in_room_id else 'N/A'})")
            
            # --- NOWE ZMIANY (CHAT KLIENT - Poprawka usuwania wiadomości grupowych) ---
            # Określ, której historii czatu dotyczy usunięcie
            target_history_key = None
            if deleted_in_room_id: # Jeśli wiadomość była z pokoju
                target_history_key = deleted_in_room_id
            elif self.active_chat_type == "user" and self.active_chat_partner_id: # Jeśli to czat prywatny, użyj active_chat_partner_id
                target_history_key = self.active_chat_partner_id
            # W przypadku wiadomości prywatnej usuniętej przez partnera, musimy znaleźć, kto był partnerem tej wiadomości.
            # To jest bardziej skomplikowane, jeśli nie jesteśmy w aktywnym czacie.
            # Na razie zakładamy, że `message_deleted_successfully` przyjdzie tylko do aktywnego czatu PRYWATNEGO
            # lub do WSZYSTKICH w pokoju grupowym.

            if target_history_key is not None and target_history_key in self.chat_messages:
                self.chat_messages[target_history_key] = [
                    msg for msg in self.chat_messages[target_history_key] if msg.get('id') != message_id_deleted
                ]
                logging.debug(f"Usunięto wiadomość ID {message_id_deleted} z lokalnej historii dla klucza {target_history_key}.")

                # Odśwież widok, jeśli dotyczy to AKTYWNIE otwartego czatu (prywatnego LUB grupowego)
                if self.active_chat_partner_id == target_history_key and \
                   ((self.active_chat_type == "room" and deleted_in_room_id == target_history_key) or \
                    (self.active_chat_type == "user" and not deleted_in_room_id)): # Sprawdź, czy typ się zgadza
                    logging.info(f"Odświeżanie aktywnego czatu ({self.active_chat_type} ID: {target_history_key}) po usunięciu wiadomości.")
                    self._display_active_chat_history(self.active_chat_partner_id)
                else:
                    logging.debug(f"Usunięta wiadomość ID {message_id_deleted} nie dotyczy aktywnie otwartego czatu. Aktywny: {self.active_chat_type} {self.active_chat_partner_id}, Wiadomość z pokoju: {deleted_in_room_id}")

            else:
                logging.warning(f"Nie można zlokalizować historii czatu dla usuniętej wiadomości (target_key: {target_history_key}).")
            # --- KONIEC NOWYCH ZMIAN ---

        else:
            logging.error(f"Chat: Serwer odmówił usunięcia wiadomości ID: {message_id_deleted}. Powód: {error_msg_server}")
            # --- ZMIANA: Użyj self.chat_page_frame jako rodzica (jeśli istnieje) ---
            parent_for_msgbox = self.chat_page_frame if hasattr(self, 'chat_page_frame') and self.chat_page_frame.winfo_exists() else self.root
            messagebox.showerror("Błąd Usuwania", f"Nie udało się usunąć wiadomości:\n{error_msg_server or 'Nieznany błąd serwera.'}", parent=parent_for_msgbox)
            # --- KONIEC ZMIANY ---

    def _go_to_server_selection_from_chat_auth(self):
        """Przechodzi do strony wyboru serwera z panelu logowania czatu."""
        # Tutaj nie ma potrzeby rozłączania, bo i tak nie jesteśmy połączeni
        self.show_server_selection_page()

    def _go_to_server_selection_from_chat_main(self):
        """Przechodzi do strony wyboru serwera z głównego panelu czatu, rozłączając obecne połączenie."""
        if self.sio and self.sio.connected:
            self._chat_logout() # Rozłącz i zresetuj stan czatu
            # Daj chwilę na przetworzenie rozłączenia przed przejściem
            self.root.after(150, self.show_server_selection_page)
        else:
            self.show_server_selection_page()

    def _apply_chat_message_tags_and_alignment(self):
        """Stosuje tagi wyrównania do dymków wiadomości w oknie czatu.
           Powinno być wywoływane po wstawieniu wszystkich wiadomości
           lub przy zmianie rozmiaru okna, jeśli wyrównanie od tego zależy.
        """
        if not hasattr(self, 'chat_message_display') or not self.chat_message_display.winfo_exists():
            return
        
        # Marginesy dla dymków (symulacja wyrównania)
        display_width_px = self.chat_message_display.winfo_width()
        bubble_margin = int(display_width_px * 0.30) # Np. dymek zajmuje 70% szerokości

        self.chat_message_display.tag_config("my_message_bubble_align_tag", 
                                             justify='right', 
                                             lmargin1=bubble_margin, rmargin1=10) # Moje - duży lewy margines
        self.chat_message_display.tag_config("other_message_bubble_align_tag", 
                                             justify='left', 
                                             lmargin1=10, rmargin1=bubble_margin) # Innych - duży prawy margines
        
        # Styl dla linków w dymkach (jeśli używamy ttk.Button jako linków)
        # To jest bardziej skomplikowane, bo ttk.Button w tk.Text jest Window, a nie tekstem.
        # Łatwiej stylizować przez dedykowane style dla ChatLink.<msg_type>.TButton

# W klasie GameLauncher

    # ... (istniejący kod) ...

    def _load_and_display_chat_image_thumbnail(self, image_url, target_label_widget, message_id_for_cache=None):
        """
        Pobiera obraz z URL i wyświetla go jako miniaturkę w podanym ttk.Label.
        Działa w tle. Używa cache'u.
        """
        log_prefix = f"ChatImgLoad (ID: {message_id_for_cache}, URL: {image_url}): "
        logging.debug(f"{log_prefix}Rozpoczęto próbę załadowania miniaturki.")

        if not target_label_widget.winfo_exists():
            logging.warning(f"{log_prefix}Label docelowy już nie istnieje. Przerywanie.")
            return

        if not hasattr(self, '_chat_image_thumbnail_cache'):
            self._chat_image_thumbnail_cache = {}
        
        thumbnail_max_width = 200 
        thumbnail_max_height = 150 
        cache_key = f"{image_url}_{thumbnail_max_width}x{thumbnail_max_height}"

        if cache_key in self._chat_image_thumbnail_cache:
            cached_photo = self._chat_image_thumbnail_cache[cache_key]
            if cached_photo:
                logging.debug(f"{log_prefix}Miniaturka znaleziona w cache. Aktualizowanie UI.")
                self.root.after(0, lambda: self._update_image_label(target_label_widget, cached_photo, image_url, log_prefix))
                return
            else:
                logging.debug(f"{log_prefix}Miniaturka była w cache jako None (poprzedni błąd). Próba ponownego załadowania.")
        
        # Ustawienie tekstu "Ładowanie..." przed próbą pobrania
        self.root.after(0, lambda: target_label_widget.config(text="[Ładowanie podglądu...]"))

        try:
            logging.debug(f"{log_prefix}Pobieranie danych obrazu z serwera...")
            response = requests.get(image_url, stream=True, timeout=20)
            response.raise_for_status()
            logging.debug(f"{log_prefix}Odpowiedź serwera: {response.status_code}")

            image_data_bytes = response.content # Pobierz całą zawartość od razu
            logging.debug(f"{log_prefix}Pobrano {len(image_data_bytes)} bajtów danych obrazu.")
            
            if not image_data_bytes:
                logging.error(f"{log_prefix}Pobrane dane obrazu są puste.")
                raise ValueError("Puste dane obrazu")

            image_data_io = BytesIO(image_data_bytes)
            
            logging.debug(f"{log_prefix}Próba otwarcia obrazu z BytesIO za pomocą Pillow...")
            with Image.open(image_data_io) as img:
                logging.debug(f"{log_prefix}Obraz otwarty. Format: {img.format}, Rozmiar: {img.size}, Tryb: {img.mode}")
                img.thumbnail((thumbnail_max_width, thumbnail_max_height), Image.Resampling.LANCZOS)
                logging.debug(f"{log_prefix}Miniaturka utworzona. Nowy rozmiar: {img.size}")
                photo_image = ImageTk.PhotoImage(img)
                logging.debug(f"{log_prefix}ImageTk.PhotoImage utworzony.")
                
            self._chat_image_thumbnail_cache[cache_key] = photo_image 
            self.root.after(0, lambda: self._update_image_label(target_label_widget, photo_image, image_url, log_prefix))
            logging.info(f"{log_prefix}Miniaturka pomyślnie załadowana i zaplanowano aktualizację UI.")

        except requests.exceptions.RequestException as e:
            logging.error(f"{log_prefix}Błąd sieciowy: {e}")
            self._chat_image_thumbnail_cache[cache_key] = None
            self.root.after(0, lambda: target_label_widget.config(text="[Błąd sieci]"))
        except UnidentifiedImageError:
            logging.error(f"{log_prefix}Nie można zidentyfikować obrazka (nieprawidłowy format?)")
            self._chat_image_thumbnail_cache[cache_key] = None
            self.root.after(0, lambda: target_label_widget.config(text="[Zły format obrazka]"))
        except ValueError as ve: # Dla pustych danych obrazu
            logging.error(f"{log_prefix}Błąd wartości (np. puste dane): {ve}")
            self._chat_image_thumbnail_cache[cache_key] = None
            self.root.after(0, lambda: target_label_widget.config(text="[Błąd danych obrazka]"))
        except Exception as e:
            logging.exception(f"{log_prefix}Nieoczekiwany błąd")
            self._chat_image_thumbnail_cache[cache_key] = None
            self.root.after(0, lambda: target_label_widget.config(text="[Błąd ładowania]"))
            
    def _update_image_label(self, label_widget, photo_image, original_url, log_prefix_outer=""):
        """Aktualizuje etykietę obrazkiem (wywoływane przez root.after)."""
        log_prefix = f"{log_prefix_outer}UpdateImgLabel: "
        if label_widget.winfo_exists():
            logging.debug(f"{log_prefix}Aktualizowanie widgetu Label obrazkiem.")
            label_widget.config(image=photo_image, text="")
            label_widget.image = photo_image 
            label_widget.unbind("<Button-1>") 
            label_widget.bind("<Button-1>", lambda e, url=original_url: webbrowser.open(url))
            ToolTip(label_widget, "Kliknij, aby otworzyć pełny obraz")
            logging.debug(f"{log_prefix}Widget Label zaktualizowany.")
        else:
            logging.warning(f"{log_prefix}Widget Label już nie istnieje. Pominięto aktualizację.")


    # --- NOWE ZMIANY (CHAT) ---
    # PRZENIESIONA I ZMIENIONA NAZWA METODY
    # Modyfikacja metody _display_active_chat_history
    # --- ZMODYFIKOWANA METODA _display_active_chat_history ---
    def _display_active_chat_history(self, partner_id):
        """
        Wyczyść okno i wyrenderuj pełną historię czatu z partnerem.
        Potwierdzenia „przeczytane” wyślemy tylko przy pierwszym wywołaniu
        (czyli gdy użytkownik faktycznie otworzy czat).
        """
        # --- NOWE ZMIANY ---
        self._rendered_message_widgets.clear() # Wyczyść mapowanie widgetów przed każdym pełnym renderowaniem
        # --- KONIEC NOWYCH ZMIAN ---
        # --- obsługa None lub Dashboard ---
        if partner_id is None:
            self._display_chat_message("", "clear")
            self._display_chat_message("Wybierz partnera czatu lub panel główny.", "system")
            self.chat_active_partner_label.config(text="Panel Czatu")
            if hasattr(self, 'chat_typing_indicator_label'):
                self.chat_typing_indicator_label.config(text="")
            self._rendered_chat_partner_id = None
            return

        if partner_id == self.chat_dashboard_placeholder_id:
            self.chat_active_partner_label.config(text="Panel Główny Czatu")
            if hasattr(self, 'chat_typing_indicator_label'):
                self.chat_typing_indicator_label.config(text="")
            self._show_chat_dashboard()
            self._rendered_chat_partner_id = partner_id

            if hasattr(self, 'chat_message_search_var'):
                self.chat_message_search_var.set("")
            return

        # --- Czyścimy i przygotowujemy dane ---
        first_display = (self._rendered_chat_partner_id != partner_id)
        self._display_chat_message("", "clear")
        self._last_chat_date_displayed_for_active = {}

        all_msgs = self.chat_messages.get(partner_id, [])
        # filtr na podstawie wyszukiwarki
        search_term = getattr(self, 'chat_message_search_var', tk.StringVar()).get().lower().strip()
        if search_term:
            to_show = [
                m for m in all_msgs
                if search_term in (m.get('content') or "").lower()
                or search_term in (m.get('attachment_original_filename') or "").lower()
            ]
        else:
            to_show = all_msgs

        partner_uname = self.chat_users.get(partner_id, {}).get('username', f"ID_{partner_id}")
        if not to_show:
            if search_term:
                self._display_chat_message(
                    f"--- Brak wiadomości pasujących do '{search_term}' w czacie z {partner_uname} ---",
                    "system")
            else:
                self._display_chat_message(
                    f"--- Brak historii czatu z {partner_uname} ---",
                    "system")
            self._rendered_chat_partner_id = partner_id
            return

        # sortujemy
        sorted_msgs = sorted(to_show,
                            key=lambda m: datetime.datetime.fromisoformat(m['timestamp']))

        # znajdujemy ostatnią swoją wiadomość, którą odbiorca przeczytał
        my_id = self.chat_logged_in_user['user_id']
        last_read_id = None
        for m in sorted_msgs:
            if m.get('sender_id') == my_id and m.get('is_read_by_receiver'):
                last_read_id = m['id']

        # nagłówek
        if not search_term:
            self._display_chat_message(f"--- Początek czatu z {partner_uname} ---", "system")
        else:
            self._display_chat_message(
                f"--- Wyniki wyszukiwania '{search_term}' w czacie z {partner_uname} ---",
                "system")

        # zbieramy ID wiadomości, które trzeba oznaczyć jako przeczytane
        message_ids_to_mark = []

        # pętla wyświetlająca każdą wiadomość
        for m in sorted_msgs:
            dt = datetime.datetime.fromisoformat(m['timestamp'])
            # wrzuc datówkę
            if self._last_chat_date_displayed_for_active.get(partner_id) != dt.date():
                self._display_chat_message("", "normal")
                self._display_chat_message(self._format_chat_date(dt.date()), "system")
                self._display_chat_message("", "normal")
                self._last_chat_date_displayed_for_active[partner_id] = dt.date()

            sid = m['sender_id']
            ts = dt.strftime('%H:%M')
            # tekst i typ
            # Ważne: Jeśli `m['sender_id']` jest NULL (bo konto usunięto), to `self.chat_users.get(sid)` zwróci None.
            # Upewnij się, że wyświetlanie nadawcy jest bezpieczne.
            sender_obj = self.chat_users.get(sid)
            sender_name = sender_obj.get('username') if sender_obj else "Usunięty Użytkownik" # Nowy bezpieczny tekst
            
            # --- NOWE ZMIANY ---
            if sid == self.chat_logged_in_user['user_id']:
                text = f"[{ts}] Ja: {m.get('content','')}"
                msg_type = "my_message"
            else:
                # Jeśli to wiadomość grupowa, wyświetl imię nadawcy
                if self.active_chat_type == "room":
                    text = f"[{ts}] {sender_name}: {m.get('content','')}"
                else: # Prywatna wiadomość (już działało)
                    text = f"[{ts}] {sender_name}: {m.get('content','')}"
                msg_type = "other_message"
            # --- KONIEC NOWYCH ZMIAN ---

            # załącznik
            attach = None
            if m.get('attachment_server_filename'):
                attach = {
                    'server_filename': m['attachment_server_filename'],
                    'original_filename': m.get('attachment_original_filename'),
                    'attachment_mimetype': m.get('attachment_mimetype')
                }

            # 4) Display the bubble
            self._display_chat_message(
                text,
                msg_type,
                attachment_data=attach,
                message_id=m['id'],
                is_read_by_receiver=(msg_type=="my_message" and m['id']==last_read_id),
                sender_id_for_read_status_check=sid,
                replied_to_message_preview=m.get('replied_to_message_preview'),
                # --- NOWE ZMIANY ---
                message_data=m # Przekazujemy pełne dane wiadomości
                # --- KONIEC NOWYCH ZMIAN ---
            )

        # stopka
        if not search_term:
            self._display_chat_message(f"--- Koniec czatu z {partner_uname} ---", "system")

        # --- ZMIANA: Wywołaj _check_and_mark_read po wyświetleniu historii ---
        if first_display:
             self.root.after(100, self._check_and_mark_read)
        # --- KONIEC ZMIANY ---

        # --- NOWE ZMIANY ---
        # Przewiń na dół TYLKO jeśli nie mamy celu do przeskoczenia
        if self._jump_target_message_id is None:
            if hasattr(self, 'chat_message_display') and self.chat_message_display.winfo_exists():
                self.chat_message_display.see(tk.END)
        # --- KONIEC NOWYCH ZMIAN ---

        self._rendered_chat_partner_id = partner_id
        if hasattr(self, '_update_typing_indicator'):
            self._update_typing_indicator()

        # --- NOWE ZMIANY ---
        # Po zakończeniu renderowania, przewiń do wiadomości docelowej, jeśli istnieje flaga
        if self._jump_target_message_id is not None:
            target_widget_to_jump_to = self._rendered_message_widgets.get(self._jump_target_message_id)
            if target_widget_to_jump_to and target_widget_to_jump_to.winfo_exists():
                # Przewiń do wiadomości
                self.chat_message_display.see(self.chat_message_display.index(target_widget_to_jump_to))
                # Podświetl na chwilę
                self._highlight_message_widget(target_widget_to_jump_to)
            self._jump_target_message_id = None # Skasuj flagę po użyciu
        # --- KONIEC NOWYCH ZMIAN ---

    def _update_send_button_state(self):
        """
        Aktualizuje stan pól wprowadzania i przycisku wysyłania
        w zależności od statusu połączenia i wybranego partnera.
        """
        send_possible = (self.chat_logged_in_user and
                         self.chat_connected_to_server and
                         self.chat_authenticated and
                         (self.active_chat_type == "user" or self.active_chat_type == "room") # Enable if user OR room is active
                        )


    def _jump_to_message(self, target_message_id: int):
        """
        Przewija widok czatu do wiadomości o podanym ID i ją podświetla.
        Jeśli wiadomość nie jest aktualnie renderowana, przeładuje historię.
        """
        if not target_message_id:
            logging.warning("Jump: Otrzymano puste ID wiadomości do przeskoku.")
            return

        # Spróbuj znaleźć widget wiadomości, jeśli jest już w pamięci i na ekranie
        target_widget = self._rendered_message_widgets.get(target_message_id)

        if target_widget and target_widget.winfo_exists():
            logging.info(f"Jump: Znaleziono wiadomość ID {target_message_id} już wyrenderowaną. Przewijanie...")
            # `self.chat_message_display.index(widget)` zwraca indeks tekstu, gdzie widget został wstawiony.
            self.chat_message_display.see(self.chat_message_display.index(target_widget))
            self._highlight_message_widget(target_widget)
        else:
            logging.info(f"Jump: Wiadomość ID {target_message_id} nie jest wyrenderowana. Przeładowywanie historii i przewijanie...")
            # Ustaw flagę, aby po przeładowaniu historii przewinąć do tej wiadomości
            self._jump_target_message_id = target_message_id 
            # Wymuś ponowne załadowanie i wyświetlenie historii dla aktywnego partnera
            # To spowoduje, że _display_active_chat_history zostanie ponownie wywołane i zobaczy _jump_target_message_id
            self._load_and_display_chat_history(self.active_chat_partner_id)


    def _highlight_message_widget(self, widget_to_highlight):
        """
        Tymczasowo podświetla tło dymka wiadomości i jego wewnętrznych elementów.
        """
        if not widget_to_highlight or not widget_to_highlight.winfo_exists():
            return

        original_bg_main = getattr(widget_to_highlight, '_original_bg', None)
        if not original_bg_main: # Jeśli nie ma zapisanego oryginalnego tła, użyj obecnego
            original_bg_main = widget_to_highlight.cget('bg')
            widget_to_highlight._original_bg = original_bg_main # Zapisz na przyszłość
        
        # Zmień tło głównego dymka
        widget_to_highlight.config(bg=self.MESSAGE_HIGHLIGHT_COLOR)

        # Zmień tło wewnętrznych dzieci dymka, które mają zapamiętane oryginalne kolory
        children_colors = getattr(widget_to_highlight, '_bubble_children_colors', {})
        for child_widget, original_child_bg in children_colors.items():
            if child_widget.winfo_exists():
                try: # Nie wszystkie widgety mogą mieć 'background'
                    child_widget.config(bg=self.MESSAGE_HIGHLIGHT_COLOR)
                except tk.TclError:
                    pass # Ignoruj, jeśli widget nie obsługuje 'background'

        # Zaplanuj przywrócenie oryginalnych kolorów po 1.5 sekundzie
        self.root.after(1500, lambda: self._reset_widget_bg_after_highlight(widget_to_highlight, original_bg_main, children_colors))

    def _reset_widget_bg_after_highlight(self, widget, original_main_bg, children_colors):
        """Przywraca oryginalne kolory tła po podświetleniu."""
        if widget.winfo_exists():
            widget.config(bg=original_main_bg)
            for child_widget, original_child_bg in children_colors.items():
                if child_widget.winfo_exists():
                    try:
                        child_widget.config(bg=original_child_bg)
                    except tk.TclError:
                        pass # Ignoruj błędy
            logging.debug(f"Zresetowano podświetlenie dla wiadomości: {getattr(widget, '_chat_message_id', 'N/A')}")

    # --- Koniec modyfikacji metod dla wyświetlania załączników ---
    # --- KONIEC NOWYCH ZMIAN (CHAT) ---

    # --- NOWE ZMIANY (CHAT) ---
    def _format_chat_date(self, chat_date: datetime.date) -> str:
        """Formatuje datę wiadomości na 'Dzisiaj', 'Wczoraj' lub pełną datę."""
        today = datetime.date.today()
        yesterday = today - datetime.timedelta(days=1)
        
        if chat_date == today:
            return "--- Dzisiaj ---"
        elif chat_date == yesterday:
            return "--- Wczoraj ---"
        else:
            return f"--- {chat_date.strftime('%Y-%m-%d')} ---"
    # --- KONIEC NOWYCH ZMIAN (CHAT) ---

    # --- NOWE ZMIANY (CHAT UI) ---
    def _fetch_chat_users(self):
        """
        Pobiera listę wszystkich zarejestrowanych użytkowników czatu (dla prywatnych konwersacji)
        oraz listę dostępnych pokoi czatu (dla grup).
        """
        try:
            # 1. Pobierz użytkowników
            response_users = requests.get(f"{self.chat_server_url}/users", timeout=10)
            response_users.raise_for_status()
            users_data = response_users.json()
            self.chat_users = {user['id']: user for user in users_data}
            logging.info(f"Chat: Pobrano {len(self.chat_users)} użytkowników: {self.chat_users}") # Dodatkowy log

            # 2. Pobierz pokoje czatu
            response_rooms = requests.get(f"{self.chat_server_url}/rooms", timeout=10)
            response_rooms.raise_for_status()
            rooms_data = response_rooms.json()
            self.chat_rooms = {room['id']: room for room in rooms_data}
            logging.info(f"Chat: Pobrano {len(self.chat_rooms)} pokoi czatu: {self.chat_rooms}") # Dodatkowy log

            # 3. Zaktualizuj Treeview
            self.root.after(0, self._filter_chat_users)

        except requests.exceptions.RequestException as e:
            logging.error(f"Chat: Błąd pobierania listy użytkowników/pokoi: {e}")
            self.root.after(0, lambda: self._display_chat_message(f"--- Błąd pobierania użytkowników/pokoi: {e} ---", "error"))
        except Exception as e_ex: # Złap inne potencjalne błędy parsowania
            logging.exception(f"Chat: Nieoczekiwany błąd w _fetch_chat_users: {e_ex}")

    def _load_and_display_chat_history(self, current_user_id, partner_or_room_id, *, chat_type: str): # Zmieniono user1_id na current_user_id
        """
        Ładuje pierwszą stronę historii czatu (ostatnie N wiadomości)
        i wyświetla je w oknie.
        """
        self.chat_history_before = None
        self.chat_history_has_more = False
        self.chat_history_loading = False
        self._jump_target_message_id = None

        self._display_chat_message("", "clear")
        self._display_chat_message("--- Ładowanie historii czatu... ---", "system")

        def fetch_initial_page():
            try:
                url_path = ""
                params = {
                    "limit": self.chat_page_size,
                    "user_id": current_user_id 
                }

                if chat_type == "user":
                    url_path = f"/messages/{current_user_id}/{partner_or_room_id}"
                elif chat_type == "room":
                    url_path = f"/rooms/{partner_or_room_id}/messages"
                else:
                    self.root.after(0, lambda: self._display_chat_message("--- Błąd: Nieznany typ chatu ---", "error"))
                    return

                logging.debug(f"Chat: Pobieranie historii z {self.chat_server_url}{url_path} z parametrami: {params}")
                resp = requests.get(f"{self.chat_server_url}{url_path}", params=params, timeout=10)
                resp.raise_for_status() # To rzuci wyjątek dla 4xx/5xx
                data = resp.json()
                
                self.chat_messages[partner_or_room_id] = data["messages"] 
                self.chat_history_has_more = data.get("has_more", False)
                self.chat_history_before = data.get("next_before")

                self.root.after(0, lambda partner_id_cb=partner_or_room_id: self._display_active_chat_history(partner_id_cb))

            except requests.exceptions.HTTPError as http_err_local:
                error_content = "Nieznany błąd serwera HTTP."
                response_obj_for_lambda = http_err_local.response
                status_code_for_lambda = response_obj_for_lambda.status_code if response_obj_for_lambda else None
                
                try:
                    error_content = response_obj_for_lambda.json().get('error', error_content) if response_obj_for_lambda else str(http_err_local)
                except json.JSONDecodeError:
                    error_content = str(http_err_local)
                
                logging.error(f"Chat: Błąd HTTP ({status_code_for_lambda}) podczas pobierania historii: {error_content}")

                # --- NOWE ZMIANY: Obsługa błędu 403 Forbidden ---
                if status_code_for_lambda == 403:
                    # Użytkownik nie jest członkiem pokoju
                    room_name_for_message = self.chat_rooms.get(partner_or_room_id, {}).get('name', f"Pokój ID {partner_or_room_id}")
                    self.root.after(0, lambda rn=room_name_for_message, rid=partner_or_room_id: 
                                    self._display_join_room_prompt(rn, rid))
                else: # Inne błędy HTTP
                    self.root.after(
                        0,
                        lambda err=error_content, code=status_code_for_lambda: 
                        self._display_chat_message(f"--- Błąd ładowania historii ({code}): {err} ---", "error")
                    )
                # --- KONIEC ZMIANY ---
            except Exception as general_e_local: # Zmieniono nazwę zmiennej błędu
                 logging.exception(f"Chat: Nieoczekiwany błąd w fetch_initial_page dla historii: {general_e_local}")
                 # --- ZMIANA: Przekazanie wartości do lambdy ---
                 self.root.after(
                    0,
                    lambda err_str_gen=str(general_e_local): self._display_chat_message(f"--- Nieoczekiwany błąd: {err_str_gen} ---", "error")
                )
                 # --- KONIEC ZMIANY ---
        threading.Thread(target=fetch_initial_page, daemon=True).start()

    # --- NOWA METODA (CHAT GRUPOWY - Bezpieczeństwo / UI Klienta) ---
    def _display_join_room_prompt(self, room_name: str, room_id: int):
        """Wyświetla w oknie czatu informację o braku dostępu i przycisk dołączenia."""
        self._display_chat_message("", "clear") # Wyczyść okno wiadomości
        
        prompt_text = (
            f"Nie jesteś członkiem pokoju '{room_name}'.\n\n"
            "Aby zobaczyć wiadomości i uczestniczyć w rozmowie, musisz najpierw dołączyć do pokoju."
        )
        self._display_chat_message(prompt_text, "system")
        
        # Możemy tutaj dodać przycisk "Dołącz do Pokoju" bezpośrednio w oknie Text,
        # ale to jest bardziej skomplikowane. Na razie zostawmy to jako informację.
        # Użytkownik będzie musiał użyć menu kontekstowego (które dodamy później).
        # Alternatywnie, moglibyśmy dodać przycisk pod polem wiadomości.
        
        # TODO: W przyszłości, zamiast tylko tekstu, można by dodać tutaj interaktywny element "Dołącz"
        # lub pokazać pole do wpisania hasła, jeśli pokój jest chroniony.
        # Na razie, po prostu informujemy.

        # Upewnij się, że etykieta partnera pokazuje nazwę pokoju
        if hasattr(self, 'chat_active_partner_label'):
            self.chat_active_partner_label.config(text=f"Pokój: {room_name} (Brak dostępu)")

        # Wyłącz pole do wpisywania wiadomości, jeśli nie jesteśmy członkiem
        if hasattr(self, 'chat_input_entry'):
            self.chat_input_entry.config(state=tk.DISABLED)
            self.chat_input_var.set("")
            if hasattr(self, '_current_reply_message_data'): self._current_reply_message_data = None
            if hasattr(self, '_pending_chat_attachment'): self._pending_chat_attachment = None
            self._update_reply_preview_ui()
            self._update_pending_attachment_ui()
            
        self._update_send_button_state() # To powinno wyłączyć przycisk wysyłania
    # --- KONIEC NOWEJ METODY ---

# ... (istniejący kod) ...

    # Modyfikacja metody _add_message_to_history
    def _add_message_to_history(self, message_data: dict, is_sent_by_me: bool, message_context: str): # Dodano message_context
        """
        Dodaje wiadomość do historii self.chat_messages i, jeśli dotyczy
        aktywnego czatu, wyświetla ją natychmiast oraz wysyła potwierdzenie odczytu.
        `message_context` może być "private" lub "group".
        """
        sender_id = message_data.get('sender_id')
        msg_id = message_data.get('id')
        timestamp_str = message_data.get('timestamp')
        timestamp_dt = datetime.datetime.fromisoformat(timestamp_str)
        current_user_id = self.chat_logged_in_user['user_id']

        # Załącznik
        attachment_server_filename = message_data.get('attachment_server_filename')
        attachment_original_filename = message_data.get('attachment_original_filename')
        attachment_mimetype = message_data.get('attachment_mimetype')

        # Cytowana wiadomość
        replied_to_preview = message_data.get('replied_to_message_preview')
        
        # Pełne dane wiadomości dla _display_chat_message
        full_message_data_for_display = message_data.copy()


        # --- NOWE ZMIANY: Ustalenie klucza dla self.chat_messages i logiki wyświetlania ---
        history_key = None # ID partnera lub pokoju, do którego przypisujemy wiadomość w historii
        display_this_message_in_active_chat = False # Czy wiadomość ma być od razu wyświetlona

        if message_context == "private":
            receiver_id = message_data.get('receiver_id')
            history_key = receiver_id if is_sent_by_me else sender_id
            if history_key == self.active_chat_partner_id and self.active_chat_type == "user":
                display_this_message_in_active_chat = True
        elif message_context == "group":
            room_id = message_data.get('room_id')
            history_key = room_id
            if history_key == self.active_chat_partner_id and self.active_chat_type == "room":
                display_this_message_in_active_chat = True
        else: # Nieznany kontekst, nie rób nic (lub zaloguj błąd)
            logging.error(f"Chat: Nieznany kontekst wiadomości w _add_message_to_history: {message_context}")
            return

        if history_key is None:
            logging.error("Chat: Nie można ustalić klucza historii (partnera/pokoju) dla wiadomości.")
            return

        # Dodaj do pamięci podręcznej historii wiadomości
        self.chat_messages.setdefault(history_key, []).append(message_data)
        logging.debug(f"Chat: Dodano wiadomość ID {msg_id} do historii dla klucza '{history_key}'. Aktualny rozmiar: {len(self.chat_messages[history_key])}")
        
        if display_this_message_in_active_chat:
            yview_info = self.chat_message_display.yview() if hasattr(self, 'chat_message_display') else (0, 1.0)
            was_at_bottom = yview_info[1] >= 0.98

            active_partner_name = ""
            if self.active_chat_type == "user":
                active_partner_name = self.chat_users.get(history_key, {}).get('username', f'ID_{history_key}')
            elif self.active_chat_type == "room":
                active_partner_name = self.chat_rooms.get(history_key, {}).get('name', f'Pokój ID_{history_key}')

            # --- Usunięcie starych stopek (footerów) ---
            footer_base_text = "--- Koniec czatu z " # Nie dołączaj tutaj nazwy, bo może się zmienić
            self.chat_message_display.config(state=tk.NORMAL)
            current_pos = "1.0"
            while True:
                idx = self.chat_message_display.search(footer_base_text, current_pos, tk.END, nocase=True)
                if not idx: break
                self.chat_message_display.delete(f"{idx} linestart", f"{idx} lineend +1c")
            self.chat_message_display.config(state=tk.DISABLED)


            # Sprawdzenie i dodanie nagłówka daty
            if (not hasattr(self, '_last_chat_date_displayed_for_active') or
                self._last_chat_date_displayed_for_active.get(history_key) != timestamp_dt.date()):
                self._display_chat_message("", "normal")
                self._display_chat_message(self._format_chat_date(timestamp_dt.date()), "system")
                self._display_chat_message("", "normal")
                if not hasattr(self, '_last_chat_date_displayed_for_active'):
                    self._last_chat_date_displayed_for_active = {}
                self._last_chat_date_displayed_for_active[history_key] = timestamp_dt.date()
            
            # Przygotowanie tekstu wiadomości
            time_str = timestamp_dt.strftime('%H:%M')
            display_text_bubble = ""
            msg_type_bubble = "other_message" # Domyślnie

            sender_display_name = message_data.get('sender_username', f"ID_{sender_id}")

            if is_sent_by_me:
                display_text_bubble = f"[{time_str}] Ja: {message_data.get('content', '')}"
                msg_type_bubble = "my_message"
            else: # Wiadomość przychodząca
                if message_context == "private":
                    display_text_bubble = f"[{time_str}] {sender_display_name}: {message_data.get('content', '')}"
                elif message_context == "group":
                    # Dla wiadomości grupowych ZAWSZE pokazuj nazwę nadawcy
                    display_text_bubble = f"[{time_str}] {sender_display_name}: {message_data.get('content', '')}"
                msg_type_bubble = "other_message"
                
            # Przygotowanie danych załącznika
            attach_data_bubble = None
            if attachment_server_filename:
                attach_data_bubble = {
                    'server_filename': attachment_server_filename,
                    'original_filename': attachment_original_filename,
                    'attachment_mimetype': attachment_mimetype
                }

            # Wyświetlenie dymka
            self._display_chat_message(
                display_text_bubble,
                msg_type_bubble,
                attachment_data=attach_data_bubble,
                message_id=msg_id,
                is_read_by_receiver=(is_sent_by_me and message_data.get('is_read_by_receiver', False)),
                sender_id_for_read_status_check=sender_id,
                replied_to_message_preview=replied_to_preview,
                message_data=full_message_data_for_display
            )
            
            # Dodanie stopki
            self._display_chat_message(f"--- Koniec czatu z {active_partner_name} ---", "system")
            
            if was_at_bottom:
                self.chat_message_display.see(tk.END)
            
            if not is_sent_by_me and message_context == "private": # Oznacz jako przeczytane tylko dla wiadomości prywatnych
                 self.root.after(200, self._check_and_mark_read) # Z opóźnieniem, aby UI zdążyło się zrenderować
        else: # Wiadomość nie dotyczy aktywnego czatu (tylko prywatne i grupowe od innych)
            if not is_sent_by_me: # Tylko dla przychodzących
                # Użyj `history_key` do aktualizacji licznika (może to być `sender_id` dla prywatnych lub `room_id` dla grup)
                self.unread_messages_count[history_key] = self.unread_messages_count.get(history_key, 0) + 1
                self._notify_new_chat_message(history_key, message_data.get('sender_username', ''), message_data.get('content', ''), message_context=message_context) # Przekaż message_context

    # --- KONIEC NOWYCH ZMIAN ---

    # --- NOWE ZMIANY (CHAT KLIENT - Odpowiadanie) ---
    def _set_reply_mode(self, message_data_to_quote: dict):
        """
        Ustawia tryb odpowiadania na wiadomość, wyświetlając jej podgląd
        nad polem wprowadzania.
        """
        if not message_data_to_quote or not message_data_to_quote.get('id'):
            logging.warning("Chat: Próba ustawienia trybu odpowiadania bez danych wiadomości.")
            return

        self._current_reply_message_data = message_data_to_quote
        logging.info(f"Chat: Ustawiono tryb odpowiadania na wiadomość ID {message_data_to_quote.get('id')}.")
        self._update_reply_preview_ui() # Odśwież UI, aby pokazać podgląd

    # --- KONIEC NOWYCH ZMIAN (CHAT KLIENT - Odpowiadanie) ---

    # --- NOWE ZMIANY (CHAT) ---
# W klasie GameLauncher, metoda _notify_new_chat_message()
    def _notify_new_chat_message(self, source_id, sender_username, message_content, message_context: str): # Dodano message_context
        """
        Wyświetla systemowe powiadomienie o nowej wiadomości i oznacza użytkownika/pokój na liście.
        `source_id` to `sender_id` dla prywatnych lub `room_id` dla grupowych.
        """
        if sender_username == self.chat_logged_in_user['username'] and source_id == self.chat_logged_in_user['user_id']: # Ignoruj powiadomienia od siebie
            return

        # --- NOWE ZMIANY: Logika tytułu powiadomienia ---
        notification_title = ""
        target_name_for_title = ""
        if message_context == "private":
            target_name_for_title = sender_username
            notification_title = f"Nowa wiadomość od {target_name_for_title}"
        elif message_context == "group":
            room_info = self.chat_rooms.get(source_id) # source_id to room_id
            target_name_for_title = room_info.get('name', f"Pokój ID_{source_id}") if room_info else f"Pokój ID_{source_id}"
            notification_title = f"Nowa wiadomość w '{target_name_for_title}' od {sender_username}"
        else:
            notification_title = f"Nowa wiadomość od {sender_username}" # Fallback
        # --- KONIEC NOWYCH ZMIAN ---

        # Opcjonalne sprawdzenie, czy nie pokazywać, jeśli okno jest aktywne i to ten czat
        if self.root.winfo_exists() and self.root.winfo_ismapped() and self.current_frame == self.chat_page_frame and \
           self.active_chat_partner_id == source_id and self.active_chat_type == message_context : # Sprawdź też typ
            logging.debug(f"Chat: Wiadomość odebrana dla aktywnego czatu ({message_context} {source_id}), pomijam powiadomienie systemowe.")
            # Jeśli to aktywny czat, _add_message_to_history już wyświetliło wiadomość
            # i zaktualizowało unread_count dla tej rozmowy/pokoju w Treeview.
            return

        # Powiadomienie systemowe
        try:
            notification.notify(
                title=notification_title, # Użyj zaktualizowanego tytułu
                message=message_content,
                app_name="Game Launcher Chat",
                app_icon=os.path.abspath("icon.ico") if os.path.exists("icon.ico") else None, 
                timeout=5
            )
        except Exception as e:
            logging.warning(f"Chat: Nie udało się wyświetlić powiadomienia systemowego: {e}")
        
        # Wizualne zaznaczenie na liście użytkowników/pokoi - użyj source_id jako klucza
        self._filter_chat_users()

    # --- NOWE ZMIANY: Dodano argument chat_type (na razie nieużywany w logice) ---
    def _clear_new_message_notification(self, partner_or_room_id, chat_type: str | None = None): # <-- Dodano chat_type
        """Usuwa wizualne powiadomienie o nowej wiadomości dla danego użytkownika/pokoju i resetuje licznik."""
        # --- KONIEC NOWYCH ZMIAN ---

        # Resetuj licznik nieprzeczytanych wiadomości dla tego partnera/pokoju
        # W przyszłości, jeśli `chat_type` będzie 'room', możemy użyć innego słownika
        # dla liczników nieprzeczytanych wiadomości grupowych. Na razie używamy tego samego.
        if partner_or_room_id is not None: # Upewnij się, że ID nie jest None
            self.unread_messages_count.pop(partner_or_room_id, None) # Użyj pop do usunięcia klucza, jeśli istnieje
        
        # Wizualne zaznaczenie na liście użytkowników/pokoi
        if hasattr(self, 'chat_users_tree') and self.chat_users_tree.winfo_exists():
            item_iid_to_clear = None
            if chat_type == "user" and partner_or_room_id is not None:
                item_iid_to_clear = f"{self.CHAT_PREFIX_USER}{partner_or_room_id}"
            elif chat_type == "room" and partner_or_room_id is not None:
                item_iid_to_clear = f"{self.CHAT_PREFIX_ROOM}{partner_or_room_id}"

            if item_iid_to_clear and self.chat_users_tree.exists(item_iid_to_clear):
                current_tags = list(self.chat_users_tree.item(item_iid_to_clear, 'tags'))
                if "new_message_tag" in current_tags:
                    current_tags.remove("new_message_tag")
                    # Zaktualizuj również licznik w kolumnie (ustaw na pusty string)
                    current_values = list(self.chat_users_tree.item(item_iid_to_clear, 'values'))
                    if len(current_values) == 2: # Powinno być ("Nazwa", "Nowe")
                        current_values[1] = "" # Wyczyść licznik "Nowe"
                        self.chat_users_tree.item(item_iid_to_clear, values=tuple(current_values), tags=tuple(current_tags))
                    else:
                        self.chat_users_tree.item(item_iid_to_clear, tags=tuple(current_tags)) # Fallback
                    
                    logging.debug(f"Chat: Usunięto tag 'new_message' dla IID: {item_iid_to_clear}")

            # Opcjonalnie, jeśli używasz `_filter_chat_users` do pełnego odświeżenia,
            # powyższy kod może nie być potrzebny, bo `_filter_chat_users` sam odświeży tagi
            # na podstawie zresetowanego `unread_messages_count`. Ale bezpośrednia manipulacja tagami jest szybsza.
            # self._filter_chat_users() # Można odkomentować, jeśli chcesz pełne odświeżenie listy.

    # --- KONIEC NOWYCH ZMIAN (CHAT) ---

    # --- NOWE ZMIANY (CHAT) ---
    def _load_saved_chat_credentials(self):
        active_server_data = self._get_active_server_data()
        if active_server_data and active_server_data.get("remember_credentials", False):
            creds = active_server_data.get("credentials", {})
            self.chat_email_var.set(creds.get("email", ""))
            self.chat_password_var.set(creds.get("password", "")) # Nadal plain/zaszyfrowane
            logging.debug(f"Chat: Wypełniono pola zapamiętanymi danymi dla serwera '{active_server_data.get('name')}'.")
        else: # Wyczyść pola, jeśli nie ma zapamiętanych dla tego serwera lub opcja jest wyłączona
            self.chat_email_var.set("")
            self.chat_password_var.set("")
    # --- KONIEC NOWYCH ZMIAN (CHAT) ---

    def _send_chat_message(self, event=None):
        # Walidacja stanu czatu
        if not self.chat_logged_in_user or not self.sio or not self.sio.connected or not self.chat_authenticated:
            messagebox.showwarning("Czat", "Musisz być zalogowany i połączony, aby wysyłać wiadomości.", parent=self.chat_page_frame)
            return
        # --- NOWE ZMIANY (CHAT GRUPOWY - Etap 2/5 - Zmiana 5/5) ---
        if not (self.active_chat_type == "user" or self.active_chat_type == "room"):
            messagebox.showwarning("Czat", "Wybierz partnera czatu lub pokój grupowy.", parent=self.chat_page_frame)
            return
        # --- KONIEC NOWYCH ZMIAN ---

        message_content = self.chat_input_var.get().strip()
        replied_to_id = None
        if self._current_reply_message_data: replied_to_id = self._current_reply_message_data.get('id')

        # Jeżeli brak treści i brak załącznika -> nic nie wysyłaj
        if not message_content and not self._pending_chat_attachment: return

        # Przygotuj dane do wysłania
        payload = {
            'sender_id': self.chat_logged_in_user['user_id'],
            'content': message_content,
        }
        # --- NOWE ZMIANY ---
        # Kierowanie wiadomości
        if self.active_chat_type == "user":
            payload['receiver_id'] = self.active_chat_partner_id
        elif self.active_chat_type == "room":
            payload['room_id'] = self.active_chat_partner_id
        # --- KONIEC NOWYCH ZMIAN ---

        if replied_to_id: payload['replied_to_message_id'] = replied_to_id

        # Obsługa załącznika (kopiujemy istniejący blok logiczny z `_emit_chat_message_with_attachment`)
        if self._pending_chat_attachment:
            filepath = self._pending_chat_attachment['filepath']
            original_name = self._pending_chat_attachment['original_filename']

            upload_win = tk.Toplevel(self.chat_page_frame); # ... (standardowy kod progressbar) ...

            try:
                file_obj = open(filepath, 'rb')
                files_payload = {'file': (original_name, file_obj, mimetypes.guess_type(filepath)[0] or 'application/octet-stream')}

                def _upload_and_then_send_socket_message_thread(
                    files_payload_local,
                    progress_window_local,
                    file_to_close_local,
                    payload_local # Teraz przekazujemy cały payload zamiast tylko text_content_local i replied_to_id
                ):
                    try:
                        resp = requests.post(f"{self.chat_server_url}/upload_file", files=files_payload_local, timeout=60)
                        resp.raise_for_status()
                        upload_data = resp.json()
                        if progress_window_local.winfo_exists(): progress_window_local.destroy()
                        
                        # Dodaj dane załącznika do payloadu
                        payload_local['attachment_server_filename'] = upload_data.get('attachment_server_filename')
                        payload_local['attachment_original_filename'] = upload_data.get('attachment_original_filename')
                        payload_local['attachment_mimetype'] = upload_data.get('attachment_mimetype')
                        
                        self.root.after(0, self._emit_chat_message, payload_local) # Nowa/uproszczona metoda emitująca
                    except Exception as e:
                        err = str(e); logging.error(f"Błąd wysyłania pliku: {err}")
                        if progress_window_local.winfo_exists(): progress_window_local.destroy()
                        self.root.after(0, lambda: messagebox.showerror("Błąd Wysyłania Pliku", err, parent=self.chat_page_frame))
                        self.root.after(0, self._clear_pending_chat_attachment)
                    finally:
                        if file_to_close_local and not file_to_close_local.closed: file_to_close_local.close()

                threading.Thread(
                    target=_upload_and_then_send_socket_message_thread,
                    args=(files_payload, upload_win, file_obj, payload),
                    daemon=True
                ).start()

            except Exception as e:
                logging.error(f"Przygotowanie pliku nie powiodło się: {e}"); messagebox.showerror("Błąd Wysyłania", str(e), parent=self.chat_page_frame)
                if 'upload_win' in locals() and upload_win.winfo_exists(): upload_win.destroy()
                if 'file_obj' in locals() and not file_obj.closed: file_obj.close()
                self._clear_pending_chat_attachment()

        # Wysyłka samej wiadomości tekstowej (bez załącznika)
        elif message_content:
            self._emit_chat_message(payload) # Nowa/uproszczona metoda emitująca

    # Nowa / zmodyfikowana metoda `_emit_chat_message`
    def _emit_chat_message(self, payload: dict):
        """
        Faktycznie emituje wiadomość Socket.IO na serwer.
        Teraz ZAWSZE emituje event 'send_message'.
        """
        # --- ZMIANA: Zawsze używamy eventu 'send_message' ---
        event_name = 'send_message'
        log_message = ""
        if 'room_id' in payload and payload['room_id'] is not None: # Sprawdź czy room_id nie jest None
            log_message = f"Chat: Emitting '{event_name}' for GROUP to room {payload['room_id']}"
        elif 'receiver_id' in payload and payload['receiver_id'] is not None: # Sprawdź czy receiver_id nie jest None
            log_message = f"Chat: Emitting '{event_name}' for PRIVATE to user {payload.get('receiver_id')}"
        else:
            logging.error(f"Chat: Próba wysłania wiadomości ({event_name}) bez room_id i bez receiver_id. Payload: {payload}")
            messagebox.showerror("Błąd Wysyłania", "Błąd wewnętrzny: Brak odbiorcy lub pokoju.", parent=self.chat_page_frame)
            return

        logging.info(log_message)
        # --- KONIEC ZMIANY ---

        try:
            self.sio.emit(event_name, payload) # Emituj event 'send_message'
            self.chat_input_var.set("") 
            self._clear_pending_chat_attachment() 
            self._send_typing_stop_event() 
            self._cancel_reply_mode() 
        except Exception as e:
            messagebox.showerror("Błąd Wysyłania", f"Nie udało się wysłać wiadomości:\n{e}", parent=self.chat_page_frame)
            logging.error(f"Chat: Błąd emitowania wiadomości ({event_name}): {e}")

    # Zmieniamy nazwę poprzedniej metody _select_and_upload_chat_file, bo teraz jej funkcję pełni _send_chat_message
    # Usuniemy _select_and_upload_chat_file i _upload_file_thread, _handle_file_upload_response
    # --- KONIEC NOWYCH ZMIAN (CHAT - Obsługa oczekującego załącznika) ---

    # --- NOWE ZMIANY (Strona Wyboru Serwera - Metody Pokazania i Tworzenia UI) ---
    def show_server_selection_page(self):
        """Pokazuje stronę zarządzania serwerami czatu."""
        self._hide_library_components() # Jeśli jest taka metoda do ukrywania specyficznych rzeczy
        
        self.server_selection_page_frame.grid()
        self.server_selection_page_frame.tkraise()
        self.current_frame = self.server_selection_page_frame

        if not self._server_selection_initialized:
            logging.info("Tworzenie zawartości strony wyboru serwera czatu po raz pierwszy.")
            self._create_server_selection_page_content()
            self._server_selection_initialized = True
        else:
            # Jeśli strona była już inicjalizowana, odśwież listę serwerów
            if hasattr(self, '_load_chat_servers_to_treeview'):
                self._load_chat_servers_to_treeview()
        
        self.current_section = "Zarządza Serwerami Czatu" # Lub podobnie
        self._update_discord_status(status_type="browsing", activity_details=self.current_section)

    def _create_server_selection_page_content(self):
        """Tworzy interfejs użytkownika dla strony zarządzania serwerami czatu."""
        for widget in self.server_selection_page_frame.winfo_children():
            widget.destroy()

        self.server_selection_page_frame.columnconfigure(0, weight=1)
        self.server_selection_page_frame.rowconfigure(1, weight=1) # Pozwól Treeview rosnąć

        # Nagłówek
        header_frame_servers = ttk.Frame(self.server_selection_page_frame)
        header_frame_servers.grid(row=0, column=0, sticky="ew", padx=10, pady=(10,5))
        header_frame_servers.columnconfigure(0, weight=1) # Wyśrodkowanie etykiety
        ttk.Label(header_frame_servers, text="Zarządzanie Serwerami Czatu", font=("Helvetica", 16, "bold")).pack(pady=5)

        # Ramka dla Treeview i Scrollbara
        tree_frame_servers = ttk.Frame(self.server_selection_page_frame)
        tree_frame_servers.grid(row=1, column=0, sticky="nsew", padx=10, pady=5)
        tree_frame_servers.columnconfigure(0, weight=1)
        tree_frame_servers.rowconfigure(0, weight=1)

        columns = ("name", "url", "default")
        self.servers_tree = ttk.Treeview(tree_frame_servers, columns=columns, show="headings", selectmode="browse")
        self.servers_tree.heading("name", text="Nazwa Serwera")
        self.servers_tree.heading("url", text="Adres URL")
        self.servers_tree.heading("default", text="Domyślny?")
        
        self.servers_tree.column("name", width=200, anchor=tk.W)
        self.servers_tree.column("url", width=300, anchor=tk.W)
        self.servers_tree.column("default", width=80, anchor=tk.CENTER, stretch=False)

        servers_scrollbar = ttk.Scrollbar(tree_frame_servers, orient="vertical", command=self.servers_tree.yview)
        self.servers_tree.configure(yscrollcommand=servers_scrollbar.set)
        
        self.servers_tree.grid(row=0, column=0, sticky="nsew")
        servers_scrollbar.grid(row=0, column=1, sticky="ns")

        # TODO: Bindowanie <Double-1> do "Połącz" i <Button-3> do menu kontekstowego

        # Ramka na przyciski zarządzania listą serwerów
        buttons_frame_servers = ttk.Frame(self.server_selection_page_frame)
        buttons_frame_servers.grid(row=2, column=0, pady=10, sticky="ew")
        # Wyśrodkowanie przycisków
        buttons_frame_servers.columnconfigure(0, weight=1) 
        buttons_frame_servers.columnconfigure(1, weight=1)
        buttons_frame_servers.columnconfigure(2, weight=1)
        buttons_frame_servers.columnconfigure(3, weight=1) # Dla Połącz

        # Umieść przyciski w wewnętrznej ramce, aby były obok siebie, a potem wyśrodkuj ramkę
        inner_buttons_frame = ttk.Frame(buttons_frame_servers)
        inner_buttons_frame.grid(row=0, column=0, columnspan=4) # columnspan, aby ramka mogła się centrować

        ttk.Button(inner_buttons_frame, text="➕ Dodaj Serwer", command=self._add_edit_chat_server_dialog).pack(side=tk.LEFT, padx=5)
        ttk.Button(inner_buttons_frame, text="✏️ Edytuj Zaznaczony", command=lambda: self._add_edit_chat_server_dialog(edit_mode=True)).pack(side=tk.LEFT, padx=5)
        ttk.Button(inner_buttons_frame, text="❌ Usuń Zaznaczony", command=self._delete_chat_server_dialog).pack(side=tk.LEFT, padx=5)
        ttk.Button(inner_buttons_frame, text="🔗 Połącz z Zaznaczonym", style="Green.TButton", command=self._connect_to_selected_server).pack(side=tk.LEFT, padx=15)


        # Ramka dla opcji globalnych (np. auto-connect)
        global_options_frame = ttk.Frame(self.server_selection_page_frame)
        global_options_frame.grid(row=3, column=0, pady=(10,5), padx=10, sticky="w")
        
        auto_connect_check = ttk.Checkbutton(
            global_options_frame,
            text="Automatycznie łącz z domyślnym serwerem przy starcie launchera",
            variable=self.chat_auto_connect_to_default_var,
            command=self._save_auto_connect_setting
        )
        auto_connect_check.pack(side=tk.LEFT)

        # Wczytaj dane do Treeview
        self._load_chat_servers_to_treeview()

    def _load_chat_servers_to_treeview(self):
        """Wczytuje listę serwerów z self.chat_servers_list do Treeview."""
        if not hasattr(self, 'servers_tree') or not self.servers_tree.winfo_exists():
            return

        for item in self.servers_tree.get_children():
            self.servers_tree.delete(item)

        # Sortuj listę serwerów np. alfabetycznie po nazwie, z domyślnym na górze
        sorted_servers = sorted(self.chat_servers_list, key=lambda s: (not s.get("is_default", False), s.get("name", "").lower()))

        for server_data in sorted_servers:
            server_id = server_data.get("id")
            name = server_data.get("name", "Brak Nazwy")
            url = server_data.get("url", "Brak URL")
            is_default_str = "Tak" if server_data.get("is_default") else "Nie"
            
            tags = []
            if server_data.get("id") == self.active_chat_server_id:
                tags.append('active_server') # Tag dla aktywnego serwera

            self.servers_tree.insert("", "end", iid=server_id, values=(name, url, is_default_str), tags=tags)
        
        # Konfiguracja tagu dla aktywnego serwera (np. pogrubienie)
        self.servers_tree.tag_configure('active_server', font=('Segoe UI', 9, 'bold'), foreground='lightgreen')

    # Placeholder dla metod, które będą potrzebne (dodamy je w kolejnych krokach)
    def _add_edit_chat_server_dialog(self, edit_mode=False):
        """Otwiera dialog do dodawania lub edycji serwera czatu."""
        server_data_to_edit = None
        if edit_mode:
            selection = self.servers_tree.selection()
            if not selection:
                messagebox.showwarning("Brak Zaznaczenia", "Zaznacz serwer, który chcesz edytować.", 
                                     parent=self.server_selection_page_frame)
                return
            selected_server_id = selection[0]
            server_data_to_edit = next((s for s in self.chat_servers_list if s.get("id") == selected_server_id), None)
            if not server_data_to_edit:
                messagebox.showerror("Błąd", "Nie można znaleźć danych dla wybranego serwera.",
                                     parent=self.server_selection_page_frame)
                return

        dialog = ChatServerEditorDialog(self.server_selection_page_frame, self, server_data_to_edit)
        
        if dialog.result:
            new_server_data = dialog.result
            
            # --- NOWE ZMIANY: Logika aktualizacji is_default ---
            if new_server_data.get("is_default"):
                # Jeśli ten serwer jest ustawiany jako domyślny,
                # odznacz wszystkie inne serwery jako domyślne.
                for s_iter in self.chat_servers_list:
                    if s_iter.get("id") != new_server_data.get("id"): # Nie odznaczaj właśnie edytowanego/dodanego
                        s_iter["is_default"] = False
            # Jeśli ten serwer NIE jest ustawiany jako domyślny (is_default = False w new_server_data)
            # a był to JEDYNY domyślny serwer, to musimy ustawić inny jako domyślny (np. pierwszy z listy).
            elif not new_server_data.get("is_default") and \
                 server_data_to_edit and server_data_to_edit.get("is_default") and \
                 not any(s.get("is_default") for s in self.chat_servers_list if s.get("id") != new_server_data.get("id")):
                # Jeśli odznaczyliśmy jedyny domyślny serwer, i lista nie jest pusta po tej operacji,
                # ustaw pierwszy serwer na liście jako domyślny.
                # Najpierw zaktualizuj/dodaj wpis, potem znajdź nowy domyślny.
                pass # Logika poniżej to obsłuży
            # --- KONIEC NOWYCH ZMIAN ---

            if edit_mode and server_data_to_edit:
                updated_list_after_edit = False
                for i, server in enumerate(self.chat_servers_list):
                    if server.get("id") == server_data_to_edit.get("id"):
                        self.chat_servers_list[i] = new_server_data
                        updated_list_after_edit = True
                        break
                if not updated_list_after_edit: # Na wszelki wypadek, gdyby ID się zmieniło w dialogu (nie powinno)
                    self.chat_servers_list.append(new_server_data) 
            else: 
                self.chat_servers_list.append(new_server_data)
            
            # --- NOWE ZMIANY: Upewnij się, że zawsze jest JEDEN domyślny, jeśli lista nie jest pusta ---
            if self.chat_servers_list and not any(s.get("is_default") for s in self.chat_servers_list):
                self.chat_servers_list[0]["is_default"] = True # Ustaw pierwszy jako domyślny
            # --- KONIEC NOWYCH ZMIAN ---
                
            self.local_settings["chat_servers"] = self.chat_servers_list
            save_local_settings(self.local_settings)
            self._load_chat_servers_to_treeview()

    def _delete_chat_server_dialog(self):
        """Usuwa zaznaczony serwer czatu z listy."""
        selection = self.servers_tree.selection()
        if not selection:
            messagebox.showwarning("Brak Zaznaczenia", "Zaznacz serwer, który chcesz usunąć.",
                                 parent=self.server_selection_page_frame)
            return
        selected_server_id = selection[0]
        server_to_delete = next((s for s in self.chat_servers_list if s.get("id") == selected_server_id), None)

        if not server_to_delete:
            messagebox.showerror("Błąd", "Nie można znaleźć wybranego serwera do usunięcia.",
                                 parent=self.server_selection_page_frame)
            return

        if len(self.chat_servers_list) <= 1:
            messagebox.showwarning("Ostrzeżenie", "Nie można usunąć ostatniego serwera z listy.",
                                 parent=self.server_selection_page_frame)
            return

        if messagebox.askyesno("Potwierdź Usunięcie", 
                               f"Czy na pewno chcesz usunąć serwer:\n'{server_to_delete.get('name')}' ({server_to_delete.get('url')})?",
                               icon='warning', parent=self.server_selection_page_frame):
            
            self.chat_servers_list = [s for s in self.chat_servers_list if s.get("id") != selected_server_id]
            
            # Jeśli usunięto aktywny serwer, ustaw inny jako aktywny (np. pierwszy lub domyślny)
            if self.active_chat_server_id == selected_server_id:
                if self.sio and self.sio.connected: self._chat_logout() # Rozłącz, jeśli był połączony
                
                new_active_server = next((s for s in self.chat_servers_list if s.get("is_default")), None)
                if not new_active_server and self.chat_servers_list:
                    new_active_server = self.chat_servers_list[0]
                
                self.active_chat_server_id = new_active_server.get("id") if new_active_server else None
                self.local_settings["active_chat_server_id"] = self.active_chat_server_id
                # Zaktualizuj używany URL itp.
                self._update_active_server_dependent_settings()


            # Jeśli usunięto domyślny serwer, a lista nie jest pusta, ustaw inny jako domyślny
            if server_to_delete.get("is_default") and self.chat_servers_list:
                # Sprawdź, czy jest już inny domyślny
                if not any(s.get("is_default") for s in self.chat_servers_list):
                     self.chat_servers_list[0]["is_default"] = True # Ustaw pierwszy jako domyślny
            
            self.local_settings["chat_servers"] = self.chat_servers_list
            save_local_settings(self.local_settings)
            self._load_chat_servers_to_treeview()
            logging.info(f"Usunięto serwer czatu: {server_to_delete.get('name')}")

    # Potrzebna nowa metoda pomocnicza do aktualizacji ustawień po zmianie aktywnego serwera
    def _update_active_server_dependent_settings(self):
        """Aktualizuje self.chat_server_url i inne zmienne na podstawie aktywnego serwera."""
        active_data = self._get_active_server_data()
        if active_data:
            self.chat_server_url = active_data.get("url", "http://127.0.0.1:5000")
            creds = active_data.get("credentials", {})
            self.current_server_credentials["email"] = creds.get("email", "")
            self.current_server_credentials["password"] = creds.get("password", "")
            self.current_server_remember_credentials = active_data.get("remember_credentials", False)
            self.current_server_auto_login = active_data.get("auto_login_to_server", False)

            if hasattr(self, 'chat_server_url_var'): self.chat_server_url_var.set(self.chat_server_url)
            if hasattr(self, 'chat_remember_me_var'): self.chat_remember_me_var.set(self.current_server_remember_credentials)
            if hasattr(self, 'chat_auto_login_var'): self.chat_auto_login_var.set(self.current_server_auto_login)
            
            # Wyczyść pola logowania, jeśli "remember_me" nie jest ustawione dla nowego aktywnego serwera
            if hasattr(self, 'chat_email_var') and hasattr(self, 'chat_password_var'):
                if not self.current_server_remember_credentials:
                    self.chat_email_var.set("")
                    self.chat_password_var.set("")
                else: # Załaduj dane, jeśli są zapamiętane
                    self.chat_email_var.set(self.current_server_credentials["email"])
                    self.chat_password_var.set(self.current_server_credentials["password"])

            logging.info(f"Przełączono na serwer: {active_data.get('name')} ({self.chat_server_url})")
        else: # Brak serwerów na liście
            self.chat_server_url = "http://127.0.0.1:5000" # Fallback
            # Wyczyść wszystkie powiązane zmienne
            if hasattr(self, 'chat_server_url_var'): self.chat_server_url_var.set(self.chat_server_url)
            if hasattr(self, 'chat_remember_me_var'): self.chat_remember_me_var.set(False)
            if hasattr(self, 'chat_auto_login_var'): self.chat_auto_login_var.set(False)
            if hasattr(self, 'chat_email_var'): self.chat_email_var.set("")
            if hasattr(self, 'chat_password_var'): self.chat_password_var.set("")
            logging.warning("Brak zdefiniowanych serwerów czatu.")

    def _connect_to_selected_server(self):
        """Łączy z serwerem wybranym w Treeview na stronie zarządzania serwerami."""
        if not hasattr(self, 'servers_tree') or not self.servers_tree.winfo_exists():
            logging.error("Próba połączenia, ale Treeview serwerów nie istnieje.")
            return

        selection = self.servers_tree.selection()
        if not selection:
            messagebox.showwarning("Brak Zaznaczenia", "Zaznacz serwer z listy, z którym chcesz się połączyć.",
                                 parent=self.server_selection_page_frame)
            return
        
        selected_server_id = selection[0]
        server_data_to_connect = next((s for s in self.chat_servers_list if s.get("id") == selected_server_id), None)

        if not server_data_to_connect:
            messagebox.showerror("Błąd Wewnętrzny", "Nie można znaleźć danych dla wybranego serwera.",
                                 parent=self.server_selection_page_frame)
            self._load_chat_servers_to_treeview() # Odśwież listę na wszelki wypadek
            return

        new_url = server_data_to_connect.get("url")
        new_name = server_data_to_connect.get("name")

        if not new_url:
            messagebox.showerror("Brak URL", f"Wybrany serwer '{new_name}' nie ma zdefiniowanego adresu URL.",
                                 parent=self.server_selection_page_frame)
            return

        logging.info(f"Próba połączenia z wybranym serwerem: '{new_name}' ({new_url})")

        # 1. Rozłącz z obecnym serwerem, jeśli jesteś połączony
        if self.sio and self.sio.connected:
            if self.chat_server_url == new_url: # Próba połączenia z tym samym serwerem, z którym już jesteśmy połączeni
                messagebox.showinfo("Informacja", f"Jesteś już połączony z serwerem '{new_name}'.",
                                    parent=self.server_selection_page_frame)
                self.show_chat_page() # Po prostu przejdź do strony czatu
                return
            else: # Łączenie z innym serwerem
                self._chat_logout() # To rozłączy i zresetuje stan czatu

        # 2. Ustaw nowy serwer jako aktywny i zaktualizuj ustawienia
        self.active_chat_server_id = selected_server_id
        self.local_settings["active_chat_server_id"] = selected_server_id # Zapisz jako ostatnio używany/aktywny
        
        # Aktualizuj last_used dla wybranego serwera
        for server in self.chat_servers_list:
            if server.get("id") == selected_server_id:
                server["last_used"] = time.time()
                break
        self.local_settings["chat_servers"] = self.chat_servers_list
        save_local_settings(self.local_settings)

        self._update_active_server_dependent_settings() # To ustawi self.chat_server_url, creds, etc.
        self._load_chat_servers_to_treeview() # Odśwież Treeview, aby pokazać nowy aktywny serwer

        # 3. Przejdź do strony czatu (która spróbuje się połączyć i ewentualnie auto-zalogować)
        messagebox.showinfo("Przełączanie Serwera", 
                            f"Przełączono na serwer '{new_name}'.\nPrzechodzenie do strony logowania/czatu...",
                            parent=self.server_selection_page_frame)
        
        self.show_chat_page() # To wywoła logikę połączenia i logowania dla nowego serwera

    def _save_auto_connect_setting(self):
        self.local_settings["chat_auto_connect_to_default"] = self.chat_auto_connect_to_default_var.get()
        save_local_settings(self.local_settings)
        logging.info(f"Ustawienie auto-connect to default server: {self.chat_auto_connect_to_default_var.get()}")
    # --- KONIEC NOWYCH ZMIAN ---

    # --- Metoda do cyklicznej aktualizacji overlay'a z GameLauncher ---
    def _update_overlay_regularly(self):
        """Pobiera dane z odtwarzacza i aktualizuje overlay, jeśli jest widoczny."""
        if self.overlay_update_timer:
            self.root.after_cancel(self.overlay_update_timer)
            self.overlay_update_timer = None # Zresetuj, aby uniknąć podwójnych timerów

        # Sprawdź, czy overlay ma być w ogóle pokazywany (ustawienie użytkownika)
        # show_overlay_var jest inicjalizowany w _create_settings_page_content
        should_show_overlay = False
        if hasattr(self, 'show_track_overlay_var'):
            try:
                should_show_overlay = self.show_track_overlay_var.get()
            except tk.TclError: # Może się zdarzyć, jeśli root jest niszczony
                should_show_overlay = self.local_settings.get("show_track_overlay", False)


        if hasattr(self, 'track_overlay') and self.track_overlay and \
           self.track_overlay.winfo_exists() and self.track_overlay.winfo_viewable() and \
           hasattr(self, 'music_player_page_instance') and self.music_player_page_instance:
            
            player = self.music_player_page_instance
            track_name_disp = "Nic nie gra..."
            current_t_sec = 0.0
            total_t_sec = 0.0
            is_actually_playing_or_paused = player.is_playing # Uwzględnia pauzę jako część "aktywnego" utworu

            # --- ZMIANA: Pobierz dane tylko jeśli coś gra lub jest spauzowane ---
            if player.is_playing and player.current_track_index != -1 and player.current_track_index < len(player.playlist):
                current_entry = player.playlist[player.current_track_index]
                track_name_disp = player._get_display_name_for_track(current_entry).replace("♥ ", "").strip()
                total_t_sec = getattr(player, '_current_track_duration_sec', 0.0)

                if not player.is_paused: # Czas idzie do przodu tylko jeśli nie jest spauzowane
                    if hasattr(player, '_start_time') and hasattr(player, '_pause_acc'):
                         current_t_sec = time.monotonic() - player._start_time - player._pause_acc
                         current_t_sec = max(0, current_t_sec)
                         if total_t_sec > 0: # Ogranicz do długości utworu
                             current_t_sec = min(current_t_sec, total_t_sec)
                else: # Jeśli jest spauzowane, pokaż ostatnią znaną pozycję
                    # _pause_start jest ustawiane, gdy pauzujemy
                    # current_pos przed pauzą to _pause_start - _start_time - _pause_acc (bez czasu tej pauzy)
                    if hasattr(player, '_pause_start') and hasattr(player, '_start_time') and hasattr(player, '_pause_acc'):
                        current_t_sec = player._pause_start - player._start_time - player._pause_acc
                        current_t_sec = max(0, current_t_sec)
                        if total_t_sec > 0:
                            current_t_sec = min(current_t_sec, total_t_sec)
                    # Jeśli nie ma _pause_start, użyj ostatniej znanej wartości z _update_track_progress (trudne do synchronizacji)
                    # Prościej jest, aby _execute_play_pause zapisywało ostatnią pozycję przy pauzie.
                    # Na razie: overlay przy pauzie może pokazywać "zamrożony" czas, który był ostatnio obliczony.
                    # Ta logika w _update_overlay_regularly sama to obsłuży, bo current_t_sec nie będzie rosło.
                    # Ale potrzebujemy zapamiętać current_pos_sec z chwili pauzy,
                    # inaczej będzie dalej liczyć od _start_time - _pause_acc.

                    # Prostsze rozwiązanie dla pauzy: _update_track_progress w MusicPlayerPage
                    # aktualizuje zmienną np. player._last_known_play_position, którą tu odczytujemy.
                    # Aktualnie _update_track_progress już nie działa przy pauzie.

                    # Najlepiej, aby `TrackOverlayWindow.update_display` przyjmowało `is_paused`
                    # i jeśli tak, nie aktualizowało paska/czasu, tylko zostawiało ostatnią wartość.
                    # Aktualna logika:
                    # Jeśli jest spauzowane, current_t_sec NIE jest aktualizowane o time.monotonic(),
                    # ale update_display i tak zostanie wywołane.

                    # Poprawka: Przekażmy player.is_paused do update_display.
                    # Na razie `is_actually_playing_or_paused` jest używane.
                    pass # is_actually_playing_or_paused obsłuży to poniżej
            
            # --- KONIEC ZMIANY ---
            self.track_overlay.update_display(track_name_disp, current_t_sec, total_t_sec, is_actually_playing_or_paused)
        
        if should_show_overlay: # Zaplanuj następne tylko jeśli opcja jest włączona
            self.overlay_update_timer = self.root.after(250, self._update_overlay_regularly) # Aktualizuj częściej dla płynności paska

    def _set_music_hotkey_dialog(self, action_key: str, string_var_to_update: tk.StringVar, entry_widget_to_update: ttk.Entry):
        """
        Otwiera okno/logikę do nasłuchiwania i ustawiania nowego skrótu klawiszowego.
        Używa pynput.keyboard.Listener.
        """
        logging.debug(f"Rozpoczęto ustawianie skrótu dla akcji: {action_key}")
        if hasattr(self, 'key_combination_listener') and self.key_combination_listener and self.key_combination_listener.is_alive():
            messagebox.showwarning("Uwaga", "Już jesteś w trakcie ustawiania innego skrótu.\nZakończ lub anuluj poprzednią próbę.", 
                                 parent=self.settings_page_frame if hasattr(self, 'settings_page_frame') else self.root)
            if hasattr(self, 'capturing_hotkey_toplevel') and self.capturing_hotkey_toplevel.winfo_exists():
                self.capturing_hotkey_toplevel.lift()
            return

        self.current_new_hotkey_action = action_key
        self.current_new_hotkey_stringvar = string_var_to_update
        self._pressed_keys_for_new_hotkey = set() 

        # Tworzenie okna Toplevel
        self.capturing_hotkey_toplevel = tk.Toplevel(self.settings_page_frame if hasattr(self, 'settings_page_frame') else self.root)
        self.capturing_hotkey_toplevel.title("Ustawianie Skrótu")
        
        parent_for_geometry = self.settings_page_frame if hasattr(self, 'settings_page_frame') and self.settings_page_frame.winfo_exists() else self.root
        parent_x = parent_for_geometry.winfo_rootx()
        parent_y = parent_for_geometry.winfo_rooty()
        parent_w = parent_for_geometry.winfo_width()
        parent_h = parent_for_geometry.winfo_height()
        dialog_w = 350
        dialog_h = 130 # Trochę więcej miejsca na tekst i przycisk
        pos_x = parent_x + (parent_w // 2) - (dialog_w // 2)
        pos_y = parent_y + (parent_h // 2) - (dialog_h // 2)
        self.capturing_hotkey_toplevel.geometry(f"{dialog_w}x{dialog_h}+{pos_x}+{pos_y}")
        
        self.capturing_hotkey_toplevel.transient(parent_for_geometry)
        self.capturing_hotkey_toplevel.grab_set()
        self.capturing_hotkey_toplevel.resizable(False, False)
        
        # Użyj nazwy wyświetlanej dla akcji
        display_action_name = self.hotkey_actions_display_names.get(action_key, action_key)

        ttk.Label(self.capturing_hotkey_toplevel, 
                  text=f"Naciśnij nową kombinację klawiszy dla:\n'{display_action_name}'", 
                  wraplength=330, justify="center", anchor="center").pack(pady=(10,5), fill="x", expand=True)
        self.capturing_hotkey_label = ttk.Label(self.capturing_hotkey_toplevel, text="...", font=("Segoe UI", 10, "bold"), anchor="center")
        self.capturing_hotkey_label.pack(pady=5, fill="x", expand=True)
        ttk.Button(self.capturing_hotkey_toplevel, text="Anuluj", command=self._cancel_hotkey_capture).pack(pady=(0,10))
        
        self.capturing_hotkey_toplevel.protocol("WM_DELETE_WINDOW", self._cancel_hotkey_capture)
        self.capturing_hotkey_toplevel.focus_force()
        
        # Tymczasowo zatrzymaj globalne skróty, aby uniknąć konfliktów
        if hasattr(self, 'global_hotkeys_listener') and self.global_hotkeys_listener and self.global_hotkeys_listener.is_alive():
            self.global_hotkeys_listener.stop()
            logging.debug("Tymczasowo zatrzymano GlobalHotKeys na czas ustawiania nowego skrótu.")

        try:
            # suppress=True zapobiega przekazywaniu wciśnięć do innych aplikacji podczas przechwytywania
            self.key_combination_listener = keyboard.Listener(
                on_press=self._on_press_for_new_hotkey,
                on_release=self._on_release_for_new_hotkey,
                suppress=True 
            )
            self.key_combination_listener.start()
            logging.debug("Uruchomiono listenera pynput (keyboard.Listener) dla nowego skrótu (suppress=True).")
        except Exception as e:
            logging.error(f"Nie udało się uruchomić listenera pynput (keyboard.Listener): {e}")
            messagebox.showerror("Błąd Listenera", "Nie można było uruchomić nasłuchiwania klawiatury.", 
                                 parent=self.capturing_hotkey_toplevel if hasattr(self, 'capturing_hotkey_toplevel') and self.capturing_hotkey_toplevel.winfo_exists() else self.root)
            self._cancel_hotkey_capture() # Anuluj, jeśli listener nie mógł wystartować
            self._reregister_all_global_hotkeys() # Spróbuj ponownie włączyć globalne, jeśli były zatrzymane



    def _cancel_hotkey_capture(self):
        """Anuluje proces ustawiania nowego skrótu i przywraca globalne skróty."""
        if hasattr(self, 'key_combination_listener') and self.key_combination_listener and self.key_combination_listener.is_alive():
            self.key_combination_listener.stop()
            self.key_combination_listener.join(timeout=0.1) # Daj szansę na zatrzymanie
            logging.debug("Anulowano i zatrzymano listenera dla nowego skrótu.")
        self.key_combination_listener = None
        
        if hasattr(self, 'capturing_hotkey_toplevel') and self.capturing_hotkey_toplevel.winfo_exists():
            self.capturing_hotkey_toplevel.destroy()
        
        # --- NOWE: Ponownie zarejestruj globalne skróty, jeśli były aktywne ---
        if self.local_settings.get("music_hotkeys_enabled", True): # Jeśli skróty były włączone
            self._reregister_all_global_hotkeys()
        # --- KONIEC NOWEGO ---

        self.current_new_hotkey_action = None
        self.current_new_hotkey_stringvar = None
        if hasattr(self, '_pressed_keys_for_new_hotkey'):
            self._pressed_keys_for_new_hotkey.clear()

    def _music_action_callback(self, action_key):
        """Ogólny callback dla skrótów muzycznych."""
        logging.info(f"Globalny skrót muzyczny aktywowany: {action_key}")
        if action_key == "play_pause": self._music_control_play_pause()
        elif action_key == "next_track": self._music_control_next_track()
        elif action_key == "prev_track": self._music_control_prev_track()
        elif action_key == "stop_music": self._music_control_stop() # Musisz stworzyć tę metodę wrapper
        elif action_key == "volume_up": self._music_control_volume_up() # Musisz stworzyć
        elif action_key == "volume_down": self._music_control_volume_down() # Musisz stworzyć

    def _register_music_hotkeys(self):
        """Rejestruje globalne skróty klawiszowe dla muzyki."""
        if not self.local_settings.get("music_hotkeys_enabled", True): # Sprawdź flagę
            logging.info("Globalne skróty muzyczne są wyłączone w ustawieniach. Pomijanie rejestracji.")
            if self.global_hotkeys_listener and self.global_hotkeys_listener.is_alive():
                self.global_hotkeys_listener.stop() # Na wszelki wypadek zatrzymaj, jeśli działały
                self.global_hotkeys_listener = None
            return
        if self.global_hotkeys_listener and self.global_hotkeys_listener.is_alive():
            self.global_hotkeys_listener.stop()
            self.global_hotkeys_listener = None
            logging.info("Zatrzymano poprzedniego listenera GlobalHotKeys.")

        hotkey_config = self.local_settings.get("music_hotkeys", DEFAULT_MUSIC_HOTKEYS.copy())
        self.active_hotkeys = {} # Wyczyść mapę zarejestrowanych

        # Pylint może narzekać na tworzenie funkcji w pętli, ale dla GlobalHotKeys jest to typowe.
        # Aby tego uniknąć, można stworzyć listę krotek (kombinacja, callback)
        # i przekazać ją do konstruktora GlobalHotKeys.

        callbacks_map = {}
        for action, combination_str in hotkey_config.items():
            if combination_str: # Tylko jeśli skrót jest zdefiniowany
                # Tworzenie callbacku z zamrożoną wartością action_key
                callback = functools.partial(self._music_action_callback, action)
                callbacks_map[combination_str] = callback
                logging.debug(f"Przygotowano do rejestracji: '{combination_str}' -> {action}")
            else:
                logging.debug(f"Pominięto rejestrację dla akcji '{action}', brak zdefiniowanego skrótu.")
        
        if not callbacks_map:
            logging.info("Brak skrótów do zarejestrowania dla muzyki.")
            return

        try:
            self.global_hotkeys_listener = keyboard.GlobalHotKeys(callbacks_map)
            self.global_hotkeys_listener.start()
            logging.info("Pomyślnie uruchomiono listenera GlobalHotKeys dla muzyki.")
        except Exception as e:
            logging.error(f"Nie udało się uruchomić GlobalHotKeys: {e}")
            messagebox.showerror("Błąd Skrótów Globalnych", f"Nie można było zarejestrować globalnych skrótów klawiszowych dla muzyki:\n{e}", parent=self.root)
            self.global_hotkeys_listener = None


    def _reregister_all_global_hotkeys(self):
        """Zatrzymuje i ponownie rejestruje wszystkie globalne skróty (np. po zmianie)."""
        logging.info("Ponowna rejestracja globalnych skrótów klawiszowych...")
        # Na razie mamy tylko skróty muzyczne, ale w przyszłości mogą być inne
        self._register_music_hotkeys()


    # Metody-wrappery (niektóre już masz, dodaj brakujące)
    def _music_control_stop(self):
        if hasattr(self, 'track_overlay') and self.track_overlay and self.track_overlay.winfo_exists():
            self.track_overlay.update_display("Nic nie gra...", 0, 0, False) # Zaktualizuj od razu po stopie


    def _music_control_volume_up(self):
        if hasattr(self, 'music_player_page_instance') and self.music_player_page_instance:
            self.root.after(0, lambda: self.music_player_page_instance._change_volume_by_step(10)) # np. +10%

    def _music_control_volume_down(self):
        if hasattr(self, 'music_player_page_instance') and self.music_player_page_instance:
            self.root.after(0, lambda: self.music_player_page_instance._change_volume_by_step(-10)) # np. -10%




    def toggle_library_view(self): # POPRAWNE WCIĘCIE
        """Przełącza tryb widoku biblioteki i odświeża UI."""
        current_mode = self.library_view_mode.get()
        new_mode = 'list' if current_mode == 'tiles' else 'tiles'
        self.library_view_mode.set(new_mode) # Ustaw nową wartość
        self.local_settings["library_view_mode"] = new_mode
        save_local_settings(self.local_settings)

        # Zaktualizuj tekst przycisku *przed* odświeżeniem siatki
        self.update_view_mode_button_text()

        # Odśwież siatkę z nowym trybem
        self.reset_and_update_grid()

    # --- NOWA METODA ---
    def _capture_initial_root_size(self):
        """Pobiera i zapisuje początkowy rozmiar okna po jego utworzeniu."""
        try:
            # Wymuś aktualizację, aby uzyskać poprawne wymiary
            self.root.update_idletasks()
            self._last_root_width = self.root.winfo_width()
            self._last_root_height = self.root.winfo_height()
            logging.info(f"Początkowy rozmiar okna: {self._last_root_width}x{self._last_root_height}")
        except tk.TclError as e:
            # Może się zdarzyć, jeśli okno zostanie zamknięte przed wykonaniem after_idle
            logging.warning(f"Błąd podczas pobierania początkowego rozmiaru okna: {e}")
    # --- KONIEC NOWEJ METODY ---

    def update_view_mode_button_text(self): # POPRAWNE WCIĘCIE
        """Aktualizuje tekst przycisku przełączania widoku."""
        if hasattr(self, 'view_mode_button') and self.view_mode_button.winfo_exists():
            current_mode = self.library_view_mode.get()
            if current_mode == 'tiles':
                # Jeśli aktualnie są kafelki, przycisk oferuje przejście do listy
                self.view_mode_button.config(text="Widok: Lista")
            else:
                # Jeśli aktualnie jest lista, przycisk oferuje przejście do kafelków
                self.view_mode_button.config(text="Widok: Kafelki")

# W klasie GameLauncher, metoda toggle_fullscreen

    def toggle_fullscreen(self):
        is_fullscreen = self.fullscreen_var.get()
        self.root.attributes('-fullscreen', is_fullscreen)
        # --- NOWE: Odśwież siatkę po zmianie trybu ---
        # Dajmy chwilę oknu na zmianę rozmiaru przed odświeżeniem
        if self.current_frame == self.main_frame and self.library_view_mode.get() == 'tiles':
             self.root.after(100, self.reset_and_update_grid)
        # --- KONIEC NOWEGO ---


    def ask_for_username(self):
        username = simpledialog.askstring("Nazwa Użytkownika", "Podaj swoją nazwę użytkownika:")
        if username:
            self.user["username"] = username
        else:
            self.user["username"] = "Gracz"
        save_config(self.config)

    def create_sidebar(self):
        # Usuń istniejące widgety z panelu bocznego
        for widget in self.sidebar.winfo_children():
            widget.destroy()

        ttk.Label(self.sidebar, text=self.translator.gettext("Game Launcher"), font=("Helvetica", 16, "bold")).pack(pady=20)

        self.btn_home = ttk.Button(self.sidebar, text=self.translator.gettext("Home"), command=self.show_home)
        self.btn_home.pack(fill="x", padx=20, pady=5)

        self.btn_library = ttk.Button(self.sidebar, text=self.translator.gettext("Library"), command=self.show_library)
        self.btn_library.pack(fill="x", padx=20, pady=5)

        self.btn_roadmap = ttk.Button(self.sidebar, text=self.translator.gettext("Roadmap"), command=self.show_roadmap)
        self.btn_roadmap.pack(fill="x", padx=20, pady=5)

        self.btn_mods = ttk.Button(self.sidebar, text=self.translator.gettext("Mod Manager"), command=self.show_mod_manager)
        self.btn_mods.pack(fill="x", padx=20, pady=5)

        # --- NOWY PRZYCISK ---
        self.btn_achievements = ttk.Button(self.sidebar, text=self.translator.gettext("Osiągnięcia"), command=self.show_achievements_page)
        self.btn_achievements.pack(fill="x", padx=20, pady=5)
        # --- KONIEC NOWEGO ---

        self.btn_news = ttk.Button(self.sidebar, text=self.translator.gettext("News"), command=self.show_news)
        self.btn_news.pack(fill="x", padx=20, pady=5)

        # --- NOWE ZMIANY ---
        self.btn_stats = ttk.Button(self.sidebar, text="Statystyki", command=self.show_statistics_page) # Nowy przycisk
        self.btn_stats.pack(fill="x", padx=20, pady=5)
        # --- KONIEC NOWYCH ZMIAN ---

        # --- NOWY PRZYCISK MUZYKI ---
        self.btn_music = ttk.Button(self.sidebar, text="Muzyka", command=self.show_music_page)
        self.btn_music.pack(fill="x", padx=20, pady=5)
        # --- KONIEC NOWEGO PRZYCISKU ---

        # --- NOWE ZMIANY (CHAT) ---
        self.btn_chat = ttk.Button(self.sidebar, text="Czat", command=self.show_chat_page)
        self.btn_chat.pack(fill="x", padx=20, pady=5)
        # --- KONIEC NOWYCH ZMIAN (CHAT) ---

        # --- NOWE ZMIANY (Strona Wyboru Serwera - Przycisk w Sidebarze) ---
        self.btn_chat_servers = ttk.Button(self.sidebar, text="Serwery Czatu", command=self.show_server_selection_page)
        self.btn_chat_servers.pack(fill="x", padx=20, pady=5)
        # --- KONIEC NOWYCH ZMIAN ---

        self.btn_settings = ttk.Button(self.sidebar, text=self.translator.gettext("Settings"), command=self.show_settings) # Upewnij się, że command=self.show_settings
        self.btn_settings.pack(fill="x", padx=20, pady=5)

        self.btn_exit = ttk.Button(self.sidebar, text=self.translator.gettext("Exit"), command=self.on_closing)
        self.btn_exit.pack(fill="x", padx=20, pady=5)

        # Dodaj przyciski "Tryb Pełnoekranowy" i "Zminimalizuj do zasobnika"
        self.fullscreen_var = tk.BooleanVar(value=self.fullscreen_var.get() if hasattr(self, 'fullscreen_var') else False)
        fullscreen_btn = ttk.Checkbutton(self.sidebar, text=self.translator.gettext("Fullscreen Mode"), variable=self.fullscreen_var, command=self.toggle_fullscreen)
        fullscreen_btn.pack(pady=5)

        minimize_btn = ttk.Button(self.sidebar, text=self.translator.gettext("Minimize to Tray"), command=self.minimize_to_tray)
        minimize_btn.pack(pady=5)


    def create_header(self):
        """Tworzy górny panel (header) dla widoku biblioteki."""
        if hasattr(self, 'header') and self.header.winfo_exists():
            for widget in self.header.winfo_children():
                widget.destroy()
        else:
            self.header = ttk.Frame(self.main_frame)
            self.header.grid(row=0, column=0, sticky="ew")

        self.search_var = tk.StringVar()
        self.search_var.trace_add("write", lambda *_: self._on_search_change())

        ttk.Label(self.header, text="Biblioteka", font=("Helvetica", 14)).grid(row=0, column=0, padx=10, pady=10, sticky="w")

        self.search_entry = ttk.Entry(self.header, textvariable=self.search_var)
        self.search_entry.grid(row=0, column=1, padx=5, pady=10, sticky="ew") # Wyszukiwarka dostaje główny weight

        self.add_game_btn = ttk.Button(self.header, text="Dodaj Grę", command=self.add_game)
        self.add_game_btn.grid(row=0, column=2, padx=5, pady=10)

        self.filter_or_group_var = tk.StringVar(value="Wszystkie Gry")
        self.filter_group_menu_placeholder = ttk.Frame(self.header) 
        self.filter_group_menu_placeholder.grid(row=0, column=3, padx=5, pady=10, sticky="ew")
        self.update_filter_group_menu()

        self.add_group_btn = ttk.Button(self.header, text="Dodaj Grupę Statyczną", command=self.add_group)
        self.add_group_btn.grid(row=0, column=4, padx=5, pady=10)

        self.delete_group_btn = ttk.Button(self.header, text="Usuń Grupę Statyczną", command=self.delete_group)
        self.delete_group_btn.grid(row=0, column=5, padx=5, pady=10)

        manage_filters_btn = ttk.Button(self.header, text="Zarządzaj filtrami", command=self.open_advanced_filter_manager)
        manage_filters_btn.grid(row=0, column=6, padx=10, pady=10, sticky='ew')

        self.header.columnconfigure(1, weight=1) # Kolumna dla pola wyszukiwania przejmuje całą wolną przestrzeń


        # --- Dolny Rząd: Filtry szczegółowe, Sortowanie, Przyciski ---
        filter_sort_frame = ttk.Frame(self.header)
        filter_sort_frame.grid(row=1, column=0, columnspan=7, sticky='ew', padx=5, pady=(0, 5))
        
        # Kolumny wewnątrz filter_sort_frame:
        # [Etykieta (w=0)] [Dropdown (w=1, minsize)] ... [Button (w=0)] [Button (w=0)]
        
        current_col_in_filter_sort_frame = 0 
        
        # Minimalne szerokości dla pól rozwijanych, dobrane empirycznie,
        # by zmieścić standardowe "Wszystkie Gatunki" itp.
        MIN_DROPDOWN_WIDTH = 130 
        COMMON_INNER_PADX = 5 # PadX wewnątrz par Label/Dropdown

        # === Gatunek ===
        filter_sort_frame.columnconfigure(current_col_in_filter_sort_frame, weight=0) # Etykieta
        ttk.Label(filter_sort_frame, text="Gatunek:").grid(row=0, column=current_col_in_filter_sort_frame, padx=(0, COMMON_INNER_PADX), pady=5, sticky="w"); current_col_in_filter_sort_frame += 1
        
        filter_sort_frame.columnconfigure(current_col_in_filter_sort_frame, weight=1, minsize=MIN_DROPDOWN_WIDTH) # Rozwijalna lista gatunków
        self.filter_var = tk.StringVar(value="Wszystkie Gatunki")
        self.genre_options = ["Wszystkie Gatunki"] + self.get_all_genres() 
        self.filter_menu = ttk.OptionMenu(filter_sort_frame, self.filter_var, self.filter_var.get(), *self.genre_options, command=lambda _: self.reset_and_update_grid())
        # Zmieniono padx - tylko z lewej (nie z prawej, żeby przylegał do następnej etykiety)
        self.filter_menu.grid(row=0, column=current_col_in_filter_sort_frame, padx=(0,0), pady=5, sticky="ew"); current_col_in_filter_sort_frame += 1


        # === Tag ===
        filter_sort_frame.columnconfigure(current_col_in_filter_sort_frame, weight=0) # Etykieta
        ttk.Label(filter_sort_frame, text="Tag:").grid(row=0, column=current_col_in_filter_sort_frame, padx=(COMMON_INNER_PADX, COMMON_INNER_PADX), pady=5, sticky="w"); current_col_in_filter_sort_frame += 1
        
        filter_sort_frame.columnconfigure(current_col_in_filter_sort_frame, weight=1, minsize=MIN_DROPDOWN_WIDTH) # Rozwijalna lista tagów
        self.tag_filter_var = tk.StringVar(value="Wszystkie Tagi")
        self.tag_filter_menu = ttk.OptionMenu(filter_sort_frame, self.tag_filter_var, "Wszystkie Tagi", command=lambda _: self.reset_and_update_grid())
        self.tag_filter_menu.grid(row=0, column=current_col_in_filter_sort_frame, padx=(0,0), pady=5, sticky="ew"); current_col_in_filter_sort_frame += 1
        self.update_tag_filter_options() 


        # === Typ ===
        filter_sort_frame.columnconfigure(current_col_in_filter_sort_frame, weight=0) # Etykieta
        ttk.Label(filter_sort_frame, text="Typ:").grid(row=0, column=current_col_in_filter_sort_frame, padx=(COMMON_INNER_PADX, COMMON_INNER_PADX), pady=5, sticky="w"); current_col_in_filter_sort_frame += 1
        
        filter_sort_frame.columnconfigure(current_col_in_filter_sort_frame, weight=1, minsize=MIN_DROPDOWN_WIDTH) # Rozwijalna lista typów
        self.game_type_filter_var = tk.StringVar(value="Wszystkie Typy")
        game_type_options = ["Wszystkie Typy", "Gry PC", "Gry Emulowane"]
        self.game_type_filter_menu = ttk.OptionMenu(filter_sort_frame, self.game_type_filter_var, self.game_type_filter_var.get(), *game_type_options, command=lambda _: self.reset_and_update_grid())
        self.game_type_filter_menu.grid(row=0, column=current_col_in_filter_sort_frame, padx=(0,0), pady=5, sticky="ew"); current_col_in_filter_sort_frame += 1


        # === Sortuj ===
        filter_sort_frame.columnconfigure(current_col_in_filter_sort_frame, weight=0) # Etykieta
        ttk.Label(filter_sort_frame, text="Sortuj:").grid(row=0, column=current_col_in_filter_sort_frame, padx=(COMMON_INNER_PADX, COMMON_INNER_PADX), pady=5, sticky="w"); current_col_in_filter_sort_frame += 1
        
        filter_sort_frame.columnconfigure(current_col_in_filter_sort_frame, weight=1, minsize=MIN_DROPDOWN_WIDTH) # Rozwijalna lista sortowania
        self.sort_var = tk.StringVar(value="Nazwa")
        sort_options = ["Nazwa", "Data Dodania", "Czas Gry", "Ocena"]
        self.sort_menu = ttk.OptionMenu(filter_sort_frame, self.sort_var, self.sort_var.get(), *sort_options, command=lambda _: self.reset_and_update_grid())
        self.sort_menu.grid(row=0, column=current_col_in_filter_sort_frame, padx=(0,0), pady=5, sticky="ew"); current_col_in_filter_sort_frame += 1
        
        # === Przyciski zarządzania i widoku ===
        # Te przyciski będą po prawej stronie sortowania, z minimalnym padx między sobą.
        # Będą spychane przez rozciągające się pola rozwijane.

        # Zarządzaj Gatunkami
        manage_genres_btn = ttk.Button(filter_sort_frame, text="Zarządzaj Gatunkami", command=self.manage_genres)
        # PadX po lewej: oddzielenie od poprzedniego OptionMenu (zmieniono na 10px, aby nie kleiło się za bardzo)
        manage_genres_btn.grid(row=0, column=current_col_in_filter_sort_frame, padx=(10,5), pady=5, sticky="e"); current_col_in_filter_sort_frame += 1

        # Widok: Lista/Kafelki
        self.view_mode_button = ttk.Button(filter_sort_frame, command=self.toggle_library_view)
        manage_genres_btn.grid(row=0, column=current_col_in_filter_sort_frame, padx=(5,0), pady=5, sticky="e"); current_col_in_filter_sort_frame += 1

        self.update_view_mode_button_text()

        # Ustawienie wagi dla ostatniej kolumny (przycisk widoku), aby nie rozpychała za bardzo
        # filter_sort_frame.columnconfigure(col_idx - 1, weight=0)

# W klasie GameLauncher

    # --- NOWA METODA ---
    def show_statistics_page(self):
        """Pokazuje stronę statystyk, tworząc ją przy pierwszym użyciu."""
        # Sprawdź, czy zawartość strony została już utworzona
        if not self.stats_page_frame.winfo_children():
            logging.info("Tworzenie zawartości strony Statystyk po raz pierwszy.")
            self.create_statistics_page() # Utwórz UI

        self.stats_page_frame.grid() # Pokaż ramkę (jeśli była ukryta)
        self.stats_page_frame.tkraise()
        self.current_frame = self.stats_page_frame
        # --- ZMIANA ---
        self.current_section = "Przegląda Statystyki"
        self._update_discord_status(status_type="browsing", activity_details=self.current_section)
        # --- KONIEC ZMIANY ---
        self._update_launcher_usage_display()
        # --- KONIEC NOWEGO ---
        # Automatyczne odświeżenie wykresu przy pokazaniu strony (opcjonalne)
        # self._on_refresh_stats_threaded() # Można odkomentować, jeśli chcesz auto-odświeżania
    # --- KONIEC NOWEJ METODY ---

    # --- NOWA METODA ---
    def create_statistics_page(self):
        """Tworzy interfejs użytkownika dla strony statystyk."""
        for widget in self.stats_page_frame.winfo_children():
            widget.destroy()

        self.stats_page_frame.columnconfigure(0, weight=1)
        self.stats_page_frame.rowconfigure(1, weight=1)

        controls_frame = ttk.Frame(self.stats_page_frame, padding=(10, 5))
        controls_frame.grid(row=0, column=0, sticky="ew")

        # === Konfiguracja kolumn dla kontrolek ===
        # Będziemy używać więcej kolumn, aby stworzyć odstępy
        # Okres: Kolumna 0 (Label), Kolumna 1 (Combobox)
        # Widok: Kolumna 2 (Label), Kolumna 3 (Combobox)
        # Pusta przestrzeń / Combobox gry / Zakres dat: Kolumna 4 (może się rozciągać)
        # Przycisk Szczegółów Czasu: Kolumna 5
        # Przycisk Koloru Słupków: Kolumna 6
        # Przycisk Odśwież: Kolumna 7

        col_idx = 0
        # Wybór okresu
        ttk.Label(controls_frame, text="Okres:").grid(row=0, column=col_idx, padx=(0, 2), pady=5, sticky="w"); col_idx += 1
        initial_period_key = "Last 7 Days"
        initial_period_display = self.STATS_PERIOD_OPTIONS_TRANSLATED.get(initial_period_key, initial_period_key)
        self.stats_period_var = tk.StringVar(value=initial_period_display)
        period_options_display = list(self.STATS_PERIOD_OPTIONS_TRANSLATED.values())
        self.stats_period_combo = ttk.Combobox(controls_frame, textvariable=self.stats_period_var, values=period_options_display, state="readonly", width=18)
        self.stats_period_combo.grid(row=0, column=col_idx, padx=(0, 10), pady=5, sticky="w"); col_idx += 1 # Zwiększony padx

        # Wybór typu wykresu/widoku
        ttk.Label(controls_frame, text="Widok:").grid(row=0, column=col_idx, padx=(0, 2), pady=5, sticky="w"); col_idx += 1
        initial_view_key = "Playtime per Day"
        initial_view_display = self.STATS_VIEW_OPTIONS_TRANSLATED.get(initial_view_key, initial_view_key)
        self.stats_view_var = tk.StringVar(value=initial_view_display)
        view_options_display = list(self.STATS_VIEW_OPTIONS_TRANSLATED.values())
        self.stats_view_combo = ttk.Combobox(controls_frame, textvariable=self.stats_view_var, values=view_options_display, state="readonly", width=25)
        self.stats_view_combo.grid(row=0, column=col_idx, padx=(0, 10), pady=5, sticky="w"); col_idx += 1 # Zwiększony padx
        self.stats_view_combo.bind("<<ComboboxSelected>>", self._on_view_change)

        # --- Ramka na dynamiczne kontrolki (Wybór Gry, Zakres Dat) ---
        # Ta ramka będzie umieszczona w kolumnie `col_idx` i będzie zawierać pozostałe kontrolki
        self.dynamic_controls_frame = ttk.Frame(controls_frame)
        self.dynamic_controls_frame.grid(row=0, column=col_idx, padx=5, pady=5, sticky="w"); col_idx += 1
        # --- Wewnątrz dynamic_controls_frame ---
        self.stats_game_select_frame = ttk.Frame(self.dynamic_controls_frame) # Parent to dynamic_controls_frame
        # grid() dla stats_game_select_frame będzie w _on_view_change (można użyć pack tutaj)
        ttk.Label(self.stats_game_select_frame, text="Gra:").pack(side=tk.LEFT, padx=(0,2))
        self.stats_game_var = tk.StringVar()
        all_game_names = sorted(list(self.games.keys()), key=str.lower)
        self.stats_game_combo = ttk.Combobox(self.stats_game_select_frame, textvariable=self.stats_game_var, values=all_game_names, state="readonly", width=30)
        if all_game_names: self.stats_game_var.set(all_game_names[0])
        self.stats_game_combo.pack(side=tk.LEFT)

        self.custom_range_frame = ttk.Frame(self.dynamic_controls_frame) # Parent to dynamic_controls_frame
        # grid() dla custom_range_frame będzie w _on_period_change (można użyć pack tutaj)
        ttk.Label(self.custom_range_frame, text="Od:").grid(row=0, column=0, padx=(0, 2))
        self.stats_start_date_entry = DateEntry(self.custom_range_frame, width=10, date_pattern='yyyy-mm-dd')
        self.stats_start_date_entry.grid(row=0, column=1, padx=(0, 5))
        ttk.Label(self.custom_range_frame, text="Do:").grid(row=0, column=2, padx=(5, 2))
        self.stats_end_date_entry = DateEntry(self.custom_range_frame, width=10, date_pattern='yyyy-mm-dd')
        self.stats_end_date_entry.grid(row=0, column=3)
        today = datetime.date.today(); one_week_ago = today - datetime.timedelta(days=6)
        self.stats_start_date_entry.set_date(one_week_ago)
        self.stats_end_date_entry.set_date(today)
        # --- Koniec ramki na dynamiczne kontrolki ---

        # Pusta kolumna rozciągliwa, aby odsunąć przyciski na prawo
        controls_frame.columnconfigure(col_idx, weight=1); col_idx += 1

        # Przycisk "Pokaż Szczegóły Czasu Gier"
        self.show_time_details_button = ttk.Button(controls_frame, text="Pokaż Czas / Grę (Okres)", command=self._show_total_playtime_details)
        # grid() zostanie wywołany w _on_view_change, teraz w kolumnie `col_idx`
        # self.show_time_details_button.grid(row=0, column=col_idx, padx=5, pady=5, sticky="e"); col_idx += 1 # Przykładowe umiejscowienie

        # Przycisk wyboru koloru słupków
        def _choose_bar_color():
            initial = getattr(self, 'stats_bar_color', '#0078d7')
            color_code = colorchooser.askcolor(initialcolor=initial, parent=self.stats_page_frame)
            if color_code and color_code[1]:
                self.stats_bar_color = color_code[1]
                self._on_refresh_stats_threaded()
        color_btn = ttk.Button(controls_frame, text="Kolor słupków", command=_choose_bar_color)
        color_btn.grid(row=0, column=col_idx, padx=5, pady=5, sticky="e"); col_idx += 1 # Nowa kolumna dla tego przycisku

        # Przycisk odświeżania
        refresh_btn = ttk.Button(controls_frame, text="Odśwież", command=self._on_refresh_stats_threaded)
        refresh_btn.grid(row=0, column=col_idx, padx=(5, 0), pady=5, sticky="e"); col_idx += 1

        # Wyświetlanie czasu launchera
        self.launcher_usage_label = ttk.Label(controls_frame, text="Łączny czas w launcherze: Ładowanie...", font=("Segoe UI", 8, "italic"))
        self.launcher_usage_label.grid(row=1, column=0, columnspan=col_idx, sticky="w", padx=5, pady=(5,0)) # columnspan do końca użytych kolumn

        # --- Główny obszar na wykres i detale ---
        # ... (reszta bez zmian) ...
        chart_detail_frame = ttk.Frame(self.stats_page_frame); chart_detail_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=5); chart_detail_frame.rowconfigure(0, weight=1); chart_detail_frame.columnconfigure(0, weight=1); chart_detail_frame.columnconfigure(1, weight=0)
        self.chart_container = ttk.Frame(chart_detail_frame, relief="sunken", borderwidth=1); self.chart_container.grid(row=0, column=0, sticky="nsew", padx=(0, 5)); self.chart_info_label = ttk.Label(self.chart_container, text="Wybierz okres i widok...", anchor="center"); self.chart_info_label.pack(expand=True)
        self.details_frame = ttk.Frame(chart_detail_frame); self.details_frame.rowconfigure(1, weight=1); self.details_frame.columnconfigure(0, weight=1)
        details_label = ttk.Label(self.details_frame, text="Szczegóły:", font=("Segoe UI", 9, "bold")); details_label.grid(row=0, column=0, columnspan=2, sticky="nw", pady=(0, 2))
        self.details_tree = ttk.Treeview(self.details_frame, columns=("Col1", "Col2"), show="headings", height=10); self.details_tree.heading("Col1", text="Nazwa Gry"); self.details_tree.heading("Col2", text="Wartość"); self.details_tree.column("Col1", anchor="w", width=150); self.details_tree.column("Col2", anchor="e", width=80, stretch=False)
        details_tree_scroll = ttk.Scrollbar(self.details_frame, orient="vertical", command=self.details_tree.yview); self.details_tree.configure(yscrollcommand=details_tree_scroll.set); self.details_tree.grid(row=1, column=0, sticky="nsew"); details_tree_scroll.grid(row=1, column=1, sticky="ns"); self.details_frame.grid_remove()
        self._current_chart_data = None; self._last_figure_canvas = None
        self._on_period_change(); self._on_view_change()

    # --- NOWA METODA POMOCNICZA: Obsługa zmiany okresu ---
    # Zaktualizuj _on_period_change, aby poprawnie umieszczał custom_range_frame
# W klasie GameLauncher

    def _on_period_change(self, event=None):
        """Pokazuje/ukrywa kontrolki dla Custom Range."""
        # --- NOWE ZMIANY: Użyj mapowania odwrotnego ---
        selected_display_period = self.stats_period_var.get()
        period_key = self.TRANSLATED_TO_STATS_PERIOD.get(selected_display_period)
        # --- KONIEC NOWYCH ZMIAN ---

        # --- ZMIANA: Użyj period_key w porównaniu ---
        if period_key == "Custom Range...":
             self.custom_range_frame.grid(row=0, column=4, columnspan=4, padx=5, pady=5, sticky="w")
        else:
             self.custom_range_frame.grid_remove()
        # --- KONIEC ZMIANY ---
        # Wywołaj też obsługę zmiany widoku, aby poprawnie umieścić/ukryć inne elementy
        self._on_view_change()

    # --- NOWA METODA ---
    def _get_time_period_dates(self):
        """Zwraca (start_date, end_date) na podstawie wybranego okresu."""
        # --- NOWE ZMIANY: Użyj mapowania odwrotnego ---
        selected_display_period = self.stats_period_var.get() # Pobierz wyświetlaną wartość
        period_key = self.TRANSLATED_TO_STATS_PERIOD.get(selected_display_period) # Pobierz klucz techniczny
        if not period_key:
            logging.warning(f"Nie można znaleźć klucza technicznego dla okresu: {selected_display_period}. Używam 'Last 7 Days'.")
            period_key = "Last 7 Days" # Fallback
        # --- KONIEC NOWYCH ZMIAN ---

        today = datetime.date.today()
        start_date, end_date = None, None

        # --- ZMIANA: Użyj period_key w porównaniach ---
        if period_key == "Last 7 Days":
            start_date = today - datetime.timedelta(days=6)
            end_date = today
        elif period_key == "Last 30 Days":
            start_date = today - datetime.timedelta(days=29)
            end_date = today
        elif period_key == "This Month":
            start_date = today.replace(day=1)
            end_date = today
        elif period_key == "This Year":
            start_date = today.replace(month=1, day=1)
            end_date = today
        elif period_key == "All Time":
            first_date_ts = min([g.get('date_added', time.time()) for g in self.games.values()] or [time.time()])
            start_date = datetime.date.fromtimestamp(first_date_ts)
            end_date = today
        elif period_key == "Custom Range...":
            try:
                start_date = self.stats_start_date_entry.get_date()
                end_date = self.stats_end_date_entry.get_date()
                if start_date > end_date:
                    messagebox.showerror("Błąd Zakresu Dat", "Data początkowa nie może być późniejsza niż końcowa.", parent=self.stats_page_frame)
                    return None, None
            except Exception as e:
                 messagebox.showerror("Błąd Daty", f"Nieprawidłowy format daty w zakresie niestandardowym: {e}", parent=self.stats_page_frame)
                 return None, None
        else: # Domyślnie ostatnie 7 dni (fallback)
             start_date = today - datetime.timedelta(days=6)
             end_date = today
        # --- KONIEC ZMIANY ---

        return start_date, end_date

# W klasie GameLauncher, metoda _prepare_chart_data
    # --- NOWA WERSJA: Pokazuje ŁĄCZNY czas (poprzednie + bieżąca sesja) ---
    def _update_launcher_usage_display(self):
        """Aktualizuje etykiety z ŁĄCZNYM czasem użycia launchera,
           wliczając czas bieżącej sesji."""
        try: # Dodajmy try-except dla bezpieczeństwa
            # 1. Pobierz zapisany czas z poprzednich sesji
            saved_total_seconds = self.local_settings.get("total_launcher_usage_seconds", 0)

            # 2. Oblicz czas trwania bieżącej sesji
            current_session_seconds = time.time() - self.launcher_start_time

            # 3. Oblicz AKTUALNY łączny czas
            actual_total_seconds = saved_total_seconds + current_session_seconds

            # 4. Formatowanie d/h/m dla łącznego czasu
            days, rem = divmod(actual_total_seconds, 86400)
            hours, rem = divmod(rem, 3600)
            minutes = rem // 60
            txt_prefix = "Łączny czas: "
            if days > 0:
                txt = txt_prefix + f"{int(days)}d {int(hours)}h {int(minutes)}m"
            else:
                txt = txt_prefix + f"{int(hours)}h {int(minutes)}m"

            # 5. Zaktualizuj obie etykiety (jeśli istnieją)
            if hasattr(self, 'launcher_usage_label') and self.launcher_usage_label.winfo_exists():
                self.launcher_usage_label.config(text=txt)
            if hasattr(self, 'total_launcher_usage_label_home') and self.total_launcher_usage_label_home.winfo_exists():
                self.total_launcher_usage_label_home.config(text=txt)

        except Exception as e:
             logging.error(f"Błąd w _update_launcher_usage_display: {e}")
             # Można dodać tekst błędu do etykiet w razie problemów
             if hasattr(self, 'total_launcher_usage_label_home') and self.total_launcher_usage_label_home.winfo_exists():
                 self.total_launcher_usage_label_home.config(text="Łączny czas: Błąd")
             if hasattr(self, 'launcher_usage_label') and self.launcher_usage_label.winfo_exists():
                self.launcher_usage_label.config(text="Łączny czas: Błąd")


        # --- ZMIANA: Zmień interwał odświeżania łącznego czasu ---
        # Aktualizowanie co sekundę może być niepotrzebne, wystarczy np. co 10-30 sekund
        # lub nawet co minutę, bo ten licznik nie musi być aż tak dynamiczny.
        # Zostawmy na razie sekundę dla testów, ale można to zmienić.
        if hasattr(self, 'root') and self.root.winfo_exists():
            self.root.after(1000, self._update_launcher_usage_display) # Nadal co sekundę
        # --- KONIEC ZMIANY ---
    # --- KONIEC ZMIENIONEJ WERSJI ---

    # --- NOWA METODA ---
    def reset_launcher_usage_time(self):
        """
        Zeruje łączny czas spędzony w launcherze
        (zarówno zapisany, jak i bieżącą sesję) po potwierdzeniu użytkownika.
        """
        if not messagebox.askyesno(
                "Reset licznika",
                "Wyzerować zapisany czas spędzony w launcherze?"):
            return

        self.local_settings["total_launcher_usage_seconds"] = 0
        save_local_settings(self.local_settings)   # zapisz na dysku
        self.launcher_start_time = time.time()     # zacznij nową sesję od zera
        self._update_launcher_usage_display()      # odśwież etykiety

    def _prepare_chart_data(self):
        start_date, end_date = self._get_time_period_dates()
        if start_date is None or end_date is None:
            return None

        selected_display_view = self.stats_view_var.get()
        view_type = self.TRANSLATED_TO_STATS_VIEW.get(
            selected_display_view, "Playtime per Day"
        )
        logging.info(
            f"Przygotowywanie danych dla widoku: '{view_type}', "
            f"okres: {start_date} - {end_date}"
        )

        # ---------------------------------------------------------------
        # Daty w zakresie
        dates_in_period = [
            start_date + datetime.timedelta(days=i)
            for i in range((end_date - start_date).days + 1)
        ]
        # --- NOWE ZMIANY: upewnij się, że dzisiejsza data jest na liście
        today = datetime.date.today()
        if start_date <= today <= end_date and today not in dates_in_period:
            dates_in_period.append(today)
            dates_in_period.sort()
        # --- KONIEC NOWYCH ZMIAN
        # ---------------------------------------------------------------

        # Bufory zbiorcze
        daily_playtime_seconds = defaultdict(float)
        daily_games_set = defaultdict(set)
        per_game_playtime_seconds = defaultdict(float)
        selected_game_daily_playtime = defaultdict(float)
        genre_playtime_seconds = defaultdict(float)
        tag_playtime_seconds = defaultdict(float)
        game_launch_counts = defaultdict(int)
        game_session_durations = defaultdict(list)
        total_sessions_count = 0
        total_sessions_duration = 0.0

        # ---------------------------------------------------------------
        # Widok „wybrana gra”
        selected_game_name = None
        if view_type == "Playtime per Game (Selected)":
            selected_game_name = self.stats_game_var.get()
            if (
                not selected_game_name
                or selected_game_name not in self.games
            ):
                messagebox.showerror(
                    "Błąd Gry",
                    "Wybierz poprawną grę z listy.",
                    parent=self.stats_page_frame,
                )
                return None
        # ---------------------------------------------------------------

        # ---------------------------------------------------------------
        # Iteruj przez wszystkie gry i ich sesje
        for game_name, game_data in self.games.items():
            if (
                view_type == "Playtime per Game (Selected)"
                and game_name != selected_game_name
            ):
                continue  # pomiń, jeśli nie jest to wybrana gra

            game_genres = game_data.get("genres", [])
            game_tags = game_data.get("tags", [])

            for session in game_data.get("play_sessions", []):
                session_start_ts = session.get("start")
                session_end_ts = session.get("end")
                if not session_start_ts or not session_end_ts:
                    continue

                session_duration = session_end_ts - session_start_ts
                try:
                    session_start_date = datetime.date.fromtimestamp(
                        session_start_ts
                    )
                    session_date_end = datetime.date.fromtimestamp(
                        session_end_ts
                    )
                except ValueError as e_date:
                    logging.warning(
                        f"Nie można przekonwertować timestamp sesji na datę "
                        f"dla gry {game_name}: {e_date}"
                    )
                    continue  # pomiń tę sesję

                # Liczba uruchomień (sprawdzamy START)
                if start_date <= session_start_date <= end_date:
                    game_launch_counts[game_name] += 1

                # Podziel sesję na dni (dla wszystkich agregacji)
                current_check_date = start_date
                session_counted_for_avg = False
                while current_check_date <= end_date:
                    if (
                        session_start_date
                        <= current_check_date
                        <= session_date_end
                    ):
                        day_start_ts = time.mktime(
                            current_check_date.timetuple()
                        )
                        day_end_ts = day_start_ts + 86_400

                        overlap_start = max(session_start_ts, day_start_ts)
                        overlap_end = min(session_end_ts, day_end_ts)
                        duration_on_day = max(0, overlap_end - overlap_start)

                        if duration_on_day > 0:
                            # wszystkie podstawowe bufory
                            daily_playtime_seconds[
                                current_check_date
                            ] += duration_on_day
                            daily_games_set[current_check_date].add(
                                game_name
                            )
                            per_game_playtime_seconds[
                                game_name
                            ] += duration_on_day
                            for genre in game_genres:
                                genre_playtime_seconds[
                                    genre
                                ] += duration_on_day
                            for tag in game_tags:
                                tag_playtime_seconds[tag] += duration_on_day

                            if game_name == selected_game_name:
                                selected_game_daily_playtime[
                                    current_check_date
                                ] += duration_on_day

                            # średnia długość sesji
                            if (
                                not session_counted_for_avg
                                and start_date
                                <= session_start_date
                                <= end_date
                            ):
                                game_session_durations[game_name].append(
                                    session_duration
                                )
                                total_sessions_duration += session_duration
                                total_sessions_count += 1
                                session_counted_for_avg = True

                    current_check_date += datetime.timedelta(days=1)
        # ---------------------------------------------------------------

        # ---------------------------------------------------------------
        # --- NOWE ZMIANY: słownik czasu spędzonego tylko w launcherze ---
        launcher_usage_seconds = defaultdict(float)
        for iso_date, secs in self.local_settings.get(
            "launcher_daily_usage_seconds", {}
        ).items():
            try:
                launcher_usage_seconds[
                    datetime.date.fromisoformat(iso_date)
                ] += secs
            except ValueError:
                logging.warning(
                    f"Zły klucz daty w launcher_daily_usage_seconds: {iso_date}"
                )

        # Dodaj trwającą sesję do dzisiejszego wpisu
        if start_date <= today <= end_date:
            launcher_usage_seconds[today] += (
                time.time() - self.launcher_start_time
            )
        # --- KONIEC NOWYCH ZMIAN
        # ---------------------------------------------------------------

        # ---------------------------------------------------------------
        # Struktura wynikowa
        chart_data = {
            "x_labels": [],
            "y_values": [],
            "details": None,
            "title": "",
            "y_label": "",
            "all_games_playtime": per_game_playtime_seconds,
        }
        # ---------------------------------------------------------------

        # ---------------------------------------------------------------
        # Wypełnianie chart_data dla poszczególnych widoków
        if view_type == "Playtime per Day":
            chart_data["title"] = (
                f"Czas gry dziennie ({start_date:%Y-%m-%d} – {end_date:%Y-%m-%d})"
            )
            chart_data["y_label"] = "Czas gry (godziny)"
            for dt in dates_in_period:
                chart_data["x_labels"].append(dt.strftime("%m-%d"))
                chart_data["y_values"].append(
                    round(daily_playtime_seconds[dt] / 3600, 2)
                )

        elif view_type == "Games Played per Day":
            chart_data["title"] = (
                f"Liczba unikalnych gier dziennie "
                f"({start_date:%Y-%m-%d} – {end_date:%Y-%m-%d})"
            )
            chart_data["y_label"] = "Liczba gier"
            chart_data["details"] = daily_games_set
            for dt in dates_in_period:
                chart_data["x_labels"].append(dt.strftime("%m-%d"))
                chart_data["y_values"].append(len(daily_games_set[dt]))

        elif view_type == "Playtime per Game":
            chart_data["title"] = (
                f"Łączny czas gry per gra "
                f"({start_date:%Y-%m-%d} – {end_date:%Y-%m-%d})"
            )
            chart_data["y_label"] = "Czas gry (godziny)"
            sorted_games = sorted(
                per_game_playtime_seconds.items(),
                key=lambda item: item[1],
                reverse=True,
            )[:20]
            for game_name, seconds in sorted_games:
                if seconds > 0:
                    chart_data["x_labels"].append(game_name)
                    chart_data["y_values"].append(round(seconds / 3600, 2))

        elif view_type == "Playtime per Game (Selected)" and selected_game_name:
            chart_data["title"] = (
                f"Czas gry dla '{selected_game_name}' dziennie "
                f"({start_date:%Y-%m-%d} – {end_date:%Y-%m-%d})"
            )
            chart_data["y_label"] = "Czas gry (godziny)"
            for dt in dates_in_period:
                chart_data["x_labels"].append(dt.strftime("%m-%d"))
                chart_data["y_values"].append(
                    round(selected_game_daily_playtime[dt] / 3600, 2)
                )

        elif view_type == "Playtime by Genre (Pie)":
            chart_data["title"] = (
                f"Udział gatunków w czasie gry "
                f"({start_date:%Y-%m-%d} – {end_date:%Y-%m-%d})"
            )
            chart_data["y_label"] = ""
            sorted_genres = sorted(
                genre_playtime_seconds.items(),
                key=lambda item: item[1],
                reverse=True,
            )
            limit = 8
            top_genres = sorted_genres[:limit]
            other_seconds = sum(item[1] for item in sorted_genres[limit:])

            chart_data["x_labels"] = [g for g, _ in top_genres]
            chart_data["y_values"] = [
                round(sec / 3600, 2) for _, sec in top_genres
            ]
            if other_seconds > 0:
                chart_data["x_labels"].append("Inne")
                chart_data["y_values"].append(round(other_seconds / 3600, 2))

        elif view_type == "Most Launched Games":
            chart_data["title"] = (
                f"Najczęściej uruchamiane gry "
                f"({start_date:%Y-%m-%d} – {end_date:%Y-%m-%d})"
            )
            chart_data["y_label"] = "Liczba uruchomień"
            sorted_launches = sorted(
                game_launch_counts.items(),
                key=lambda item: item[1],
                reverse=True,
            )[:20]
            for game_name, count in sorted_launches:
                if count > 0:
                    chart_data["x_labels"].append(game_name)
                    chart_data["y_values"].append(count)

        # --- NOWE ZMIANY: widok „Czas w launcherze dziennie” -------------
        elif view_type == "Launcher Usage per Day":
            chart_data["title"] = (
                f"Czas w launcherze dziennie "
                f"({start_date:%Y-%m-%d} – {end_date:%Y-%m-%d})"
            )
            chart_data["y_label"] = "Czas (godziny)"
            for dt in dates_in_period:
                chart_data["x_labels"].append(dt.strftime("%m-%d"))
                chart_data["y_values"].append(
                    round(launcher_usage_seconds[dt] / 3600, 2)
                )
        # --- KONIEC NOWYCH ZMIAN ----------------------------------------

        elif view_type == "Average Session Time":
            chart_data["title"] = (
                f"Średni czas sesji per gra "
                f"({start_date:%Y-%m-%d} – {end_date:%Y-%m-%d})"
            )
            chart_data["y_label"] = "Średni czas (minuty)"
            avg_session_times = {
                g: (sum(durs) / len(durs)) / 60
                for g, durs in game_session_durations.items()
                if durs
            }
            sorted_avg = sorted(
                avg_session_times.items(), key=lambda item: item[1], reverse=True
            )[:20]
            for game_name, minutes in sorted_avg:
                if minutes > 0:
                    chart_data["x_labels"].append(game_name)
                    chart_data["y_values"].append(round(minutes, 1))

        # ---------------------------------------------------------------
        logging.info(
            f"Przygotowano dane dla '{view_type}': "
            f"X={len(chart_data['x_labels'])}, Y={len(chart_data['y_values'])}"
        )
        return chart_data


    # --- NOWA METODA ---
# W klasie GameLauncher

    def format_play_time(self, seconds):
        """Formatuje sekundy na czytelny string (h m) lub (m)."""
        if seconds < 60: # Mniej niż minuta
             # Możemy pokazać sekundy lub "< 1m"
             # return f"{int(seconds)}s"
             return "< 1m"
        elif seconds < 3600: # Mniej niż godzina, ale co najmniej minuta
             minutes = int(seconds // 60)
             return f"{minutes}m"
        else: # Co najmniej godzina
             hours = int(seconds // 3600)
             minutes = int((seconds % 3600) // 60)
             return f"{hours}h {minutes}m"

    def _generate_matplotlib_figure(self, chart_data, view_type_display):
        view_type = self.TRANSLATED_TO_STATS_VIEW.get(view_type_display, "Playtime per Day")
        active_theme_name = self.settings.get('theme', 'Dark')
        all_themes = self.get_all_available_themes()
        theme_def = all_themes.get(active_theme_name, THEMES.get('Dark', {}))

        if not chart_data or not chart_data["x_labels"] or not any(y > 0 for y in chart_data["y_values"]):
            # ... (kod zwracania pustej figury) ...
            fig = Figure(figsize=(6, 4), dpi=100); fig.patch.set_facecolor(theme_def.get('background', '#1e1e1e'))
            ax = fig.add_subplot(111); ax.set_facecolor(theme_def.get('entry_background', '#2e2e2e'))
            ax.text(0.5, 0.5, "Brak danych...", horizontalalignment='center', verticalalignment='center', transform=ax.transAxes, color=theme_def.get('foreground', 'white'))
            ax.spines['top'].set_visible(False); ax.spines['right'].set_visible(False)
            ax.spines['bottom'].set_visible(False); ax.spines['left'].set_visible(False)
            ax.tick_params(axis='x', colors='none'); ax.tick_params(axis='y', colors='none')
            return fig


        fig = Figure(figsize=(6, 4), dpi=100, facecolor=theme_def.get('background', '#1e1e1e'))
        ax = fig.add_subplot(111)
        ax.set_facecolor(theme_def.get('entry_background', '#2e2e2e'))

        x_labels = chart_data["x_labels"]
        y_values = chart_data["y_values"]
        title = chart_data["title"]
        y_label = chart_data["y_label"]

        if view_type == "Playtime by Genre (Pie)":
            colors = plt.cm.Paired(range(len(x_labels)))
            wedges, texts, autotexts = ax.pie(
                y_values, labels=None, autopct='%1.1f%%', startangle=90, colors=colors,
                wedgeprops={'edgecolor': theme_def.get('background', '#1e1e1e'), 'linewidth': 0.5}
            )
            plt.setp(autotexts, size=8, weight="bold", color=get_contrast_color(theme_def.get('background', '#1e1e1e')))

            # --- ZMIANA: Ustawienie koloru tytułu legendy ---
            # Najpierw utwórz legendę bez koloru w title_fontproperties
            legend = ax.legend(wedges, [f"{l} ({v:.1f}h)" for l, v in zip(x_labels, y_values)],
                      title="Gatunki", loc="center left", bbox_to_anchor=(1, 0, 0.5, 1), fontsize=8,
                      labelcolor=theme_def.get('foreground', 'white'),
                      facecolor=theme_def.get('entry_background', '#2e2e2e'),
                      edgecolor=theme_def.get('tree_heading', '#3e3e3e'),
                      # Usuń 'color' z title_fontproperties
                      title_fontproperties={'weight':'bold', 'size':'9'}
                     )
            # Następnie ustaw kolor tytułu na obiekcie legendy
            if legend.get_title(): # Sprawdź, czy tytuł istnieje
                legend.get_title().set_color(theme_def.get('foreground', 'white'))
            # --- KONIEC ZMIANY ---

            ax.set_title(title, color=theme_def.get('foreground', 'white'), fontsize=12, pad=20)
        else:  # Wykres słupkowy
            # --- ZMIANA: Pobierz kolor słupków i osi z theme_def ---
            bar_color = getattr(self, 'stats_bar_color', '#0078d7') # Domyślny niebieski
            axis_color = theme_def.get('chart_axis_color', 'grey') # Domyślny szary
            # --- KONIEC ZMIANY ---

            bars = ax.bar(x_labels, y_values, color=bar_color) # Użyj bar_color

            label_texts = []
            # --- NOWE ZMIANY: etykiety również dla „Launcher Usage per Day” ---
            # dodać nowy widok do listy:
            if view_type in [
                "Playtime per Day",
                "Playtime per Game",
                "Playtime per Game (Selected)",
                "Launcher Usage per Day",           #  <-- NOWE
            ]:
                label_texts = [
                    self.format_play_time(val * 3600) for val in y_values
                ]
                label_texts = [
                    text if y_values[i] * 3600 >= 1 else ""
                    for i, text in enumerate(label_texts)
                ]
            # --- KONIEC NOWYCH ZMIAN ---
                
            # --- KONIEC ZMIANY ---
            elif view_type == "Games Played per Day":
                label_texts = [f"{int(val):d}" for val in y_values]
                label_texts = [text if int(text) > 0 else "" for text in label_texts] # Ukryj etykiety 0
            elif view_type == "Most Launched Games":
                label_texts = [f"{int(val):d}" for val in y_values]
                label_texts = [text if int(text) > 0 else "" for text in label_texts] # Ukryj etykiety 0
            elif view_type == "Average Session Time":
                # Średni czas jest już w minutach, formatujemy go
                label_texts = [f"{val:.0f}m" if val >= 1 else "< 1m" for val in y_values] # Pokaż minuty bez miejsc po przecinku lub < 1m
                label_texts = [text if y_values[i] > 0 else "" for i, text in enumerate(label_texts)] # Ukryj etykiety 0
            else: # Wykres kołowy lub nieznany - nie potrzebuje etykiet słupków
                label_texts = [str(val) for val in y_values]

            # Zastosuj etykiety (tylko jeśli nie jest to wykres kołowy)
            if view_type != "Playtime by Genre (Pie)":
                # --- ZMIANA: Sprawdź, czy bars istnieje przed wywołaniem bar_label ---
                if 'bars' in locals(): # Sprawdź, czy zmienna bars została utworzona
                    ax.bar_label(bars, labels=label_texts, padding=3, color=theme_def.get('foreground', 'white'), fontsize=8)
                # --- KONIEC ZMIANY ---

            # Ustawienia osi i tytułu
            ax.set_title(title, color=theme_def.get('foreground', 'white'), fontsize=12)
            ax.set_ylabel(y_label, color=theme_def.get('foreground', 'white'), fontsize=10)
            ax.tick_params(axis='y', colors=theme_def.get('foreground', 'white'), labelsize=8)
            ax.tick_params(axis='x', colors=theme_def.get('foreground', 'white'), labelsize=8, rotation=45, pad=5)
            plt.setp(ax.get_xticklabels(), ha="right")

            # Siatka i ramki
            ax.yaxis.grid(True, linestyle='--', which='major', color='grey', alpha=0.25)
            ax.set_axisbelow(True)
            ax.spines['top'].set_visible(False); ax.spines['right'].set_visible(False)
            # --- ZMIANA: Użyj axis_color ---
            ax.spines['bottom'].set_color(axis_color)
            ax.spines['left'].set_color(axis_color)
            # --- KONIEC ZMIANY ---

        fig.tight_layout(rect=[0, 0, 0.85, 1] if view_type == "Playtime by Genre (Pie)" else None)

        return fig
    # --- KONIEC NOWEJ METODY ---

    # --- NOWA METODA: Odświeżanie wykresu (wywoływana z przycisku) ---
    def _on_refresh_stats_threaded(self):
        """Uruchamia przygotowanie danych i generowanie wykresu w tle."""
        # Pokaż jakąś informację o ładowaniu
        if hasattr(self, '_last_figure_canvas'):
             # Na razie proste - usuń stary wykres
             if self._last_figure_canvas and self._last_figure_canvas.get_tk_widget().winfo_exists():
                  self._last_figure_canvas.get_tk_widget().destroy()
             if hasattr(self, 'chart_info_label') and self.chart_info_label.winfo_exists():
                 self.chart_info_label.pack(expand=True) # Pokaż "ładowanie"
                 self.chart_info_label.config(text="Generowanie wykresu...")
        self.root.update_idletasks() # Wymuś aktualizację UI

        # Uruchom wątek
        self.stats_queue = queue.Queue() # Kolejka do komunikacji z wątkiem
        stats_thread = threading.Thread(target=self._generate_stats_in_thread, daemon=True)
        stats_thread.start()
        # Zacznij sprawdzać kolejkę
        self.root.after(100, self._check_stats_queue)

    def _generate_stats_in_thread(self):
        """Funkcja wykonywana w osobnym wątku."""
        try:
            chart_data = self._prepare_chart_data()
            if chart_data:
                view_type = self.stats_view_var.get() # Pobierz typ widoku
                figure = self._generate_matplotlib_figure(chart_data, view_type)
                # Zapisz dane potrzebne do interakcji (np. dla kliknięcia)
                self._current_chart_data = chart_data # Zapisz pełne dane
                self.stats_queue.put({"success": True, "figure": figure})
            else:
                # Błąd w przygotowaniu danych (np. zły zakres dat)
                self.stats_queue.put({"success": False, "error": "Błąd podczas przygotowywania danych."})
        except Exception as e:
            logging.exception("Błąd w wątku generowania statystyk.")
            self.stats_queue.put({"success": False, "error": str(e)})

    def _check_stats_queue(self):
        """Sprawdza kolejkę i aktualizuje wykres w głównym wątku."""
        try:
            result = self.stats_queue.get_nowait()
            if result["success"]:
                self._update_stats_chart(result["figure"])
            else:
                # Pokaż błąd
                if hasattr(self, 'chart_info_label') and self.chart_info_label.winfo_exists():
                    self.chart_info_label.config(text=f"Błąd:\n{result.get('error', 'Nieznany błąd')}")
                else: # Fallback
                     messagebox.showerror("Błąd Statystyk", f"Nie można wygenerować wykresu:\n{result.get('error', 'Nieznany błąd')}", parent=self.stats_page_frame)
        except queue.Empty:
            # Kolejka pusta, sprawdź ponownie później
            self.root.after(100, self._check_stats_queue)
        except Exception as e:
             logging.exception("Błąd podczas sprawdzania kolejki statystyk.")
             if hasattr(self, 'chart_info_label') and self.chart_info_label.winfo_exists():
                 self.chart_info_label.config(text=f"Błąd aktualizacji:\n{e}")

    def _update_stats_chart(self, figure):
        """Osadza wygenerowaną figurę Matplotlib w Tkinter."""
        if not hasattr(self, 'chart_container') or not self.chart_container.winfo_exists():
            logging.warning("Próba aktualizacji wykresu, ale kontener nie istnieje.")
            return

        # Usuń starą etykietę informacyjną lub poprzedni wykres
        if hasattr(self, 'chart_info_label') and self.chart_info_label.winfo_exists():
            self.chart_info_label.pack_forget()
        if hasattr(self, '_last_figure_canvas') and self._last_figure_canvas and self._last_figure_canvas.get_tk_widget().winfo_exists():
            self._last_figure_canvas.get_tk_widget().destroy()

        # Osadź nową figurę
        canvas = FigureCanvasTkAgg(figure, master=self.chart_container)
        canvas.draw()
        widget = canvas.get_tk_widget()
        widget.pack(fill=tk.BOTH, expand=True)
        self._last_figure_canvas = canvas # Zapisz referencję

        # Dodaj obsługę kliknięcia (jeśli to odpowiedni wykres)
        # --- ZMIANA: Obsługa kliknięcia i detali ---
        view_type = self.TRANSLATED_TO_STATS_VIEW.get(self.stats_view_var.get()) # Pobierz klucz techniczny

        # Ukryj ramkę detali dla widoków, które jej nie używają
        if view_type not in ["Games Played per Day", "Playtime per Day"]:
             if hasattr(self, 'details_frame') and self.details_frame.winfo_ismapped():
                  self.details_frame.grid_remove()
                  if hasattr(self, 'chart_container') and self.chart_container.winfo_exists():
                      self.chart_container.master.columnconfigure(0, weight=1)
                      self.chart_container.master.columnconfigure(1, weight=0)

        # Dodaj obsługę kliknięcia tylko dla "Games Played per Day"
        # Usuń poprzednie bindowania, jeśli były
        if hasattr(self, '_chart_click_cid') and self._chart_click_cid:
             try: canvas.mpl_disconnect(self._chart_click_cid)
             except Exception: pass # Ignoruj błędy przy rozłączaniu
             self._chart_click_cid = None

        if view_type == "Games Played per Day" and self._current_chart_data and self._current_chart_data.get("details"):
             self._chart_click_cid = canvas.mpl_connect('button_press_event', self._on_chart_click) # Zapisz ID połączenia
        # --- KONIEC ZMIANY ---

    # --- NOWA METODA ---
    def _show_total_playtime_details(self):
        """Wyświetla listę gier i ich łączny czas gry w wybranym okresie."""
        if not hasattr(self, '_current_chart_data') or not self._current_chart_data:
            logging.warning("Brak danych wykresu do pokazania szczegółów czasu gry.")
            return
        if not hasattr(self, 'details_tree') or not self.details_tree.winfo_exists():
             return

        all_games_playtime = self._current_chart_data.get("all_games_playtime")
        if not all_games_playtime:
             messagebox.showinfo("Brak Danych", "Brak zarejestrowanego czasu gry w wybranym okresie.", parent=self.stats_page_frame)
             if self.details_frame.winfo_ismapped():
                  self.details_frame.grid_remove()
                  self.chart_container.master.columnconfigure(0, weight=1)
                  self.chart_container.master.columnconfigure(1, weight=0)
             return

        self.details_frame.grid(row=0, column=1, sticky="nsew", padx=(5, 0))
        # --- NOWE ZMIANY: włącz auto‑skalowanie tabelki ---
        self._bind_details_resize()
        # --- KONIEC NOWYCH ZMIAN ---
        self.chart_container.master.columnconfigure(0, weight=2) # Zmniejszamy wagę wykresu
        self.chart_container.master.columnconfigure(1, weight=1) # Dajemy więcej wagi detalom

        self.details_tree.heading("Col1", text="Nazwa Gry")
        self.details_tree.heading("Col2", text="Czas w okresie")

        # --- ZMIANA: Zwiększ szerokość kolumny "Nazwa Gry" ---
        self.details_tree.column("Col1", anchor="w", width=200) # Zwiększono z 150 na np. 200 lub więcej
        # --- KONIEC ZMIANY ---
        # --- ZMIANA: Zwiększ szerokość kolumny czasu ---
        self.details_tree.column("Col2", anchor="e", width=150, stretch=False) # Zwiększono z 80 na np. 100
        # --- KONIEC ZMIANY ---

        self.details_tree.delete(*self.details_tree.get_children())
        sorted_games = sorted(all_games_playtime.items(), key=lambda item: item[1], reverse=True)

        for game_name, seconds in sorted_games:
            if seconds > 0.1:
                time_str = self.format_play_time(seconds)
                self.details_tree.insert("", "end", values=(game_name, time_str))

    # --- NOWA METODA ---
    def show_music_page(self):
        """Pokazuje stronę odtwarzacza muzyki, tworząc ją przy pierwszym użyciu."""
        self._hide_library_components() # Ukryj elementy biblioteki, jeśli były widoczne

        # Leniwe tworzenie instancji strony muzyki
        if self.music_player_page_instance is None:
            logging.info("Tworzenie instancji MusicPlayerPage po raz pierwszy.")
            self.music_player_page_instance = MusicPlayerPage(self.music_page_frame, self)
        else:
             # Opcjonalnie: odśwież playlistę lub inne dane, jeśli strona już istnieje
             # np. self.music_player_page_instance._refresh_playlist_display()
             pass

        self.music_page_frame.grid() # Upewnij się, że główna ramka strony jest widoczna
        self.music_page_frame.tkraise()
        self.current_frame = self.music_page_frame
        # --- ZMIANA ---
        self.current_section = "Przegląda Muzykę" # Lub "Odtwarzacz Muzyki"
        self._update_discord_status(status_type="browsing", activity_details=self.current_section)
        self._update_overlay_regularly() # Uruchom/kontynuuj aktualizację overlay'a
        # --- KONIEC ZMIANY ---

    def _on_chart_click(self, event):
        """Obsługuje kliknięcie na wykresie (np. na słupku)."""
        if event.inaxes is None: return # Kliknięcie poza obszarem osi

        ax = event.inaxes # Oś, na której kliknięto
        # Sprawdź, czy kliknięto na słupek
        clicked_bar = None
        for bar in ax.patches: # ax.patches zawiera słupki
            contains, _ = bar.contains(event)
            if contains:
                 clicked_bar = bar
                 break

        if clicked_bar and self._current_chart_data:
             # Znajdź indeks klikniętego słupka
             try:
                 bar_index = ax.patches.index(clicked_bar)
                 if 0 <= bar_index < len(self._current_chart_data["x_labels"]):
                      # Pobierz datę odpowiadającą słupkowi (zakładamy, że x_labels to daty 'MM-DD')
                      date_str_short = self._current_chart_data["x_labels"][bar_index]
                      # Znajdź pełną datę w `details` (klucze to obiekty datetime.date)
                      clicked_date = None
                      start_date, end_date = self._get_time_period_dates() # Pobierz zakres do iteracji
                      if start_date and end_date:
                           temp_date = start_date
                           while temp_date <= end_date:
                               if temp_date.strftime('%m-%d') == date_str_short:
                                   clicked_date = temp_date
                                   break
                               temp_date += datetime.timedelta(days=1)

                      if clicked_date and self._current_chart_data.get("details"):
                           games_set = self._current_chart_data["details"].get(clicked_date, set())
                           logging.info(f"Kliknięto na słupek dla daty {clicked_date}. Gry: {games_set}")
                           self._show_daily_games_details(games_set)

             except ValueError:
                  logging.warning("Nie można znaleźć indeksu klikniętego słupka.")
             except Exception as e:
                  logging.exception(f"Błąd podczas obsługi kliknięcia na wykresie: {e}")


    def _show_daily_games_details(self, games_set):
         """Wyświetla listę gier dla wybranego dnia w Treeview."""
         if not hasattr(self, 'details_tree') or not self.details_tree.winfo_exists():
              return

         self.details_frame.grid(row=0, column=1, sticky="nsew", padx=(5, 0))
         self.chart_container.master.columnconfigure(0, weight=2) # Mniej miejsca dla wykresu
         self.chart_container.master.columnconfigure(1, weight=1) # Więcej dla detali

         # --- ZMIANA: Ustaw nagłówki i szerokości kolumn ---
         # Ukryj drugą kolumnę, bo nie jest potrzebna
         self.details_tree["columns"] = ("Col1",) # Pokaż tylko pierwszą kolumnę
         self.details_tree.heading("Col1", text="Gry Uruchomione Tego Dnia")
         self.details_tree.column("Col1", anchor="w", width=250) # Ustaw szerokość
         # --- KONIEC ZMIANY ---

         self.details_tree.delete(*self.details_tree.get_children())
         if not games_set:
             self.details_tree.insert("", "end", values=("(Brak gier tego dnia)",))
         else:
             for game_name in sorted(list(games_set), key=str.lower):
                 self.details_tree.insert("", "end", values=(game_name,))

    def get_all_tags(self):
        """Zbiera unikalne tagi ze wszystkich gier."""
        all_tags = set()
        for game_data in self.games.values():
            tags = game_data.get("tags", [])
            if isinstance(tags, list): # Upewnij się, że to lista
                 all_tags.update(tag.strip() for tag in tags if tag.strip())
        return sorted(list(all_tags), key=str.lower) # Sortuj alfabetycznie, ignorując wielkość liter

    # --- NOWA METODA: Czas bieżącej sesji ---
    def _update_current_session_time_display(self):
        """Aktualizuje etykietę z czasem trwania bieżącej sesji launchera (co sekundę)."""
        if hasattr(self, 'launcher_usage_label_home') and self.launcher_usage_label_home.winfo_exists():
            current_session_seconds = time.time() - self.launcher_start_time

            # Proste formatowanie h:m:s dla bieżącej sesji
            hours, rem = divmod(current_session_seconds, 3600)
            minutes, seconds = divmod(rem, 60)
            time_str = f"{int(hours):02d}:{int(minutes):02d}:{int(seconds):02d}"

            self.launcher_usage_label_home.config(text=f"Czas sesji: {time_str}")

        # Zaplanuj następne wywołanie
        if hasattr(self, 'root') and self.root.winfo_exists():
            self.root.after(1000, self._update_current_session_time_display) # Co sekundę
    # --- KONIEC NOWEJ METODY ---

    def update_tag_filter_options(self):
        """Aktualizuje listę dostępnych tagów w OptionMenu."""
        if not hasattr(self, 'tag_filter_menu') or not self.tag_filter_menu.winfo_exists():
            logging.warning("update_tag_filter_options: OptionMenu tagów nie istnieje, pomijam aktualizację.")
            return

        menu = self.tag_filter_menu["menu"]
        menu.delete(0, "end") # Wyczyść stare opcje

        available_tags = ["Wszystkie Tagi"] + self.get_all_tags() # Pobierz aktualne tagi

        current_filter = self.tag_filter_var.get()
        if current_filter not in available_tags:
             self.tag_filter_var.set("Wszystkie Tagi") # Wróć do domyślnej, jeśli tag zniknął

        # Dodaj nowe opcje do menu
        for tag in available_tags:
            menu.add_command(label=tag, command=tk._setit(self.tag_filter_var, tag, self.reset_and_update_grid))

    # Dodaj nową metodę:
    def reset_and_update_grid(self):
        """Resetuje paginację i odświeża siatkę."""
        self.reset_pagination()
        self.update_game_grid()
    def change_language(self, selected_language):
        self.settings["language"] = selected_language
        save_config(self.config)
        self.translator.set_language(selected_language)
        # Odśwież interfejs
        self.refresh_ui()

    def refresh_ui(self):
        logging.info("Odświeżanie interfejsu użytkownika...")
        
        # Strona główna jest tworzona za każdym razem, bo jest lekka
        self.create_sidebar()
        self.create_home_page() # Zawartość home_page musi być gotowa, gdy pokazywana jest Home.

        # Reszta stron jest tworzona leniwie i są domyślnie ukryte.
        # Ich refresh_ui() po prostu upewni się, że szkielet jest i nic nie robią, dopóki ich content nie jest załadowany.

        # Odśwież stronę Roadmapy, jeśli została już zainicjalizowana
        if self._roadmap_initialized and hasattr(self, 'roadmap_frame') and self.roadmap_frame.winfo_exists():
            self._populate_roadmap_and_archive_data()

        # Odśwież stronę Ustawień, jeśli została już zainicjalizowana
        # Tutaj nie ma osobnej metody do aktualizacji contentu settings po prostu wywołujemy
        # _create_settings_page_content, aby budować zawartość i ładować listy w przypadku ponownego wczytania backupu.
        # Jeśli _settings_initialized jest True, to ta funkcja odświeży.
        # W nowej strukturze _create_settings_page_content jest leniwie inicjowane,
        # a potem jego funkcje ładowania danych są wołane.
        if self._settings_initialized and hasattr(self, 'settings_page_frame') and self.settings_page_frame.winfo_exists():
            # Po backupie mogą zmienić się nazwy w config.json, więc warto odświeżyć listy.
            self.load_scan_folders_list(); self.populate_rss_management_frame()
            self.load_ignored_folders(); self.load_screenshot_ignored_folders()
            self._load_emulators_list(); self._load_custom_themes_list()
            self._load_and_display_settings_avatar() # Refresh avatar if displayed

        # Odśwież elementy biblioteki (menu filtrów/grup) TYLKO jeśli header (nagłówek biblioteki) został już stworzony.
        # Inicjalizacja nagłówka biblioteki (i tym samym stworzenie self.filter_menu, self.tag_filter_menu itd.)
        # jest teraz lazy w show_library().
        # Upewnimy się, że nagłówek biblioteki (a w nim menu filtrów) istnieje, zanim spróbujemy je aktualizować.
        # `self._library_initialized` będzie ustawiane na `True` dopiero po zbudowaniu nagłówka i siatki.
        # Także sprawdzamy istnienie 'self.filter_menu'.
        # --- NOWE ZMIANY ---
        if self._library_initialized and hasattr(self, 'filter_menu') and self.filter_menu.winfo_exists():
             self.update_filter_group_menu()
             self.update_tag_filter_options()
             self.update_genre_menu()
             self.reset_and_update_grid() # Odśwież bibliotekę
        # --- KONIEC NOWYCH ZMIAN ---

        # Opcjonalnie: Zastosuj ponownie czcionkę i motyw, jeśli mogły się zmienić w backupie
        theme_name_from_settings = self.settings.get("theme", "Dark")
        theme_def_to_apply = self.get_all_available_themes().get(theme_name_from_settings, THEMES["Dark"])
        self.apply_theme(theme_def_to_apply)
        self.apply_font_settings()

        logging.info("Zakończono odświeżanie interfejsu.")
        # Pokaż stronę główną po odświeżeniu
        # self.show_home() # To wywołanie nie jest już konieczne, refresh_ui jest wołane już po deiconify()
        # show_home() zostało wywołane przez kod init


    def get_all_genres(self):
        genres = set()
        for game in self.games.values():
            genres.update(game.get("genres", []))
        genres.update(self.settings.get("custom_genres", []))
        return sorted(genres)

    def perform_update_check(self):
        """Wykonuje sprawdzanie aktualizacji i promuje je w GUI."""
        update_info = self.check_for_updates()
        if update_info.get("available"):
            self.root.after(0, lambda: self.prompt_update(update_info))


    def manage_genres(self):
        ManageGenresWindow(self.root, self)

    def _monitor_discord_connection(self):
        """Okresowo sprawdza i próbuje nawiązać połączenie z Discord RPC, jeśli jest włączone i nieaktywne."""
        logging.info("Uruchomiono wątek monitorujący połączenie Discord RPC.")
        while True:
            # Czekaj na początku pętli
            time.sleep(30) # Sprawdzaj co 30 sekund

            try:
                # Sprawdź, czy aplikacja nadal działa
                if not self.root.winfo_exists():
                    logging.info("Monitor RPC: Okno główne nie istnieje, zatrzymuję wątek.")
                    break

                # Pobierz stan checkboxa w głównym wątku, aby uniknąć błędów TclError
                is_enabled = False
                if hasattr(self, 'discord_rpc_enabled_var'):
                    try:
                        is_enabled = self.discord_rpc_enabled_var.get()
                    except tk.TclError:
                         logging.warning("Monitor RPC: Błąd odczytu discord_rpc_enabled_var (okno mogło zostać zamknięte).")
                         continue # Spróbuj ponownie w następnej iteracji

                # Sprawdź warunki w wątku monitorującym
                if is_enabled and not self.rpc and not self._is_connecting_rpc:
                    logging.info("Monitor RPC: Wykryto potrzebę połączenia. Zlecanie _start_discord_rpc głównemu wątkowi.")
                    # Wywołaj _start_discord_rpc w głównym wątku GUI
                    self.root.after(0, self._start_discord_rpc)

            except Exception as e:
                # Loguj błędy samego monitora, ale nie przerywaj pętli (chyba że to błąd krytyczny)
                logging.exception("Nieoczekiwany błąd w pętli monitorującej Discord RPC.")
                # Można dodać warunek zakończenia pętli przy pewnych błędach



    def _load_achievement_definitions(self):
        """Wczytuje definicje osiągnięć z pliku JSON."""
        definitions_file = "achievements_def.json"
        try:
            if os.path.exists(definitions_file):
                with open(definitions_file, "r", encoding="utf-8") as f:
                    self.achievement_definitions = json.load(f)
                    logging.info(f"Załadowano {len(self.achievement_definitions)} definicji osiągnięć.")
                    # Opcjonalnie: Walidacja struktury załadowanych danych
            else:
                logging.warning(f"Plik definicji osiągnięć '{definitions_file}' nie znaleziony.")
                self.achievement_definitions = [] # Użyj pustej listy, jeśli plik nie istnieje
        except json.JSONDecodeError as e:
            logging.error(f"Błąd odczytu pliku definicji osiągnięć: {e}")
            messagebox.showerror("Błąd Osiągnięć", f"Nie można wczytać definicji osiągnięć.\nBłąd: {e}")
            self.achievement_definitions = []
        except Exception as e:
            logging.exception("Nieoczekiwany błąd podczas ładowania definicji osiągnięć.")
            self.achievement_definitions = []

    def delete_group(self):
        # --- ZMIANA: Użyj filter_or_group_var ---
        selected_item = self.filter_or_group_var.get()

        # Sprawdź, czy wybrany element to grupa statyczna (a nie "Wszystkie Gry", separator lub filtr)
        if selected_item in self.groups:
            group_to_delete = selected_item
            # --- KONIEC ZMIANY ---
            confirm = messagebox.askyesno("Usuń Grupę Statyczną", f"Czy na pewno chcesz usunąć grupę '{group_to_delete}'?") # Zmień tytuł
            if confirm:
                # Opcjonalnie: zapytaj, co zrobić z grami w tej grupie
                del self.groups[group_to_delete]
                save_config(self.config)
                # --- ZMIANA: Zaktualizuj nowe menu i zresetuj wybór ---
                self.filter_or_group_var.set("Wszystkie Gry") # Wróć do widoku wszystkich
                self.update_filter_group_menu()
                # --- KONIEC ZMIANY ---
                self.reset_and_update_grid() # Odśwież siatkę
                messagebox.showinfo("Sukces", f"Grupa statyczna '{group_to_delete}' została usunięta.")
        elif selected_item == "Wszystkie Gry":
             messagebox.showwarning("Błąd", "Nie można usunąć grupy 'Wszystkie Gry'.")
        elif selected_item in self.config.get("saved_filters", {}):
             messagebox.showwarning("Błąd", f"'{selected_item}' to filtr zaawansowany, a nie grupa statyczna. Użyj 'Zarządzaj Filtrami'.")
        else:
             # Powinno obsłużyć też separatory lub inne nieoczekiwane wartości
             messagebox.showwarning("Błąd", f"Nie można usunąć wybranego elementu: '{selected_item}'. Wybierz grupę statyczną z listy.")


    def setup_key_bindings(self):
        self.root.bind_all('<Up>', self.focus_prev_widget)
        self.root.bind_all('<Down>', self.focus_next_widget)
        self.root.bind_all('<Left>', self.focus_prev_widget)
        self.root.bind_all('<Right>', self.focus_next_widget)
        self.root.bind_all('<Return>', self.activate_focused_widget)

    def focus_next_widget(self, event):
        event.widget.tk_focusNext().focus()
        return "break"

    def focus_prev_widget(self, event):
        event.widget.tk_focusPrev().focus()
        return "break"

    def activate_focused_widget(self, event):
        widget = self.root.focus_get()
        if isinstance(widget, ttk.Button):
            widget.invoke()
        elif isinstance(widget, ttk.Entry):
            widget.event_generate('<Return>')
        return "break"

    def upload_to_cloud(self):
        services = []
        if self.settings.get("cloud_service_google_drive"):
            services.append("Google Drive")
        if self.settings.get("cloud_service_github"):
            services.append("GitHub")
        if not services:
            messagebox.showwarning("Błąd", "Nie wybrano żadnej usługi chmurowej.")
            return

        # Uruchom operacje w osobnym wątku
        threading.Thread(target=self.upload_to_cloud_thread, args=(services,), daemon=True).start()

    def upload_to_cloud_thread(self, services):
        for service in services:
            if service == "Google Drive":
                self.do_upload_to_google_drive()
            elif service == "GitHub":
                self.do_upload_to_github()
        # Wskaźnik zakończenia
        self.progress_queue.put("DONE")

    # ------------------------------------------------------------------
    # ===  BIG-PICTURE / PAD-ONLY  =====================================
    # ------------------------------------------------------------------

    def _enter_big_picture_mode(self):
        if getattr(self, "big_picture_mode", False):
            return          # już włączone
        self.big_picture_mode = True
        logging.info("→ Włączono tryb Big-picture")
        # 1) większe kafelki
        self.local_settings["tiles_per_row"] = 3
        self.current_tile_width = 300
        # 2) powiększona domyślna czcionka
        ttk.Style(self.root).configure("TLabel", font=("Segoe UI", 11))
        ttk.Style(self.root).configure("Tile.TButton", font=("Segoe UI", 9))
        # 3) odśwież widok
        self.reset_and_update_grid()

    def _exit_big_picture_mode(self):
        if not getattr(self, "big_picture_mode", False):
            return
        self.big_picture_mode = False
        logging.info("← Wyłączono tryb Big-picture")
        self.local_settings["tiles_per_row"] = 5
        self.current_tile_width = 200
        ttk.Style(self.root).configure("TLabel", font=("Segoe UI", 9))
        ttk.Style(self.root).configure("Tile.TButton", font=("Segoe UI", 7))
        self.reset_and_update_grid()

    # ------------------------------------------------------------------
    def controller_listener(self):
        """
        Obsługuje nawigację padem (Xbox / PlayStation).
        ↑↓ = scroll (kółko), ←→ = fokus poziomo,
        A/✕ = Enter, B/○ = Back, Y/△ = Page Down, X/□ = Page Up
        """
        threshold = 10000
        pad_connected = False
        while True:
            try:
                events = get_gamepad()
                if not pad_connected:
                    pad_connected = True
                    self.root.after(0, self._enter_big_picture_mode)

                for ev in events:
                    # D-pad / lewy analog
                    if ev.code in ('ABS_HAT0X', 'ABS_X'):
                        if ev.state == -1 or ev.state < -threshold:
                            self.root.event_generate('<Left>')
                        elif ev.state == 1 or ev.state > threshold:
                            self.root.event_generate('<Right>')

                    elif ev.code in ('ABS_HAT0Y', 'ABS_Y'):
                        if ev.state == -1 or ev.state < -threshold:
                            # scroll w górę
                            if getattr(self, "canvas", None):
                                self.canvas.yview_scroll(-1, "units")
                        elif ev.state == 1 or ev.state > threshold:
                            # scroll w dół
                            if getattr(self, "canvas", None):
                                self.canvas.yview_scroll(1, "units")

                    # A (Xbox)  /  ✕ (PS)  =  Enter
                    elif ev.code == 'BTN_SOUTH' and ev.state == 1:
                        self.root.event_generate('<Return>')

                    # B (Xbox) / ○ (PS)  =  Back  → wracamy na stronę główną
                    elif ev.code == 'BTN_EAST' and ev.state == 1:
                        self.root.after(0, self.show_home)

                    # Y (Xbox) / △ (PS)  =  Page-Down (większy skok)
                    elif ev.code in ('BTN_NORTH', 'BTN_WEST') and ev.state == 1:
                        if getattr(self, "canvas", None):
                            self.canvas.yview_scroll(1, "pages")

                    # X (Xbox) / □ (PS)  =  Page-Up
                    elif ev.code in ('BTN_WEST', 'BTN_NORTH') and ev.state == 1:
                        if getattr(self, "canvas", None):
                            self.canvas.yview_scroll(-1, "pages")

                self.root.update_idletasks()

            except UnpluggedError:
                if pad_connected:
                    pad_connected = False
                    self.root.after(0, self._exit_big_picture_mode)
                time.sleep(1)

            except Exception as e:
                logging.error(f"Pad listener error: {e}")
                time.sleep(1)

    # ------------------------------------------------------------------
    # Zamieniamy domyślne metody focusa na wersję poziomą,
    # jeśli big-picture włączony.
    def focus_next_widget(self, event):
        if getattr(self, "big_picture_mode", False):
            # w poziomie → cały czas Right
            self.root.event_generate('<Right>')
        else:
            event.widget.tk_focusNext().focus()
        return "break"

    def focus_prev_widget(self, event):
        if getattr(self, "big_picture_mode", False):
            self.root.event_generate('<Left>')
        else:
            event.widget.tk_focusPrev().focus()
        return "break"



    def create_home_page(self):
        """Buduje stronę startową i podpina automatyczne skalowanie."""
        for w in self.home_frame.winfo_children():
            w.destroy()

        # ─── nagłówek ──────────────────────────────────────────
        head = ttk.Frame(self.home_frame)
        head.grid(row=0, column=0, sticky="ew", padx=10, pady=5) # Dodano padx/pady do head
        # --- NOWE ZMIANY: Dodanie awatara ---
        head.columnconfigure(0, weight=0) # Kolumna na awatar - stała szerokość
        head.columnconfigure(1, weight=1) # Kolumna na powitanie - rozciągliwa

        # --- ZMIANA: Pobierz i użyj zapisanego rozmiaru awatara ---
        avatar_s = self.local_settings.get("avatar_display_size", 48)
        avatar_size_home = (avatar_s, avatar_s)
        # Użyj odpowiedniej szerokości dla placeholdera Label
        avatar_label = ttk.Label(head, width=avatar_size_home[0]//8 if avatar_size_home[0] >= 48 else 6)
        # --- KONIEC ZMIANY ---
        avatar_label.grid(row=0, column=0, rowspan=3, padx=(5, 10), pady=5, sticky="w")

        avatar_path = self.user.get("avatar")
        if avatar_path and os.path.exists(avatar_path):
            try:
                with Image.open(avatar_path) as img:
                    # --- ZMIANA: Użyj avatar_size_home ---
                    img.thumbnail(avatar_size_home, resampling)
                    # --- KONIEC ZMIANY ---
                    avatar_photo = ImageTk.PhotoImage(img)
                    avatar_label.config(image=avatar_photo); avatar_label.image = avatar_photo
            except Exception as e: logging.error(f"... {e}"); avatar_label.config(text="Błąd", font=("Segoe UI", 7))
        else:
            # Opcjonalnie: Domyślny awatar, jeśli brak ścieżki lub pliku
            try:
                 default_avatar = Image.new('RGB', avatar_size, color='#444444')
                 draw = ImageDraw.Draw(default_avatar)
                 # Prosty inicjał lub symbol
                 username_initial = self.user.get("username", "G")[0].upper() if self.user.get("username") else "G"
                 try: font = ImageFont.truetype("arialbd.ttf", avatar_size[0]//2) # Pogrubiona czcionka
                 except IOError: font = ImageFont.load_default()
                 bbox = draw.textbbox((0, 0), username_initial, font=font)
                 text_w, text_h = bbox[2]-bbox[0], bbox[3]-bbox[1]
                 draw.text(((avatar_size[0]-text_w)//2, (avatar_size[1]-text_h)//2 - 2), username_initial, fill="white", font=font)
                 default_avatar_photo = ImageTk.PhotoImage(default_avatar)
                 avatar_label.config(image=default_avatar_photo)
                 avatar_label.image = default_avatar_photo
            except Exception as e_def:
                 logging.error(f"Nie można stworzyć domyślnego awatara: {e_def}")
                 avatar_label.config(text="Brak\navatara", font=("Segoe UI", 7))
        # --- KONIEC NOWYCH ZMIAN ---

        greetings = [
            f"Witaj, {self.user.get('username', 'Graczu')}!", # Użyj .get() dla bezpieczeństwa
            f"Co dzisiaj gramy, {self.user.get('username', 'Graczu')}?",
            f"Jak się masz, {self.user.get('username', 'Graczu')}?",
            f"Miło Cię widzieć, {self.user.get('username', 'Graczu')}!",
            f"Gotowy na nowe wyzwania, {self.user.get('username', 'Graczu')}?"
        ]
        # --- ZMIANA: Powitanie w kolumnie 1 ---
        ttk.Label(head, text=random.choice(greetings),
                font=("Helvetica", 14)).grid(row=0, column=1, sticky="w", pady=10) # Zmieniono kolumnę i sticky
        # --- KONIEC ZMIANY ---

        # --- ZMIANA: Etykiety czasu sesji i czasu łącznego ---
        # Etykieta czasu sesji
        self.launcher_usage_label_home = ttk.Label(head, text="Czas sesji: 00:00:00", font=("Segoe UI", 9), anchor="w")
        self.launcher_usage_label_home.grid(row=1, column=1, sticky="w", pady=(0, 0)) # Wiersz 1

        # Etykieta czasu łącznego
        self.total_launcher_usage_label_home = ttk.Label(head, text="Łączny czas: Ładowanie...", font=("Segoe UI", 9), anchor="w")
        self.total_launcher_usage_label_home.grid(row=2, column=1, sticky="w", pady=(0, 5)) # Wiersz 2
        # --- KONIEC ZMIANY ---
        # ─── część główna ─────────────────────────────────────
        body = ttk.Frame(self.home_frame)
        # ... (reszta metody create_home_page bez zmian) ...
        body.grid(row=1, column=0, sticky="nsew", padx=10, pady=10)
        self.home_frame.rowconfigure(1, weight=1)
        self.home_frame.columnconfigure(0, weight=1)
        body.columnconfigure((0, 1), weight=1)
        body.rowconfigure((0, 1), weight=1)
        self.recent_frame = ttk.LabelFrame(body, text="Ostatnio grane")
        self.recent_frame.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        self.random_frame = ttk.LabelFrame(body, text="Losowe gry")
        self.random_frame.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)
        self.stats_frame = ttk.Frame(body)
        self.stats_frame.grid(row=0, column=1, rowspan=2, sticky="nsew", padx=5, pady=5)
        self.stats_frame.columnconfigure(0, weight=1)
        self.stats_frame.rowconfigure((0, 1, 2), weight=1)
        self.create_time_stats(self.stats_frame, row=0, column=0)
        self.create_statistics(self.stats_frame)
        # --- ZMIANA: Wywołaj obie funkcje aktualizujące na końcu ---
        self.home_frame.bind("<Configure>", self._update_home_lists)
        self._update_home_lists()
        self._update_current_session_time_display() # Wywołaj raz na początku
        self._update_launcher_usage_display()     # Wywołaj raz na początku
        # --- KONIEC ZMIANY ---

    # --- NOWE ZMIANY (Auto‑dopasowanie tabelki Szczegóły) ----------------
    def _bind_details_resize(self):
        """Podpina <Configure> tylko raz – unikamy wielokrotnego bindowania."""
        if not getattr(self, "_details_resize_bound", False):
            self.details_frame.bind("<Configure>", self._on_details_frame_resize)
            self._details_resize_bound = True

    def _on_details_frame_resize(self, event):
        """
        Dynamicznie skaluje kolumny Treeview, aby zawsze mieściły się w oknie.
        Góra i dół statystyk NIEWZRUSZONE – zmieniamy jedynie szerokość kolumn.
        """
        try:
            # Całkowita szerokość ramki z tabelką (bez paska przewijania)
            total = self.details_frame.winfo_width()

            col2_w = 100                       # „Czas w okresie” – stałe ~100 px
            col1_w = max(150, total - col2_w - 20)   # 20 px zapasu na padding + scrollbar

            # Pierwsza kolumna rozciąga się, druga nie
            self.details_tree.column("Col1", width=col1_w, stretch=True,  anchor="w")
            self.details_tree.column("Col2", width=col2_w, stretch=False, anchor="e")
        except tk.TclError:
            # okno w trakcie niszczenia – ignorujemy
            pass
    # --- KONIEC NOWYCH ZMIAN --------------------------------------------    

    def create_statistics(self, parent):
        most_played_games = sorted(self.games.items(), key=lambda x: x[1].get('play_time', 0), reverse=True)
        num_most_played = min(10, len(most_played_games))  # Możesz zmienić 10 na dowolną liczbę
        frame = ttk.LabelFrame(parent, text="Statystyki Ogólne")
        frame.grid(row=3, column=0, padx=10, pady=10, sticky="nsew")

        # Najdłużej grane gry
        ttk.Label(frame, text="Najdłużej Grane Gry:", font=("Helvetica", 12, "bold")).grid(row=0, column=0, sticky="w")
        for idx, (game_name, game_data) in enumerate(most_played_games[:num_most_played]):
            play_time = self.format_play_time(game_data.get('play_time', 0))
            ttk.Label(frame, text=f"{idx + 1}. {game_name} - {play_time}").grid(row=idx + 1, column=0, sticky="w")
        # Możesz dodać więcej statystyk według potrzeb

    def _create_or_overwrite_autosave(self, game_name):
        """Tworzy lub nadpisuje folder _autosave w osobnym wątku z paskiem postępu."""
        game_data = self.games.get(game_name)
        if not game_data: return

        save_path = game_data.get("save_path")
        backup_base_path = os.path.join(GAMES_FOLDER, game_name)

        if not save_path or not os.path.isdir(save_path):
             logging.warning(f"Auto-zapis dla '{game_name}' pominięty: ścieżka '{save_path}' nieprawidłowa.")
             return

        autosave_dir = os.path.join(backup_base_path, "_autosave")

        # --- Uruchomienie kopiowania w wątku z oknem postępu ---
        try:
             # 1. Oblicz rozmiar/liczbę plików (w głównym wątku, może chwilę potrwać)
             total_size = 0
             total_files = 0
             for root, dirs, files in os.walk(save_path):
                 total_files += len(files)
                 # for file in files:
                 #     try: total_size += os.path.getsize(os.path.join(root, file))
                 #     except OSError: pass
             logging.info(f"Rozpoczynanie auto-zapisu dla '{game_name}'. Plików: {total_files}")

             # Jeśli nie ma plików do skopiowania
             if total_files == 0:
                  logging.info(f"Brak plików do skopiowania w '{save_path}'. Auto-zapis pominięty.")
                  # Można utworzyć pusty folder _autosave dla spójności
                  os.makedirs(autosave_dir, exist_ok=True)
                  return

             # 2. Pokaż okno postępu
             # Użyj istniejącej metody, jeśli obsługuje tryb deterministyczny
             self.show_progress_window(f"Tworzenie auto-zapisu dla {game_name}")
             self.progress_bar['maximum'] = total_files # Ustaw maksimum na liczbę plików
             self.progress_bar['value'] = 0
             self.progress_bar['mode'] = 'determinate'
             self.progress_label.config(text=f"0 / {total_files}")


             # 3. Uruchom wątek kopiujący
             copy_thread = threading.Thread(
                  target=self._copy_with_progress_thread,
                  args=(save_path, autosave_dir, total_files),
                  daemon=True
             )
             copy_thread.start()

             # 4. Monitoruj kolejkę postępu (jeśli używasz - w przeciwnym razie okno będzie statyczne)
             # Jeśli nie masz globalnej kolejki, możesz przekazać obiekt okna postępu do wątku
             # lub użyć dedykowanej kolejki dla tej operacji.
             # Na razie zakładam, że okno postępu aktualizuje się samo w wątku (prostsze).
             # Jeśli chcesz płynny progress bar, potrzebna będzie kolejka.
             # self.check_copy_progress_queue() # Przykładowa funkcja monitorująca kolejkę

        except Exception as e:
            logging.exception(f"Błąd przed rozpoczęciem kopiowania auto-zapisu dla '{game_name}': {e}")
            if hasattr(self, 'progress_window') and self.progress_window.winfo_exists():
                 self.progress_window.destroy()
            messagebox.showerror("Błąd Auto-Zapisu", f"Nie można rozpocząć auto-zapisu:\n{e}", parent=self.root)

    def _copy_with_progress_thread(self, src, dst, total_files):
         """Kopiuje pliki z src do dst, aktualizując okno postępu (działa w wątku)."""
         copied_files = 0
         os.makedirs(dst, exist_ok=True) # Upewnij się, że folder docelowy istnieje
         last_update_time = time.time()

         try:
              for root, dirs, files in os.walk(src):
                   # Utwórz odpowiadające podfoldery w miejscu docelowym
                   relative_path = os.path.relpath(root, src)
                   dest_root = os.path.join(dst, relative_path)
                   os.makedirs(dest_root, exist_ok=True)

                   for file in files:
                        source_file = os.path.join(root, file)
                        dest_file = os.path.join(dest_root, file)
                        try:
                             shutil.copy2(source_file, dest_file) # copy2 zachowuje metadane
                             copied_files += 1

                             # Aktualizuj UI tylko co jakiś czas lub co N plików, aby nie spowalniać
                             now = time.time()
                             if now - last_update_time > 0.1 or copied_files == total_files: # Aktualizuj co 0.1s lub na końcu
                                 # --- Aktualizacja UI musi być w głównym wątku! ---
                                 percent = int((copied_files / total_files) * 100) if total_files > 0 else 100
                                 progress_text = f"{copied_files} / {total_files}"
                                 # Użyj root.after do bezpiecznej aktualizacji GUI
                                 self.root.after(0, self._update_copy_progress_ui, percent, progress_text)
                                 last_update_time = now
                        except Exception as copy_e:
                             logging.error(f"Błąd kopiowania pliku {source_file} do {dest_file}: {copy_e}")
                             # Można zdecydować, czy kontynuować, czy przerwać

              logging.info(f"Zakończono kopiowanie auto-zapisu. Skopiowano {copied_files} plików.")
              # Zamknij okno postępu po zakończeniu (w głównym wątku)
              self.root.after(100, self._destroy_progress_window)

         except Exception as thread_e:
              logging.exception(f"Błąd w wątku kopiowania auto-zapisu: {thread_e}")
              # Zamknij okno postępu i pokaż błąd (w głównym wątku)
              error_msg = f"Błąd podczas tworzenia auto-zapisu:\n{thread_e}"
              self.root.after(0, lambda: (self._destroy_progress_window(), messagebox.showerror("Błąd Auto-Zapisu", error_msg, parent=self.root)))


    def _update_copy_progress_ui(self, percent, text):
         """Aktualizuje pasek postępu i etykietę (wywoływane przez root.after)."""
         if hasattr(self, 'progress_window') and self.progress_window.winfo_exists():
              if self.progress_bar['mode'] == 'indeterminate': # Zmień na deterministyczny, jeśli trzeba
                   self.progress_bar.stop()
                   self.progress_bar['mode'] = 'determinate'
              self.progress_bar['value'] = percent
              self.progress_label.config(text=text)
              #self.progress_window.update_idletasks() # Niekonieczne w root.after

    def _destroy_progress_window(self):
         """Bezpiecznie zamyka okno postępu."""
         if hasattr(self, 'progress_window') and self.progress_window.winfo_exists():
              self.progress_window.destroy()

    def monitor_game_sessions(self):
        """Monitoruje wszystkie gry i śledzi czas gry niezależnie od sposobu uruchomienia."""
        while True:
            active_game_names = list(self.games.keys())
            for game_name in active_game_names:
                if game_name not in self.games:
                    if game_name in self.tracking_games: del self.tracking_games[game_name]
                    continue

                if self.is_game_running(game_name):
                    if game_name not in self.tracking_games:
                        self.tracking_games[game_name] = time.time()
                        self.games[game_name]["last_played"] = time.time()
                        logging.info(f"Rozpoczęto śledzenie gry: {game_name}")
                else: # Gra nie jest uruchomiona
                    if game_name in self.tracking_games:
                        start_time = self.tracking_games.pop(game_name)
                        end_time = time.time()
                        elapsed = end_time - start_time
                        self.games[game_name]["play_time"] = self.games[game_name].get("play_time", 0) + elapsed
                        self.games[game_name].setdefault("play_sessions", []).append({'start': start_time, 'end': end_time})

                        roadmap_updated = False
                        for game in self.roadmap:
                            if game["game_name"] == game_name and game["status"] == "Planowana":
                                game["time_spent"] = game.get("time_spent", 0) + elapsed
                                roadmap_updated = True; break

                        save_config(self.config)
                        logging.info(f"Zakończono śledzenie gry: {game_name}, czas: {elapsed:.2f} sekund")
                        self._update_discord_status(status_type="idle")
                        self.root.after(0, self._update_button_on_game_close, game_name)
                        # --- NOWE: Wykonaj automatyczny zapis, jeśli włączony ---
                        if self.settings.get("auto_backup_on_exit", True): # Sprawdź ustawienie
                             # Wykonaj w tle, aby nie blokować GUI? Na razie synchronicznie.
                             self.root.after(10, lambda gn=game_name: self._create_or_overwrite_autosave(gn))
                        # --- KONIEC NOWEGO ---

                        self.root.after(150, lambda gn=game_name: self.prompt_checklist_update(gn)) # Opóźnienie dla checklisty
                        self.root.after(250, lambda gn=game_name: self.prompt_completion(gn)) # Jeszcze większe opóźnienie dla procentów
            # ...
            time.sleep(5)

    # --- NOWA METODA: Pytanie o aktualizację checklisty ---
    def prompt_checklist_update(self, game_name):
        """Sprawdza checklistę i pyta użytkownika, czy chce ją zaktualizować."""
        game_data = self.games.get(game_name)
        if not game_data: return

        checklist = game_data.get("checklist", [])
        # Sprawdź, czy lista istnieje i czy są na niej NIEUKOŃCZONE zadania
        has_pending_tasks = any(not item.get("done", False) for item in checklist)

        if checklist and has_pending_tasks: # Pytaj tylko, jeśli lista istnieje i ma coś do zrobienia
            logging.info(f"Gra '{game_name}' ma nieukończone zadania na checkliście.")
            if messagebox.askyesno(
                "Checklista Zadań",
                f"Zakończyłeś sesję w '{game_name}'.\nCzy chcesz teraz przejrzeć/zaktualizować checklistę zadań dla tej gry?",
                parent=self.root # Użyj głównego okna jako rodzica
            ):
                logging.info(f"Użytkownik chce otworzyć checklistę dla '{game_name}'.")
                self._show_game_details_and_select_tab(game_name, "Checklista")


    # --- NOWA METODA POMOCNICZA: Otwiera szczegóły i wybiera zakładkę ---
    def _show_game_details_and_select_tab(self, game_name, tab_text):
        """Otwiera (lub podnosi) okno szczegółów gry i aktywuje określoną zakładkę."""
        details_window = None
        details_title = f"Szczegóły Gry - {game_name}"

        # Sprawdź, czy okno już istnieje
        for widget in self.root.winfo_children():
             if isinstance(widget, tk.Toplevel) and widget.title() == details_title:
                 if isinstance(widget, GameDetailsWindow): # Upewnij się, że to właściwy typ okna
                      details_window = widget
                      break

        if details_window and details_window.winfo_exists():
             logging.debug(f"Okno szczegółów dla '{game_name}' już otwarte. Podnoszenie i zmiana zakładki.")
             details_window.lift()
             details_window.focus_force()
        else:
             logging.debug(f"Tworzenie nowego okna szczegółów dla '{game_name}', aby pokazać zakładkę '{tab_text}'.")
             details_window = GameDetailsWindow(self.root, self, game_name) # Utwórz nowe okno, jeśli nie ma

        # Wybierz zakładkę (po krótkiej chwili, aby UI zdążyło się zainicjować)
        if details_window and hasattr(details_window, 'notebook'):
             self.root.after(100, lambda dw=details_window, txt=tab_text: self._select_notebook_tab(dw, txt))
        else:
             logging.error("Nie można wybrać zakładki - okno szczegółów lub notebook nie istnieje.")

    def _select_notebook_tab(self, details_window, tab_text):
         """Pomocnicza funkcja do wybierania zakładki w Notebooku."""
         try:
              if details_window.winfo_exists(): # Sprawdź ponownie przed operacją
                   tab_id = None
                   for i, text in enumerate(details_window.notebook.tabs()):
                        if details_window.notebook.tab(i, "text") == tab_text:
                             tab_id = text # tabs() zwraca identyfikatory widgetów, nie tekst
                             break
                   if tab_id:
                        details_window.notebook.select(tab_id)
                        logging.debug(f"Wybrano zakładkę '{tab_text}'.")
                   else:
                        logging.warning(f"Nie znaleziono zakładki o tekście '{tab_text}'.")
         except tk.TclError as e:
              logging.warning(f"Błąd TclError podczas wybierania zakładki '{tab_text}': {e}")
         except Exception as e:
              logging.exception(f"Nieoczekiwany błąd podczas wybierania zakładki: {e}")

    # Dodaj nową metodę pomocniczą:
    def _update_button_on_game_close(self, game_name):
        """Aktualizuje przycisk gry do stanu 'Uruchom' (z ikoną i tooltipem) po jej zamknięciu."""
        if game_name in self._launch_buttons:
            button = self._launch_buttons[game_name]
            if button.winfo_exists():
                 game_data = self.games.get(game_name, {})
                 profiles = game_data.get("launch_profiles", [])
                 default_profile = profiles[0] if profiles else {"name": "Uruchom", "arguments": ""}

                 if len(profiles) == 1 and default_profile.get("name", "").lower() == "default":
                     tooltip_text = "Uruchom"
                 else:
                     tooltip_text = f"Uruchom: {default_profile.get('name', 'Profil')}"

                 play_icon_tk = self._button_icons.get("play_btn")
                 default_launch_command = lambda p=default_profile: self.launch_game(game_name, profile=p)

                 if play_icon_tk:
                      button.config(image=play_icon_tk, style="Green.TButton", command=default_launch_command)
                      # --- ZMIANA: Aktualizuj Tooltip ---
                      if hasattr(button, 'tooltip') and button.tooltip:
                           button.tooltip.update_text(tooltip_text)
                      # --- KONIEC ZMIANY ---
                 else:
                      button.config(image="", text="Uruchom", style="Green.TButton", command=default_launch_command)
                      # --- ZMIANA: Aktualizuj/Dodaj Tooltip ---
                      if hasattr(button, 'tooltip') and button.tooltip:
                           button.tooltip.update_text(tooltip_text)
                      else:
                           button.tooltip = ToolTip(button, tooltip_text)
                      # --- KONIEC ZMIANY ---

                 # --- NOWE: Pokaż ponownie przycisk menu profili, jeśli istnieje ---
                 profile_menu_key = f"{game_name}_profile_menu"
                 if profile_menu_key in self._launch_buttons:
                      menu_button = self._launch_buttons[profile_menu_key]
                      if menu_button.winfo_exists():
                           # Przywróć go za pomocą pack (lub grid, jeśli używasz grid w launch_area_frame)
                           menu_button.pack(side=tk.LEFT, fill=tk.Y) # Użyj tych samych opcji co w _populate_game_tile
                 # --- KONIEC NOWEGO ---

                 logging.debug(f"Zaktualizowano przycisk (ikona/tekst) dla zamkniętej gry: {game_name}")

    def prompt_completion(self, game_name):
        """Pyta użytkownika o procent ukończenia gry po jej zakończeniu."""
        completion = simpledialog.askinteger(
            "Procent ukończenia",
            f"Ile procent gry '{game_name}' ukończyłeś?",
            minvalue=0,
            maxvalue=100
        )
        if completion is not None:
            self.games[game_name]["completion"] = completion
        else:
            self.games[game_name]["completion"] = self.games[game_name].get("completion", 0)
        save_config(self.config)
        # --- NOWE: Sprawdź osiągnięcia ---
        self.check_and_unlock_achievements()
        # --- KONIEC NOWEGO ---
        self.update_game_grid()
        self.update_time_stats()
        self.create_home_page()  # Odświeżenie strony głównej



    def create_recently_played(self, parent, row=0, column=0):
        frame = ttk.LabelFrame(parent, text="Ostatnio Grane")
        frame.grid(row=row, column=column, padx=10, pady=10, sticky="nsew")
        parent.rowconfigure(row, weight=1)
        parent.columnconfigure(column, weight=1)

        # Ostatnie 5 granych gier
        recent_games = sorted(
            [g for g in self.games.values() if g.get('last_played')],
            key=lambda x: x['last_played'],
            reverse=True
        )[:5]

        for idx, game in enumerate(recent_games):
            game_name = [name for name, data in self.games.items() if data == game][0]
            btn = ttk.Button(frame, text=game_name, command=lambda gn=game_name: self.launch_game(gn))
            btn.grid(row=idx, column=0, padx=5, pady=5, sticky="w")


    def create_time_stats(self, parent, row: int = 0, column: int = 1) -> None:
        frame = ttk.LabelFrame(parent, text="Czas spędzony w grach")
        frame.grid(row=row, column=column, padx=10, pady=10, sticky="nsew")
        parent.rowconfigure(row, weight=1)
        parent.columnconfigure(column, weight=1)

        # wybór jednostki
        self.time_unit_var = tk.StringVar(value="godziny")
        ttk.OptionMenu(
            frame,
            self.time_unit_var,
            self.time_unit_var.get(),
            *["godziny", "dni", "miesiące", "lata"],
            command=self.update_time_stats
        ).grid(row=0, column=0, padx=5, pady=5, sticky="w")

        # etykiety (kolejno: wszystkie / PC / emulatory / każdy emulator)
        self.time_labels: dict[str, ttk.Label] = {}
        labels_order = [
            "Wszystkie gry", "Gry PC", "Emulatory – łącznie"
        ]
        # dołożymy później po jednym wierszu dla każdego skonfigurowanego emulatora
        for i, txt in enumerate(labels_order, start=1):
            lbl = ttk.Label(frame, text="")
            lbl.grid(row=i, column=0, sticky="w", padx=5, pady=2)
            self.time_labels[txt] = lbl

        # dynamiczne wiersze dla emulatorów
        self._time_stats_emulator_rows: list[tuple[str, ttk.Label]] = []

        self.update_time_stats()          # pierwsze wypełnienie

    def update_time_stats(self, *_):
        unit = self.time_unit_var.get()
        to_unit = {
            "godziny": 3600,
            "dni":     3600 * 24,
            "miesiące":3600 * 24 * 30,
            "lata":    3600 * 24 * 365
        }[unit]

        # pełne podsumowanie
        def _fmt(sec: float) -> str:
            return f"{sec/to_unit:.2f} {unit}"

        # usuwamy ewentualne stare wiersze emulatorów
        for name, lbl in self._time_stats_emulator_rows:
            lbl.destroy()
        self._time_stats_emulator_rows.clear()

        # 1️⃣ wszystkie gry
        self.time_labels["Wszystkie gry"].config(
            text=f"Łącznie: {_fmt(self.get_total_play_time('all'))}"
        )

        # 2️⃣ tylko PC
        self.time_labels["Gry PC"].config(
            text=f"Gry PC: {_fmt(self.get_total_play_time('all', game_type='pc'))}"
        )

        # 3️⃣ emu razem
        emu_total = self.get_total_play_time("all", game_type="emulator")
        self.time_labels["Emulatory – łącznie"].config(
            text=f"Emulatory (razem): {_fmt(emu_total)}"
        )

        # 4️⃣ rozbicie na konkretne emulatory
        row_start = len(self.time_labels) + 1
        emulators = sorted(set(
            g.get("emulator_name") for g in self.games.values()
            if g.get("game_type") == "emulator"
        ))
        for i, emu in enumerate(emulators, start=row_start):
            secs = self.get_total_play_time("all", emulator_name=emu)
            lbl = ttk.Label(self.time_labels["Wszystkie gry"].master,  # ten sam frame
                            text=f"  ↳ {emu}: {_fmt(secs)}")
            lbl.grid(row=i, column=0, sticky="w", padx=20, pady=1)
            self._time_stats_emulator_rows.append((emu, lbl))

    def get_total_play_time(
            self,
            period: str = "week",
            game_type: str | None = None,          # "pc" / "emulator" / None-=-oba
            emulator_name: str | None = None       # gdy chcesz sumę tylko danego emulatora
    ) -> float:
        """
        Zwraca łączny czas gry (w sekundach) dla zadanego okresu i filtrów.
        period  –  'week' | 'month' | 'year' | 'all'
        """
        seconds_in = {
            "week":  60 * 60 * 24 * 7,
            "month": 60 * 60 * 24 * 30,
            "year":  60 * 60 * 24 * 365,
            "all":   10**12                         # praktycznie „bez limitu”
        }[period]

        now = time.time()
        total = 0.0
        for g in self.games.values():
            if game_type and g.get("game_type", "pc") != game_type:
                continue
            if emulator_name and g.get("emulator_name") != emulator_name:
                continue

            for sess in g.get("play_sessions", []):
                if now - sess["end"] <= seconds_in:
                    total += sess["end"] - sess["start"]
        return total

    def create_random_games(self, parent, row=1, column=0):
        frame = ttk.LabelFrame(parent, text="Losowe Gry")
        frame.grid(row=row, column=column, padx=10, pady=10, sticky="nsew")
        parent.rowconfigure(row, weight=1)
        parent.columnconfigure(column, weight=1)

        # Wybierz do 10 losowych gier
        if self.games:
            num_random_games = min(10, len(self.games))  # Możesz zmienić 10 na dowolną liczbę
            random_games = random.sample(list(self.games.keys()), num_random_games)
            for idx, game_name in enumerate(random_games):
                btn = ttk.Button(frame, text=game_name, command=lambda gn=game_name: self.launch_game(gn))
                btn.grid(row=idx, column=0, padx=5, pady=5, sticky="w")
        else:
            ttk.Label(frame, text="Brak gier w bibliotece.").grid(row=0, column=0, padx=5, pady=5)


    def create_game_grid(self):
        # Canvas z przewijaniem
        self.canvas = tk.Canvas(self.content, bg="#1e1e1e", highlightthickness=0)
        self.canvas.grid(row=0, column=0, sticky="nsew")

        self.scrollbar = ttk.Scrollbar(self.content, orient="vertical", command=self.canvas.yview)
        self.scrollbar.grid(row=0, column=1, sticky="ns")

        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        # Przenosimy konfigurację na koniec, po stworzeniu games_frame
        # self.canvas.bind("<Configure>", self.on_canvas_configure) # Zostaje
        # self.canvas.bind_all("<MouseWheel>", self.on_mouse_wheel) # Zmienimy to

        self.games_frame = ttk.Frame(self.canvas)
        # UWAGA: Teraz to jest frame ID, a nie bezpośrednio window
        self.games_frame_id = self.canvas.create_window((0, 0), window=self.games_frame, anchor="nw")

    # W create_game_grid, po self.canvas.create_window(...):

        # --- NOWE: Treeview dla widoku listy ---
        self.list_view_frame = ttk.Frame(self.content) # Ramka dla Treeview i scrollbara
        # grid_remove() zostanie użyte do ukrycia na starcie

        list_columns = ("Nazwa", "Czas Gry", "Ocena", "Gatunki", "Wersja", "Tagi", "Data Dodania")
        self.list_view_tree = ttk.Treeview(
            self.list_view_frame,
            columns=list_columns,
            show="headings",
            selectmode="browse", # Pojedyncze zaznaczenie
            height=15 # Domyślna wysokość
        )

        # Ustawienia nagłówków i szerokości kolumn
        self.list_view_tree.heading("Nazwa", text="Nazwa Gry", command=lambda: self._sort_list_view_by_column("Nazwa"))
        self.list_view_tree.column("Nazwa", width=250, anchor=tk.W)

        self.list_view_tree.heading("Czas Gry", text="Czas Gry", command=lambda: self._sort_list_view_by_column("Czas Gry"))
        self.list_view_tree.column("Czas Gry", width=80, anchor=tk.CENTER)

        self.list_view_tree.heading("Ocena", text="Ocena", command=lambda: self._sort_list_view_by_column("Ocena"))
        self.list_view_tree.column("Ocena", width=60, anchor=tk.CENTER)

        self.list_view_tree.heading("Gatunki", text="Gatunki", command=lambda: self._sort_list_view_by_column("Gatunki"))
        self.list_view_tree.column("Gatunki", width=150, anchor=tk.W)

        self.list_view_tree.heading("Wersja", text="Wersja", command=lambda: self._sort_list_view_by_column("Wersja"))
        self.list_view_tree.column("Wersja", width=100, anchor=tk.W)

        self.list_view_tree.heading("Tagi", text="Tagi", command=lambda: self._sort_list_view_by_column("Tagi"))
        self.list_view_tree.column("Tagi", width=150, anchor=tk.W)

        self.list_view_tree.heading("Data Dodania", text="Data Dodania", command=lambda: self._sort_list_view_by_column("Data Dodania"))
        self.list_view_tree.column("Data Dodania", width=110, anchor=tk.CENTER)


        # Scrollbar dla Treeview
        list_scrollbar = ttk.Scrollbar(self.list_view_frame, orient="vertical", command=self.list_view_tree.yview)
        self.list_view_tree.configure(yscrollcommand=list_scrollbar.set)

        self.list_view_tree.grid(row=0, column=0, sticky="nsew")
        list_scrollbar.grid(row=0, column=1, sticky="ns")

        self.list_view_frame.columnconfigure(0, weight=1)
        self.list_view_frame.rowconfigure(0, weight=1)

        # Ukryj ramkę listy na starcie
        self.list_view_frame.grid_remove()

        # Dodaj bindowanie dla podwójnego kliknięcia (np. do uruchomienia)
        self.list_view_tree.bind("<Double-1>", self._on_list_view_double_click)
        # Dodaj bindowanie dla menu kontekstowego (prawy przycisk)
        self.list_view_tree.bind("<Button-3>", self._on_list_view_right_click)

        # Zmienne do sortowania listy
        self._list_sort_column = "Nazwa"
        self._list_sort_reverse = False
        # --- KONIEC NOWE ---

        self.content.columnconfigure(0, weight=1)
        self.content.rowconfigure(0, weight=1)

        # --- NOWE: Powiązanie zdarzeń do lazy loadingu ---
        self.canvas.bind("<Configure>", self.on_canvas_configure_and_lazy_load) # Połączono configure i lazy load
        # Bind scrollbar changes AND mouse wheel to the lazy load function
        self.scrollbar.bind("<B1-Motion>", self._trigger_lazy_load)
        self.canvas.bind_all("<MouseWheel>", self._on_mouse_wheel_and_lazy_load) # Użyj bind_all

        # --- Koniec NOWE ---

        # Parametry
        self.tile_height = 670 # Zwiększmy trochę wysokość dla dodatkowych danych
        self._loaded_tile_ids = set() # Przechowuje ID ramek, które już załadowano
        # --- NOWE: Ramka dla Paginacji ---
        self.pagination_frame = ttk.Frame(self.content)
        self.pagination_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(5, 10))
        self.pagination_frame.columnconfigure(1, weight=1) # Pozwól etykiecie się wyśrodkować

        self.prev_page_btn = ttk.Button(self.pagination_frame, text="<< Poprzednia", command=self.prev_page, state=tk.DISABLED)
        self.prev_page_btn.grid(row=0, column=0, padx=10)

        self.page_label = ttk.Label(self.pagination_frame, text="Strona 1 / 1")
        self.page_label.grid(row=0, column=1, sticky="ew") # Wyśrodkowana

        self.next_page_btn = ttk.Button(self.pagination_frame, text="Następna >>", command=self.next_page, state=tk.DISABLED)
        self.next_page_btn.grid(row=0, column=2, padx=10)

    def on_mouse_wheel(self, event):
        """Przewijanie za pomocą kółka myszy."""
        self.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")


    def format_play_time(self, seconds):
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        return f"{hours}h {minutes}m"

    def _save_and_apply_font_setting(self, event=None):
        """Zapisuje wybraną czcionkę i odświeża style."""
        selected_font = self.font_var.get()
        if self.local_settings.get("ui_font") != selected_font:
            self.local_settings["ui_font"] = selected_font
            save_local_settings(self.local_settings)
            logging.info(f"Zmieniono czcionkę interfejsu na: {selected_font}")
            # Zastosuj nowe ustawienia czcionki do stylów
            self.apply_font_settings()
            # Możesz dodać informację dla użytkownika, że restart może być potrzebny
            # messagebox.showinfo("Zmiana Czcionki", "Czcionka interfejsu została zmieniona. Pełne zastosowanie może wymagać ponownego uruchomienia aplikacji.", parent=self.settings_page_frame)

    def _update_home_lists(self, *_):
        """Przelicza ile przycisków zmieści się w danej wysokości
        i odświeża obie listy bez scroll-barów."""
        if not (self.home_frame.winfo_exists() and self.recent_frame.winfo_exists()):
            return

        self.recent_frame.update_idletasks()
        self.random_frame.update_idletasks()

        # wysokość przycisku ≈ 30 px  (u Ciebie może być inna – dostosuj!)
        btn_h = 30
        pad   = 8
        avail_recent = max(1, (self.recent_frame.winfo_height() // (btn_h + pad)) - 1)
        avail_random = max(1, (self.random_frame.winfo_height() // (btn_h + pad)) - 1)

        self._populate_recently_played(avail_recent)
        self._populate_random_games(avail_random)

    def _populate_recently_played(self, limit: int):
        for w in self.recent_frame.winfo_children():
            w.destroy()

        recent_games = sorted(
            (g for g in self.games.values() if g.get("last_played")),
            key=lambda d: d["last_played"], reverse=True
        )[:limit]

        for g in recent_games:
            name = next(k for k, v in self.games.items() if v is g)
            ttk.Button(
                self.recent_frame, text=name,
                command=lambda n=name: self.launch_game(n)
            ).pack(anchor="w", padx=5, pady=4, fill="x")

    def _populate_random_games(self, limit: int):
        for w in self.random_frame.winfo_children():
            w.destroy()

        if not self.games:
            ttk.Label(self.random_frame, text="Brak gier.").pack(anchor="w", padx=5, pady=4)
            return

        sample = random.sample(list(self.games.keys()), min(limit, len(self.games)))
        for name in sample:
            ttk.Button(
                self.random_frame, text=name,
                command=lambda n=name: self.launch_game(n)
            ).pack(anchor="w", padx=5, pady=4, fill="x")

    def apply_font_settings(self, selected_font=None):
         """Stosuje wybraną czcionkę do stylów ttk."""
         if selected_font is None:
             selected_font = self.local_settings.get("ui_font", "Segoe UI") # Użyj zapisanej lub domyślnej

         style = ttk.Style(self.root)
         # Definiuj rozmiary (możesz je dostosować)
         default_size = 9
         heading_size = 10
         bold_font = (selected_font, heading_size, "bold")
         normal_font = (selected_font, default_size)
         small_font = (selected_font, max(7, default_size - 1)) # Mniejsza czcionka, ale nie mniej niż 7

         try:
              # Aktualizuj style dla różnych widgetów
              style.configure("TLabel", font=normal_font)
              style.configure("TButton", font=normal_font)
              style.configure("TEntry", font=normal_font)
              style.configure("TCombobox", font=normal_font)
              style.configure("TSpinbox", font=normal_font)
              style.configure("TCheckbutton", font=normal_font)
              style.configure("TRadiobutton", font=normal_font)
              style.configure("TMenubutton", font=normal_font)
              style.configure("TNotebook.Tab", font=small_font) # Czcionka zakładek
              # Nagłówki Treeview
              style.configure("Treeview.Heading", font=bold_font)
              # Nagłówki LabelFrame
              style.configure("TLabelframe.Label", font=bold_font)
              # Specyficzne style, np. dla kafelków
              style.configure("Tile.TButton", font=small_font) # Przyciski na kafelku
              # Etykieta pod okładką na kafelku (wymaga modyfikacji _populate_game_tile)
              # Na razie zostawmy ją ze stałym fontem, ale można by ją też tu uwzględnić

              # Zaktualizuj font dla istniejących widgetów, które mogą go nie odziedziczyć automatycznie
              # (Np. jeśli ustawiłeś font bezpośrednio w kodzie tworzenia widgetu)
              # Przykład:
              # if hasattr(self, 'page_label'): self.page_label.config(font=normal_font)
              # if hasattr(self, 'duplicate_count_label'): self.duplicate_count_label.config(font=small_font)

              logging.info(f"Zastosowano czcionkę '{selected_font}' do stylów.")

              # Może być konieczne delikatne przerysowanie, ale unikajmy pełnego refresh_ui
              # self.root.update_idletasks()

         except tk.TclError as e:
              logging.error(f"Błąd TclError podczas stosowania czcionki '{selected_font}': {e}. Może brakować czcionki w systemie.")
              # Opcjonalnie: Wróć do domyślnej czcionki systemowej w razie błędu
              # self.font_var.set("System")
              # self.apply_font_settings("System")
              messagebox.showerror("Błąd Czcionki", f"Nie można zastosować czcionki '{selected_font}'.\nSprawdź, czy jest zainstalowana.\n\nBłąd: {e}", parent=self.settings_page_frame)
         except Exception as e:
              logging.exception(f"Nieoczekiwany błąd podczas stosowania czcionki: {e}")

    def _reset_single_achievement_progress(self, ach_id: str) -> None:
        """
        Usuwa z self.user['achievements'] wpis dotyczący wskazanego osiągnięcia
        (czyli: zeruje postęp i status „unlocked”), a następnie zapisuje config.
        """
        self.user.setdefault("achievements", {}).pop(ach_id, None)
        save_config(self.config)

    def launch_game(self, game_name, profile=None):
        """Uruchamia wybraną grę (PC lub emulowaną)."""
        game = self.games.get(game_name)
        if not game:
            messagebox.showerror("Błąd", "Nie znaleziono gry.")
            return

        game_type = game.get("game_type", "pc")

        # Zainicjuj zmienne poza blokami if/elif
        command = []
        args_to_add = []
        profile_name_for_log = "Default" # Domyślna wartość początkowa
        log_msg = ""

        try:
            if game_type == "pc":
                exe_to_run = game.get("exe_path")
                profile_name_for_log = "Default (PC)" # Domyślna dla PC

                if profile and isinstance(profile, dict):
                    profile_name_for_log = profile.get("name", "Unknown Profile")
                    profile_exe = profile.get("exe_path")
                    profile_args_str = profile.get("arguments", "")
                    if profile_exe:
                        exe_to_run = profile_exe
                        profile_name_for_log += " (profile exe)"
                    elif not exe_to_run: messagebox.showerror("Błąd", f"..."); return
                    if profile_args_str:
                        try: args_to_add = shlex.split(profile_args_str)
                        except ValueError as e: messagebox.showerror("Błąd Argumentów", f"..."); return
                elif not exe_to_run: messagebox.showerror("Błąd", f"..."); return

                if not exe_to_run or not os.path.exists(exe_to_run): messagebox.showerror("Błąd", f"..."); return

                command = [exe_to_run] + args_to_add
                log_msg = f"Uruchamianie gry PC: {game_name} (Profil: {profile_name_for_log}) z poleceniem: {command}"

            elif game_type == "emulator":
                emulator_name = game.get("emulator_name")
                rom_path = game.get("rom_path")
                emulator_args_str = game.get("emulator_args", "")
                profile_name_for_log = f"Emulator: {emulator_name}" # Ustaw dla emulatora

                if not emulator_name or not rom_path: messagebox.showerror("Błąd Konfiguracji", f"..."); return
                emulator_config = self.config.get("emulators", {}).get(emulator_name)
                if not emulator_config or not emulator_config.get("path"): messagebox.showerror("Błąd Emulatora", f"..."); return
                emulator_exe_path = emulator_config["path"]
                if not os.path.exists(emulator_exe_path): messagebox.showerror("Błąd Ścieżki", f"..."); return
                if not os.path.exists(rom_path): messagebox.showerror("Błąd Ścieżki", f"..."); return
                if emulator_args_str:
                    try: args_to_add = shlex.split(emulator_args_str)
                    except ValueError as e: messagebox.showerror("Błąd Argumentów", f"..."); return

                command = [emulator_exe_path] + args_to_add + [rom_path]
                log_msg = f"Uruchamianie gry emulowanej: {game_name} (Emulator: {emulator_name}) z poleceniem: {command}"

            else:
                messagebox.showerror("Błąd", f"Nieznany typ gry '{game_type}' dla '{game_name}'.")
                return

            # Sprawdź osiągnięcie "Nocny gracz" (logika bez zmian)
            now_hour = datetime.datetime.now().hour; ach_id_night = "night_owl"; user_achievements = self.user.setdefault("achievements", {})
            if 2 <= now_hour < 4:
                if ach_id_night not in user_achievements or not user_achievements[ach_id_night].get("_triggered_at_night"):
                    logging.info("Wykryto uruchomienie gry w nocy (2-4). Oznaczanie do sprawdzenia.")
                    ach_progress_data = user_achievements.setdefault(ach_id_night, {"unlocked": False, "timestamp": None, "current_progress": 0})
                    ach_progress_data["_triggered_at_night"] = True

            # --- Wspólna część: Uruchomienie procesu i aktualizacja danych ---
            logging.info(log_msg)
            # --- NOWE ZMIANY: Obsługa błędu OSError 740 ---
            try:
                process = subprocess.Popen(command)
                self.processes[game_name] = process # Dodaj do słownika tylko jeśli Popen się powiedzie
            except OSError as e:
                if e.winerror == 740: # Sprawdź specyficzny kod błędu Windows dla "Elevation Required"
                    logging.error(f"Błąd uruchamiania '{game_name}': Wymagane uprawnienia administratora (WinError 740).")
                    messagebox.showerror(
                        "Błąd Uprawnień",
                        f"Nie można uruchomić gry '{game_name}'.\n\n"
                        f"Ta gra wymaga uprawnień administratora, a launcher został uruchomiony bez nich.\n\n"
                        f"Możliwe rozwiązania:\n"
                        f"1. Uruchom launcher ponownie, klikając prawym przyciskiem myszy i wybierając 'Uruchom jako administrator' (mniej bezpieczne).\n"
                        f"2. Sprawdź właściwości pliku .exe gry (zakładka Zgodność) i odznacz 'Uruchom ten program jako administrator', jeśli to możliwe.",
                        parent=self.root # Użyj głównego okna jako rodzica
                    )
                    # WAŻNE: Nie kontynuuj, jeśli wystąpił błąd
                    return # Zakończ funkcję launch_game
                else:
                    # Inny błąd OSError - rzuć go dalej lub obsłuż inaczej
                    logging.exception(f"Nie udało się uruchomić gry '{game_name}' (inny OSError: {e})")
                    messagebox.showerror("Błąd Uruchamiania", f"Nie udało się uruchomić gry '{game_name}':\n{e}")
                    return # Zakończ funkcję launch_game
            except Exception as e:
                # Ogólna obsługa innych błędów (jak poprzednio)
                logging.exception(f"Nie udało się uruchomić gry '{game_name}'")
                messagebox.showerror("Błąd Uruchamiania", f"Nie udało się uruchomić gry '{game_name}':\n{e}")
                return # Zakończ funkcję launch_game
            # --- KONIEC NOWYCH ZMIAN ---

            # Aktualizuj statystyki
            game["last_played"] = time.time()
            game["play_count"] = game.get("play_count", 0) + 1
            start_time = time.time() # Zapisz czas startu
            self.game_start_times[game_name] = start_time

            # Aktualizuj przycisk na kafelku
            if game_name in self._launch_buttons:
                button = self._launch_buttons[game_name]
                if button.winfo_exists():
                    stop_icon_tk = self._button_icons.get("stop_btn"); close_command = lambda: self.close_game(game_name); tooltip_text = "Zamknij"
                    if stop_icon_tk:
                        button.config(image=stop_icon_tk, style="Red.TButton", command=close_command)
                        if hasattr(button, 'tooltip') and button.tooltip: button.tooltip.update_text(tooltip_text)
                    else:
                        button.config(image="", text="Zamknij", style="Red.TButton", command=close_command)
                        if hasattr(button, 'tooltip') and button.tooltip: button.tooltip.update_text(tooltip_text)
                        else: button.tooltip = ToolTip(button, tooltip_text)
                    # Ukryj przycisk menu profili
                    profile_menu_key = f"{game_name}_profile_menu"
                    if profile_menu_key in self._launch_buttons:
                         menu_button = self._launch_buttons[profile_menu_key]
                         if menu_button.winfo_exists(): menu_button.pack_forget()

            # --- PRZENIESIONE TUTAJ: Aktualizuj status Discord ---
            # Teraz profile_name_for_log i start_time są zdefiniowane dla obu typów gier
            self._update_discord_status(
                status_type="in_game",
                game_name=game_name,
                profile_name=profile_name_for_log, # Ta zmienna teraz zawsze istnieje
                start_time=start_time # Użyj zapisanego czasu startu
            )
            # --- KONIEC PRZENOSZENIA ---

            save_config(self.config) # Zapisz last_played itp.

        except Exception as e:
            logging.exception(f"Nie udało się uruchomić gry '{game_name}'")
            messagebox.showerror("Błąd Uruchamiania", f"Nie udało się uruchomić gry '{game_name}':\n{e}")


    def track_play_time(self, game_name):
        start_time = time.time()
        while self.is_game_running(game_name):
            time.sleep(1)
        end_time = time.time()
        elapsed = end_time - start_time
        self.games[game_name]["play_time"] += elapsed

        # Loguj sesję
        self.games[game_name].setdefault("play_sessions", []).append({'start': start_time, 'end': end_time})

        save_config(self.config)
        # Schedule GUI update in the main thread
        self.root.after(0, self.update_after_game, game_name)

    def update_after_game(self, game_name):
        # Zapytaj o procent ukończenia gry
        completion = simpledialog.askinteger("Procent ukończenia", f"Ile procent gry '{game_name}' ukończyłeś?")
        if completion is not None:
            self.games[game_name]["completion"] = completion
        else:
            self.games[game_name]["completion"] = self.games[game_name].get("completion", 0)
        save_config(self.config)
        self.update_game_grid()
        self.update_time_stats()
        self.create_home_page()  # Odświeżenie strony głównej

    def is_game_running(self, game_name):
        """Sprawdza, czy proces gry (PC lub emulowanej) jest uruchomiony."""
        game_data = self.games.get(game_name)
        if not game_data:
            return False

        game_type = game_data.get("game_type", "pc")

        if game_type == "pc":
            # --- Logika dla gier PC (bez zmian) ---
            # Sprawdź proces na podstawie głównego exe LUB profili
            exe_paths_to_check = set()
            if game_data.get("exe_path"):
                 exe_paths_to_check.add(os.path.abspath(game_data["exe_path"]))
            for profile in game_data.get("launch_profiles", []):
                 if profile.get("exe_path"): # Sprawdź tylko jeśli profil ma własne EXE
                      exe_paths_to_check.add(os.path.abspath(profile["exe_path"]))

            if not exe_paths_to_check:
                 return False # Brak jakiejkolwiek ścieżki do sprawdzenia

            exe_names_to_check = {os.path.basename(p).lower() for p in exe_paths_to_check}

            for proc in psutil.process_iter(['name', 'exe']):
                try:
                    proc_name_lower = proc.info['name'].lower()
                    proc_exe_abs = os.path.abspath(proc.info['exe']) if proc.info['exe'] else None

                    if proc_name_lower in exe_names_to_check:
                        return True
                    if proc_exe_abs and proc_exe_abs in exe_paths_to_check:
                        return True
                except (psutil.NoSuchProcess, psutil.AccessDenied, TypeError, OSError): # Dodano TypeError, OSError
                    continue
            return False
            # --- Koniec logiki PC ---

        elif game_type == "emulator":
            # --- NOWA Logika dla gier emulowanych ---
            emulator_name = game_data.get("emulator_name")
            if not emulator_name: return False # Brak nazwy emulatora

            emulator_config = self.config.get("emulators", {}).get(emulator_name)
            if not emulator_config or not emulator_config.get("path"): return False # Brak konfiguracji emulatora

            emulator_exe_path = emulator_config["path"]
            if not emulator_exe_path: return False # Pusta ścieżka w konfiguracji

            emulator_exe_path_abs = os.path.abspath(emulator_exe_path)
            emulator_exe_name_lower = os.path.basename(emulator_exe_path_abs).lower()

            # Sprawdź, czy działa proces emulatora o tej nazwie lub ścieżce
            # UWAGA: To jest uproszczenie! Jeśli masz uruchomiony ten sam emulator
            # dla INNEJ gry, ta metoda zwróci True. Dokładniejsze śledzenie
            # wymagałoby zapamiętania PID procesu przy uruchamianiu.
            for proc in psutil.process_iter(['name', 'exe', 'cmdline']): # Dodano cmdline
                try:
                    proc_name_lower = proc.info['name'].lower()
                    proc_exe_abs = os.path.abspath(proc.info['exe']) if proc.info['exe'] else None

                    if proc_name_lower == emulator_exe_name_lower or \
                       (proc_exe_abs and proc_exe_abs == emulator_exe_path_abs):
                         # --- Dodatkowe sprawdzenie linii komend (jeśli możliwe) ---
                         # Sprawdźmy, czy ścieżka ROMu jest w linii komend procesu emulatora
                         rom_path = game_data.get("rom_path")
                         if rom_path and proc.info['cmdline']:
                              # Normalizuj ścieżkę ROMu dla porównania
                              norm_rom_path = os.path.normcase(os.path.abspath(rom_path))
                              # Sprawdź, czy znormalizowana ścieżka ROMu występuje w którymkolwiek argumencie linii komend
                              if any(norm_rom_path in os.path.normcase(arg) for arg in proc.info['cmdline']):
                                   logging.debug(f"Znaleziono proces emulatora ({proc.pid}) z pasującą ścieżką ROM dla '{game_name}'.")
                                   return True
                              else:
                                   # Proces emulatora działa, ale nie dla tej gry
                                   logging.debug(f"Znaleziono proces emulatora ({proc.pid}), ale linia komend nie pasuje do ROMu '{game_name}'.")
                                   continue # Szukaj dalej, może jest inny proces tego emulatora
                         else:
                              # Jeśli nie ma ścieżki ROMu lub cmdline, musimy założyć, że to ten proces
                              logging.warning(f"Znaleziono proces emulatora dla '{game_name}', ale nie można zweryfikować ROMu w linii komend.")
                              return True # Uproszczone dopasowanie
                         # --- Koniec sprawdzania linii komend ---

                except (psutil.NoSuchProcess, psutil.AccessDenied, TypeError, OSError):
                    continue
            return False
            # --- Koniec logiki emulatora ---

        else:
            logging.error(f"Nieznany typ gry '{game_type}' w is_game_running dla '{game_name}'.")
            return False

    def close_game(self, game_name):
        """Zamyka proces gry (PC lub emulowanej)."""
        game_data = self.games.get(game_name)
        if not game_data:
            logging.error(f"Próba zamknięcia nieistniejącej gry: {game_name}")
            return

        game_type = game_data.get("game_type", "pc")
        process_found_and_killed = False

        if game_type == "pc":
            # --- Logika zamykania gier PC ---
            exe_paths_to_check = set()
            if game_data.get("exe_path"):
                 exe_paths_to_check.add(os.path.abspath(game_data["exe_path"]))
            for profile in game_data.get("launch_profiles", []):
                 if profile.get("exe_path"):
                      exe_paths_to_check.add(os.path.abspath(profile["exe_path"]))

            if not exe_paths_to_check:
                 messagebox.showwarning("Błąd", f"Brak zdefiniowanej ścieżki .exe do zamknięcia dla gry PC '{game_name}'.")
                 return

            exe_names_to_check = {os.path.basename(p).lower() for p in exe_paths_to_check}
            logging.info(f"Próba zamknięcia gry PC '{game_name}'. Sprawdzanie nazw: {exe_names_to_check}, ścieżek: {exe_paths_to_check}")

            for proc in psutil.process_iter(['pid', 'name', 'exe']):
                try:
                    proc_name_lower = proc.info['name'].lower()
                    proc_exe_abs = os.path.abspath(proc.info['exe']) if proc.info['exe'] else None

                    if proc_name_lower in exe_names_to_check or \
                       (proc_exe_abs and proc_exe_abs in exe_paths_to_check):
                        logging.info(f"Znaleziono pasujący proces PC (PID: {proc.info['pid']}). Próba zamknięcia.")
                        parent = psutil.Process(proc.info['pid'])
                        # Zabij proces potomne najpierw
                        children = parent.children(recursive=True)
                        for child in children:
                             try: child.kill()
                             except psutil.NoSuchProcess: pass
                        # Zabij proces główny
                        try: parent.kill()
                        except psutil.NoSuchProcess: pass
                        messagebox.showinfo("Informacja", f"Gra '{game_name}' została zamknięta.")
                        process_found_and_killed = True
                        break # Zakończ po znalezieniu i zabiciu pierwszego pasującego procesu
                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess, TypeError, OSError):
                    continue
            # --- Koniec logiki PC ---

        elif game_type == "emulator":
            # --- NOWA Logika zamykania gier emulowanych ---
            emulator_name = game_data.get("emulator_name")
            rom_path = game_data.get("rom_path") # Potrzebny do identyfikacji procesu
            if not emulator_name:
                messagebox.showwarning("Błąd", f"Brak nazwy emulatora dla gry '{game_name}'. Nie można zamknąć.", parent=self.root)
                return

            emulator_config = self.config.get("emulators", {}).get(emulator_name)
            if not emulator_config or not emulator_config.get("path"):
                messagebox.showwarning("Błąd", f"Brak konfiguracji ścieżki dla emulatora '{emulator_name}'.", parent=self.root)
                return

            emulator_exe_path = emulator_config["path"]
            if not emulator_exe_path:
                 messagebox.showwarning("Błąd", f"Pusta ścieżka w konfiguracji emulatora '{emulator_name}'.", parent=self.root)
                 return

            emulator_exe_path_abs = os.path.abspath(emulator_exe_path)
            emulator_exe_name_lower = os.path.basename(emulator_exe_path_abs).lower()
            norm_rom_path = os.path.normcase(os.path.abspath(rom_path)) if rom_path else None

            logging.info(f"Próba zamknięcia gry emulowanej '{game_name}'. Szukanie procesu emulatora: '{emulator_exe_name_lower}' ze ścieżką ROM: '{norm_rom_path}'")

            candidate_pids = [] # Zbierz PID pasujących procesów emulatora

            for proc in psutil.process_iter(['pid', 'name', 'exe', 'cmdline']):
                try:
                    proc_name_lower = proc.info['name'].lower()
                    proc_exe_abs = os.path.abspath(proc.info['exe']) if proc.info['exe'] else None

                    # Sprawdź, czy nazwa lub ścieżka emulatora pasuje
                    if proc_name_lower == emulator_exe_name_lower or \
                       (proc_exe_abs and proc_exe_abs == emulator_exe_path_abs):
                         # Jeśli mamy ROM, sprawdź linię komend
                         if norm_rom_path and proc.info['cmdline']:
                              if any(norm_rom_path in os.path.normcase(arg) for arg in proc.info['cmdline']):
                                   candidate_pids.append(proc.info['pid'])
                                   logging.debug(f"Znaleziono kandydata do zamknięcia (PID: {proc.info['pid']}) - pasuje emulator i ROM.")
                         elif not norm_rom_path: # Jeśli nie mamy ROMu do sprawdzenia (nie powinno się zdarzyć, ale...)
                              candidate_pids.append(proc.info['pid'])
                              logging.warning(f"Znaleziono kandydata do zamknięcia (PID: {proc.info['pid']}), ale brak ROMu do weryfikacji cmdline.")

                except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess, TypeError, OSError):
                    continue

            # Zabij znalezione procesy
            if candidate_pids:
                 for pid in candidate_pids:
                      try:
                           logging.info(f"Próba zamknięcia procesu emulatora (PID: {pid}) dla gry '{game_name}'.")
                           parent = psutil.Process(pid)
                           children = parent.children(recursive=True)
                           for child in children:
                                try: child.kill()
                                except psutil.NoSuchProcess: pass
                           try: parent.kill()
                           except psutil.NoSuchProcess: pass
                           process_found_and_killed = True # Wystarczy, że zabijemy jeden pasujący
                      except psutil.NoSuchProcess:
                           logging.warning(f"Proces emulatora (PID: {pid}) już nie istniał podczas próby zamknięcia.")
                      except Exception as kill_err:
                           logging.error(f"Błąd podczas zabijania procesu emulatora (PID: {pid}): {kill_err}")
                 if process_found_and_killed:
                      messagebox.showinfo("Informacja", f"Emulator '{emulator_name}' dla gry '{game_name}' został zamknięty.")
            # --- Koniec logiki emulatora ---
        else:
             messagebox.showerror("Błąd", f"Nieznany typ gry '{game_type}' dla '{game_name}'. Nie można zamknąć.")
             return

        # --- Wspólna część: Komunikat o błędzie i odświeżenie UI ---
        if not process_found_and_killed:
            messagebox.showwarning("Błąd", f"Nie znaleziono działającego procesu dla gry '{game_name}'.")

        # Odśwież siatkę, aby zaktualizować przycisk "Uruchom"
        # Wywołajmy to niezależnie od tego, czy proces został znaleziony,
        # aby przywrócić przycisk, jeśli gra się sama zamknęła między kliknięciem a wykonaniem funkcji.
        self.root.after(50, self.update_game_grid) # Dajmy chwilę systemowi na aktualizację listy procesów

    def reset_stats(self, game_name):
        confirm = messagebox.askyesno("Resetuj Statystyki", f"Czy na pewno chcesz zresetować statystyki gry '{game_name}'?")
        if confirm:
            self.games[game_name]["play_time"] = 0
            self.games[game_name]["completion"] = 0
            self.games[game_name]["play_sessions"] = []
            save_config(self.config)
            self.update_game_grid()
            self.update_time_stats()



    def manage_saves(self, game_name):
        # --- ZMIANA: Dodaj `self` jako ostatni argument ---
        save_manager = SaveManager(self.root, game_name, self.games[game_name], self)
        # --- KONIEC ZMIANY ---
        self.root.wait_window(save_manager.top)


    def _load_emulators_list(self):
        """Wczytuje skonfigurowane emulatory do Treeview w ustawieniach."""
        if not hasattr(self, 'emulators_tree') or not self.emulators_tree.winfo_exists():
            return # Zabezpieczenie, jeśli widget nie istnieje

        for item in self.emulators_tree.get_children():
            self.emulators_tree.delete(item)

        emulators = self.config.get("emulators", {})
        # Sortuj według nazwy emulatora dla lepszej czytelności
        for name in sorted(emulators.keys(), key=str.lower):
            path = emulators[name].get("path", "Brak ścieżki")
            # Użyj nazwy jako iid
            self.emulators_tree.insert("", "end", iid=name, values=(name, path))

    def _add_edit_emulator(self, edit_mode=False):
        """Otwiera okno dialogowe do dodawania lub edycji konfiguracji emulatora."""
        initial_name = ""
        initial_path = ""
        original_name = None # Do śledzenia oryginalnej nazwy podczas edycji

        if edit_mode:
            selection = self.emulators_tree.selection()
            if not selection:
                messagebox.showwarning("Brak zaznaczenia", "Zaznacz emulator, który chcesz edytować.", parent=self.settings_page_frame)
                return
            original_name = selection[0] # iid to nazwa emulatora
            emulator_data = self.config.get("emulators", {}).get(original_name)
            if not emulator_data:
                 messagebox.showerror("Błąd", f"Nie znaleziono danych dla emulatora: {original_name}", parent=self.settings_page_frame)
                 return
            initial_name = original_name
            initial_path = emulator_data.get("path", "")

        # --- Okno Dialogowe ---
        dialog = tk.Toplevel(self.settings_page_frame)
        dialog.title("Dodaj/Edytuj Emulator")
        dialog.configure(bg="#1e1e1e")
        dialog.grab_set()
        dialog.resizable(False, False)
        dialog.transient(self.settings_page_frame) # Zależne od okna ustawień

        ttk.Label(dialog, text="Nazwa Emulatora:").grid(row=0, column=0, padx=10, pady=5, sticky="w")
        name_var = tk.StringVar(value=initial_name)
        name_entry = ttk.Entry(dialog, textvariable=name_var, width=40)
        name_entry.grid(row=0, column=1, columnspan=2, padx=10, pady=5, sticky="ew")

        ttk.Label(dialog, text="Ścieżka do .exe:").grid(row=1, column=0, padx=10, pady=5, sticky="w")
        path_var = tk.StringVar(value=initial_path)
        path_entry = ttk.Entry(dialog, textvariable=path_var, width=40)
        path_entry.grid(row=1, column=1, padx=10, pady=5, sticky="ew")
        path_btn = ttk.Button(dialog, text="Wybierz...", command=lambda v=path_var: self._select_emulator_exe(v, dialog))
        path_btn.grid(row=1, column=2, padx=5, pady=5)

        def save_emulator():
            new_name = name_var.get().strip()
            new_path = path_var.get().strip()

            if not new_name or not new_path:
                messagebox.showerror("Błąd", "Nazwa emulatora i ścieżka do pliku .exe są wymagane.", parent=dialog)
                return
            if not os.path.isfile(new_path):
                 messagebox.showerror("Błąd", f"Podana ścieżka nie wskazuje na istniejący plik:\n{new_path}", parent=dialog)
                 return

            emulators = self.config.setdefault("emulators", {})

            # Sprawdź, czy nazwa już istnieje (poza edytowanym)
            if new_name != original_name and new_name in emulators:
                messagebox.showerror("Błąd", f"Emulator o nazwie '{new_name}' już istnieje.", parent=dialog)
                return

            # Jeśli edytujemy i zmieniono nazwę, usuń stary wpis
            if edit_mode and new_name != original_name and original_name in emulators:
                del emulators[original_name]

            # Zapisz/aktualizuj dane
            emulators[new_name] = {"path": new_path}
            save_config(self.config)
            self._load_emulators_list() # Odśwież listę w ustawieniach
             # --- NOWE: Odśwież listę emulatorów w GameForm, jeśli jest otwarty ---
            for widget in self.root.winfo_children():
                 if isinstance(widget, tk.Toplevel) and hasattr(widget, 'update_emulator_list'):
                      widget.update_emulator_list()
            # --- KONIEC NOWEGO ---
            dialog.destroy()

        button_frame = ttk.Frame(dialog)
        button_frame.grid(row=2, column=0, columnspan=3, pady=15)
        ttk.Button(button_frame, text="Zapisz", command=save_emulator).pack(side=tk.LEFT, padx=10)
        ttk.Button(button_frame, text="Anuluj", command=dialog.destroy).pack(side=tk.LEFT, padx=10)

        name_entry.focus_set()


    def _select_emulator_exe(self, string_var, parent_dialog):
        """Otwiera dialog wyboru pliku .exe dla emulatora."""
        path = filedialog.askopenfilename(
            title="Wybierz plik wykonywalny emulatora",
            filetypes=[("Pliki wykonywalne", "*.exe"), ("Wszystkie pliki", "*.*")],
            parent=parent_dialog # Ustaw okno dialogowe emulatora jako rodzica
        )
        if path:
            string_var.set(path)


    def _delete_emulator(self):
        """Usuwa zaznaczony emulator z konfiguracji."""
        selection = self.emulators_tree.selection()
        if not selection:
            messagebox.showwarning("Brak zaznaczenia", "Zaznacz emulator, który chcesz usunąć.", parent=self.settings_page_frame)
            return

        emulator_name = selection[0] # iid to nazwa

        if messagebox.askyesno("Potwierdź usunięcie", f"Czy na pewno chcesz usunąć emulator '{emulator_name}'?", parent=self.settings_page_frame):
            emulators = self.config.get("emulators", {})
            if emulator_name in emulators:
                del emulators[emulator_name]
                save_config(self.config)
                self._load_emulators_list() # Odśwież listę
                 # --- NOWE: Odśwież listę emulatorów w GameForm, jeśli jest otwarty ---
                for widget in self.root.winfo_children():
                     if isinstance(widget, tk.Toplevel) and hasattr(widget, 'update_emulator_list'):
                          widget.update_emulator_list()
                # --- KONIEC NOWEGO ---
                logging.info(f"Usunięto emulator: {emulator_name}")
            else:
                 messagebox.showerror("Błąd", f"Nie znaleziono emulatora '{emulator_name}' do usunięcia.", parent=self.settings_page_frame)

    def add_game(self):
        add_window = GameForm(self, "Dodaj Grę")
        self.root.wait_window(add_window.top)
        if add_window.result:
            game_name, game_data = add_window.result
            if game_name in self.games:
                messagebox.showwarning("Błąd", "Gra o tej nazwie już istnieje.")
                return

            # Dodaj domyślne statystyki i datę dodania dla nowej gry
            game_data["date_added"] = time.time()
            game_data["play_time"] = 0
            game_data["completion"] = 0
            game_data["last_played"] = None
            game_data["play_sessions"] = []
            game_data["launch_profiles"] = [{
             "name": "Default",
             "exe_path": None, # Użyje głównego exe_path gry
             "arguments": ""
        }]
            self.games[game_name] = game_data # Zapisz dane gry

            # Zapytaj, czy zaimportować zapisy
            import_saves = messagebox.askyesno("Importowanie zapisów", f"Czy chcesz zaimportować zapisy gry '{game_name}'?")
            if import_saves:
                source = filedialog.askdirectory(title="Wybierz folder z zapisami gry")
                if source:
                    destination = os.path.join(GAMES_FOLDER, game_name)
                    os.makedirs(destination, exist_ok=True)
                    try:
                        shutil.copytree(source, destination, dirs_exist_ok=True)
                        messagebox.showinfo("Sukces", "Zapisy zostały zaimportowane.")
                    except Exception as e:
                        messagebox.showerror("Błąd", f"Nie udało się zaimportować zapisów: {e}")

            save_config(self.config)
              # --- NOWE: Sprawdź osiągnięcia po dodaniu ---
            self.check_and_unlock_achievements()
              # --- KONIEC NOWEGO ---
            # --- NOWE: Sprawdź osiągnięcia ---
            self.check_and_unlock_achievements()
            # --- KONIEC NOWEGO ---
            # --- POPRAWIONE WYWOŁANIA ---
            self.reset_and_update_grid()      # Odśwież siatkę
            self.update_tag_filter_options()  # Odśwież listę tagów
            # --- KONIEC POPRAWKI ---
            # Aktualizuj listę gier w comboboxie roadmapy
            if hasattr(self, 'roadmap_game_name'):
                self.roadmap_game_name['values'] = list(self.games.keys())

    # --- NOWA METODA ---
    def _export_custom_theme_dialog(self):
        """Otwiera dialog wyboru sposobu eksportu zaznaczonego motywu niestandardowego."""
        if not hasattr(self, 'custom_themes_listbox'):
            logging.error("Listbox motywów niestandardowych nie istnieje.")
            return

        selection = self.custom_themes_listbox.curselection()
        if not selection:
            messagebox.showwarning("Brak zaznaczenia", "Zaznacz motyw niestandardowy, który chcesz wyeksportować.", parent=self.settings_page_frame)
            return
        theme_name = self.custom_themes_listbox.get(selection[0])
        theme_data = self.settings.get("custom_themes", {}).get(theme_name)

        if not theme_data:
            messagebox.showerror("Błąd", f"Nie można znaleźć danych dla motywu '{theme_name}'.", parent=self.settings_page_frame)
            return

        # --- Okno dialogowe wyboru eksportu ---
        export_dialog = tk.Toplevel(self.settings_page_frame)
        export_dialog.title(f"Eksportuj Motyw: {theme_name}")
        # --- ZMIANA: Użyj globalnego THEMES ---
        active_theme_def = self.get_all_available_themes().get(self.settings.get('theme', 'Dark'), THEMES.get('Dark'))
        export_dialog.configure(bg=active_theme_def.get('background', '#1e1e1e'))
        # --- KONIEC ZMIANY ---
        export_dialog.geometry("300x150")
        export_dialog.grab_set()
        export_dialog.resizable(False, False)
        export_dialog.transient(self.settings_page_frame)

        ttk.Label(export_dialog, text="Wybierz metodę eksportu:", font=("Segoe UI", 10)).pack(pady=10)

        button_frame = ttk.Frame(export_dialog)
        button_frame.pack(pady=10, fill="x", expand=True)

        def export_to_clipboard():
            try:
                theme_json_string = json.dumps({"name": theme_name, "definition": theme_data}, indent=2, ensure_ascii=False)
                self.root.clipboard_clear()
                self.root.clipboard_append(theme_json_string)
                messagebox.showinfo("Skopiowano", "Definicja motywu została skopiowana do schowka.", parent=export_dialog)
                export_dialog.destroy()
            except Exception as e:
                messagebox.showerror("Błąd", f"Nie udało się skopiować do schowka:\n{e}", parent=export_dialog)

        def export_to_file():
            try:
                # Sugerowana nazwa pliku
                default_filename = f"{theme_name.replace(' ', '_').lower()}_theme.json"
                filepath = filedialog.asksaveasfilename(
                    parent=export_dialog,
                    title=f"Zapisz motyw '{theme_name}' jako...",
                    initialfile=default_filename,
                    defaultextension=".json",
                    filetypes=[("Pliki JSON", "*.json"), ("Wszystkie pliki", "*.*")]
                )
                if filepath:
                    theme_to_save = {"name": theme_name, "definition": theme_data}
                    with open(filepath, 'w', encoding='utf-8') as f:
                        json.dump(theme_to_save, f, indent=2, ensure_ascii=False)
                    messagebox.showinfo("Zapisano", f"Motyw został zapisany do pliku:\n{filepath}", parent=export_dialog)
                    export_dialog.destroy()
            except Exception as e:
                messagebox.showerror("Błąd Zapisu", f"Nie udało się zapisać motywu do pliku:\n{e}", parent=export_dialog)

        ttk.Button(button_frame, text="Kopiuj do Schowka", command=export_to_clipboard).pack(pady=5, padx=20, fill="x")
        ttk.Button(button_frame, text="Zapisz do Pliku...", command=export_to_file).pack(pady=5, padx=20, fill="x")
    # --- KONIEC NOWEJ METODY ---

    # --- NOWA METODA (Szkielet) ---
    def _import_custom_theme_dialog(self):
        """Otwiera dialog do importowania motywu z tekstu lub pliku."""
        import_dialog = tk.Toplevel(self.settings_page_frame)
        import_dialog.title("Importuj Motyw Niestandardowy")
        # --- ZMIANA: Użyj globalnego THEMES ---
        active_theme_def = self.get_all_available_themes().get(self.settings.get('theme', 'Dark'), THEMES.get('Dark'))
        import_dialog.configure(bg=active_theme_def.get('background', '#1e1e1e'))
        # --- KONIEC ZMIANY ---
        import_dialog.geometry("450x350")
        import_dialog.grab_set()
        import_dialog.resizable(False, False)
        import_dialog.transient(self.settings_page_frame)

        main_import_frame = ttk.Frame(import_dialog, padding=10)
        main_import_frame.pack(fill="both", expand=True)
        main_import_frame.columnconfigure(0, weight=1)
        main_import_frame.rowconfigure(1, weight=1) # Pole tekstowe rośnie

        ttk.Label(main_import_frame, text="Wklej definicję motywu (JSON) poniżej LUB wybierz plik:").grid(row=0, column=0, columnspan=2, pady=(0,5), sticky="w")

        # Pole tekstowe do wklejania
        text_frame = ttk.Frame(main_import_frame) # Ramka dla Text i Scrollbar
        text_frame.grid(row=1, column=0, columnspan=2, sticky="nsew", pady=5)
        text_frame.columnconfigure(0, weight=1); text_frame.rowconfigure(0, weight=1)

        theme_text_widget = tk.Text(text_frame, height=10, width=50, wrap=tk.WORD)
        theme_text_widget.grid(row=0, column=0, sticky="nsew")
        theme_scroll = ttk.Scrollbar(text_frame, orient="vertical", command=theme_text_widget.yview)
        theme_scroll.grid(row=0, column=1, sticky="ns")
        theme_text_widget.config(yscrollcommand=theme_scroll.set)

        # Przyciski akcji
        action_button_frame = ttk.Frame(main_import_frame)
        action_button_frame.grid(row=2, column=0, columnspan=2, pady=10)

        def import_from_text():
            # TODO: Logika importu z pola theme_text_widget
            json_string = theme_text_widget.get("1.0", tk.END).strip()
            if not json_string:
                messagebox.showwarning("Puste Pole", "Wklej definicję motywu w formacie JSON.", parent=import_dialog)
                return
            self._process_theme_import(json_string, parent_window=import_dialog)

        def import_from_file():
            # TODO: Logika importu z pliku
            filepath = filedialog.askopenfilename(
                parent=import_dialog,
                title="Wybierz plik motywu JSON",
                defaultextension=".json",
                filetypes=[("Pliki JSON", "*.json"), ("Wszystkie pliki", "*.*")]
            )
            if filepath:
                try:
                    with open(filepath, 'r', encoding='utf-8') as f:
                        json_string = f.read()
                    self._process_theme_import(json_string, parent_window=import_dialog)
                except Exception as e:
                    messagebox.showerror("Błąd Odczytu Pliku", f"Nie udało się wczytać motywu z pliku:\n{e}", parent=import_dialog)

        ttk.Button(action_button_frame, text="Importuj z Pola Tekstowego", command=import_from_text).pack(side=tk.LEFT, padx=5)
        ttk.Button(action_button_frame, text="Importuj z Pliku...", command=import_from_file).pack(side=tk.LEFT, padx=5)
        ttk.Button(action_button_frame, text="Anuluj", command=import_dialog.destroy).pack(side=tk.RIGHT, padx=5)
    # --- KONIEC NOWEJ METODY (Szkielet) ---

    # --- NOWA METODA POMOCNICZA ---
    def _process_theme_import(self, json_string, parent_window):
        """Przetwarza importowany string JSON motywu."""
        try:
            imported_data = json.loads(json_string)
        except json.JSONDecodeError as e:
            messagebox.showerror("Błąd Formatu JSON", f"Nieprawidłowy format JSON definicji motywu:\n{e}", parent=parent_window)
            return

        # Walidacja podstawowej struktury
        if not isinstance(imported_data, dict) or "name" not in imported_data or "definition" not in imported_data:
            messagebox.showerror("Błąd Struktury", "Importowany motyw musi zawierać klucze 'name' i 'definition'.", parent=parent_window)
            return

        theme_name_imported = imported_data["name"]
        theme_def_imported = imported_data["definition"]

        if not isinstance(theme_name_imported, str) or not theme_name_imported.strip():
            messagebox.showerror("Błąd Nazwy", "Nazwa importowanego motywu nie może być pusta.", parent=parent_window)
            return
        if not isinstance(theme_def_imported, dict):
            messagebox.showerror("Błąd Definicji", "Definicja kolorów motywu musi być słownikiem.", parent=parent_window)
            return

        # Walidacja kluczy i wartości kolorów (podstawowa)
        template_keys = THEMES.get('Dark', {}).keys() # Użyj kluczy z Dark jako szablonu
        final_theme_def = {}
        for key in template_keys:
            if key not in theme_def_imported:
                messagebox.showwarning("Brakujący Klucz", f"Importowany motyw nie zawiera klucza '{key}'.\nUżyto wartości domyślnej.", parent=parent_window)
                final_theme_def[key] = THEMES['Dark'].get(key, "#ffffff") # Wartość domyślna z Dark
            elif not re.match(r'^#[0-9a-fA-F]{6}$', str(theme_def_imported[key])):
                messagebox.showwarning("Błędny Kolor", f"Nieprawidłowy format koloru HEX dla '{key}': {theme_def_imported[key]}.\nUżyto wartości domyślnej.", parent=parent_window)
                final_theme_def[key] = THEMES['Dark'].get(key, "#ffffff")
            else:
                final_theme_def[key] = str(theme_def_imported[key])

        # Zapytaj o nazwę (i obsłuż konflikty)
        # Walidacja nazwy (w przypadku ThemeEditorWindow jest już robiona w _save)
        new_name = simpledialog.askstring(
            "Nazwa Importowanego Motywu",
            "Podaj nazwę dla importowanego motywu:",
            initialvalue=theme_name_imported,
            parent=parent_window
        )

        if not new_name or not new_name.strip():
            messagebox.showwarning("Anulowano", "Import motywu został anulowany (brak nazwy).", parent=parent_window)
            return

        new_name = new_name.strip()
        # --- NOWE ZMIANY ---
        # Sprawdź, czy nazwa nie koliduje z motywami wbudowanymi
        if new_name in THEMES: # THEMES to globalna stała
            messagebox.showerror("Błąd Nazwy", f"Nazwa '{new_name}' jest zarezerwowana dla motywu wbudowanego.", parent=parent_window)
            return

        # Sprawdź, czy plik dla tej nazwy motywu już istnieje na dysku
        # Używamy tej samej konwencji bezpiecznych nazw plików, co przy zapisie.
        safe_new_filename = re.sub(r'[\\/*?:"<>|]', "_", new_name).strip()
        new_filepath = os.path.join(CUSTOM_THEMES_DIR, f"{safe_new_filename}.json")

        if os.path.exists(new_filepath):
            if not messagebox.askyesno("Konflikt Pliku Motywu", f"Plik motywu o nazwie '{safe_new_filename}.json' już istnieje.\nCzy chcesz go nadpisać?", parent=parent_window):
                return # Użytkownik nie chce nadpisać

        # Zapisz motyw do pliku w CUSTOM_THEMES_DIR
        try:
            os.makedirs(CUSTOM_THEMES_DIR, exist_ok=True) # Upewnij się, że folder istnieje
            with open(new_filepath, 'w', encoding='utf-8') as f:
                # Zapisz słownik zawierający klucze "name" i "definition"
                json.dump({"name": new_name, "definition": final_theme_def}, f, indent=2, ensure_ascii=False)
            logging.info(f"Zaimportowano i zapisano motyw do pliku: {new_filepath}")
        except Exception as e:
            messagebox.showerror("Błąd Zapisu", f"Nie udało się zapisać importowanego motywu do pliku:\n{e}", parent=parent_window)
            return
        
        # Po zapisie pliku, wyczyść cache w GameLauncher, aby załadował nową listę motywów z dysku.
        if hasattr(self, '_custom_themes_cache'):
            del self._custom_themes_cache
        # --- KONIEC NOWYCH ZMIAN ---

        self._load_custom_themes_list() # Odśwież Listbox z niestandardowymi motywami
        self._update_main_theme_selector() # Odśwież OptionMenu z głównym wyborem motywów

        messagebox.showinfo("Import Zakończony", f"Motyw '{new_name}' został pomyślnie zaimportowany.", parent=parent_window.master)
        if parent_window.winfo_exists(): # Zamknij okno importu
            parent_window.destroy()

    def edit_game(self, game_name):
        if game_name not in self.games:
             messagebox.showerror("Błąd", f"Gra '{game_name}' nie została znaleziona.")
             return
        # Użyj kopii, aby uniknąć modyfikacji oryginału przed zapisem
        game_data_original = self.games[game_name].copy()
        game_data_original['name'] = game_name # Przekaż nazwę do formularza

        edit_window = GameForm(self, "Edytuj Grę", game_name, game_data_original)
        self.root.wait_window(edit_window.top) # Czeka aż okno GameForm zostanie zamknięte

        if edit_window.result:
            returned_name, new_game_data = edit_window.result # returned_name to oryginalna nazwa (klucz)

            # Pobierz istniejące statystyki, aby ich nie nadpisać
            stats_to_preserve = {
                "play_time": game_data_original.get("play_time", 0),
                "completion": game_data_original.get("completion", 0),
                "last_played": game_data_original.get("last_played", None),
                "play_sessions": game_data_original.get("play_sessions", []),
                "date_added": game_data_original.get("date_added", time.time()) # Zachowaj oryginalną datę dodania
            }
            # Połącz nowe dane z formularza z zachowanymi statystykami
            final_game_data = {**new_game_data, **stats_to_preserve}

            # Zaktualizuj dane gry w głównym słowniku
            self.games[returned_name] = final_game_data
            save_config(self.config) # Zapisz zmiany do pliku JSON
              # --- NOWE: Sprawdź osiągnięcia po edycji ---
            self.check_and_unlock_achievements()
              # --- KONIEC NOWEGO ---
            # --- WYMUSZONE ODŚWIEŻENIE UI ---
            logging.debug(f"Dane gry '{returned_name}' zaktualizowane. Wymuszanie odświeżenia UI.")

            # 1. Ogólne odświeżenie siatki (może nie odświeżyć obrazka od razu)
            self.reset_and_update_grid()

            # 2. Wymuś przepopulowanie konkretnego kafelka po krótkiej chwili
            #   (Daje czas Tkinterowi i systemowi plików na przetworzenie)
            self.root.after(100, lambda gn=returned_name: self._force_refresh_tile(gn))

            # 3. Odśwież inne elementy zależne od danych gier
            self.update_tag_filter_options()
            self.create_home_page() # Odśwież stronę główną na wypadek zmian w statystykach

            # 4. Odśwież otwarte okno szczegółów (jeśli istnieje)
            details_title = f"Szczegóły Gry - {game_name}"
            for widget in self.root.winfo_children():
                if isinstance(widget, tk.Toplevel) and widget.title() == details_title:
                    if isinstance(widget, GameDetailsWindow):
                        logging.debug(f"Odświeżanie otwartego okna szczegółów dla: {game_name}")
                        widget.refresh_details_data()
                        break
            # --- KONIEC WYMUSZONEGO ODŚWIEŻENIA ---

# --- NOWA METODA POMOCNICZA ---
    def _force_refresh_tile(self, game_name):
        """Wymusza ponowne załadowanie zawartości konkretnego kafelka."""
        logging.debug(f"Próba wymuszonego odświeżenia kafelka dla: {game_name}")
        if self.library_view_mode.get() != 'tiles':
             logging.debug("Widok inny niż kafelki, pomijam wymuszone odświeżenie.")
             return # Działaj tylko w widoku kafelków

        # Znajdź ramkę kafelka dla tej gry
        tile_frame_widget = None
        if hasattr(self, 'games_frame') and self.games_frame.winfo_exists():
             for widget in self.games_frame.winfo_children():
                 if hasattr(widget, 'game_info') and widget.game_info['name'] == game_name:
                     tile_frame_widget = widget
                     break

        if tile_frame_widget and tile_frame_widget.winfo_exists():
             logging.info(f"Znaleziono kafelek dla '{game_name}'. Wywołuję _populate_game_tile.")
             # Pobierz aktualne dane gry i wymiary kafelka
             game_data = self.games.get(game_name)
             if game_data:
                 current_width = getattr(self, 'current_tile_width', 200)
                 current_height = self.tile_height
                 # Wywołaj funkcję wypełniającą, która ponownie załaduje obrazek (bo cache został wyczyszczony w save)
                 self._populate_game_tile(tile_frame_widget, game_name, game_data, current_width, current_height)
                 # Dodatkowo upewnijmy się, że Tkinter odświeży widok
                 tile_frame_widget.update_idletasks()
                 self.canvas.update_idletasks() # Może też pomóc
             else:
                 logging.warning(f"Nie znaleziono danych dla gry '{game_name}' podczas wymuszonego odświeżania.")
        else:
             logging.warning(f"Nie znaleziono widocznego kafelka dla '{game_name}' do wymuszonego odświeżenia.")

    def delete_game(self, game_name):
            confirm = messagebox.askyesno("Usuń Grę", f"Czy na pewno chcesz usunąć grę '{game_name}'?")
            if confirm:
                if game_name in self.games:
                    # Usuń obraz okładki (jeśli jest zarządzany)
                    cover_image = self.games[game_name].get("cover_image")
                    if cover_image and os.path.exists(cover_image):
                        # Sprawdź, czy okładka jest w naszym folderze IMAGES
                        if os.path.dirname(os.path.abspath(cover_image)) == os.path.abspath(IMAGES_FOLDER):
                            try:
                                os.remove(cover_image)
                                logging.info(f"Usunięto zarządzaną okładkę: {cover_image}")
                            except OSError as e:
                                logging.error(f"Nie udało się usunąć okładki {cover_image}: {e}")
                        else:
                            logging.info(f"Okładka {cover_image} nie jest zarządzana, nie usuwam.")

                    # --- USUNIĘTO KOD USUWANIA MINIATURKI ---

                    # Usuń folder zapisów
                    backup_path = os.path.join(GAMES_FOLDER, game_name)
                    if os.path.exists(backup_path):
                        shutil.rmtree(backup_path)
                    # Usuń z grup
                    for group in self.groups.values():
                        if game_name in group:
                            group.remove(game_name)
                    # Usuń grę
                    del self.games[game_name]
                    save_config(self.config)

                    # Odśwież widoki powiązane z biblioteką
                    self.reset_and_update_grid()      # Odśwież siatkę w Bibliotece
                    self.update_tag_filter_options()  # Odśwież filtry tagów (jeśli usuwana gra miała unikalny tag)
                    if hasattr(self, 'roadmap_game_name'):
                        # Zaktualizuj listę gier w comboboxie na stronie roadmapy
                        self.roadmap_game_name['values'] = list(self.games.keys())
                    
                    # --- NOWE ZMIANY ---
                    # Odśwież sekcje na stronie głównej (ostatnio grane, losowe gry, statystyki czasu)
                    # Sprawdź, czy obiekty odpowiedzialne za Home Page zostały już zainicjowane
                    # (powinny być, gdyż create_home_page jest wywoływane w __init__).
                    if hasattr(self, 'home_frame'): 
                        # Używamy root.after(0, ...), aby zaplanować aktualizację w głównym wątku GUI
                        # po zakończeniu bieżącej operacji (delete_game).
                        self.root.after(0, self._update_home_lists) # Odświeża listy gier na stronie głównej
                        self.root.after(0, self.update_time_stats) # Odświeża statystyki czasu gry
                    # --- KONIEC NOWYCH ZMIAN ---

                else:
                    messagebox.showwarning("Błąd", "Gra nie istnieje w bazie danych.")

    def add_group(self):
        group_name = simpledialog.askstring("Dodaj Grupę Statyczną", "Podaj nazwę nowej grupy:") # Zmień tytuł okna
        if group_name:
            if group_name == "Wszystkie Gry" or group_name.startswith("---"): # Nie pozwól na zarezerwowane nazwy
                 messagebox.showwarning("Błąd", f"Nazwa '{group_name}' jest zarezerwowana.")
                 return
            if group_name in self.groups:
                messagebox.showwarning("Błąd", "Grupa statyczna o tej nazwie już istnieje.")
            elif group_name in self.config.get("saved_filters", {}): # Sprawdź też kolizję z filtrami
                 messagebox.showwarning("Błąd", f"Istnieje już filtr zaawansowany o nazwie '{group_name}'.")
            else:
                self.groups[group_name] = []
                save_config(self.config)
                # --- ZMIANA: Wywołaj aktualizację nowego menu ---
                self.update_filter_group_menu()
                # --- KONIEC ZMIANY ---
                messagebox.showinfo("Sukces", f"Grupa statyczna '{group_name}' została dodana.")
                # Ustaw nowo dodaną grupę jako aktywną (opcjonalne)
                self.filter_or_group_var.set(group_name)
                self.reset_and_update_grid() # Odśwież siatkę

    # Upewnij się, że update_group_menu również resetuje paginację
    def update_filter_group_menu(self):
        groups = ["Wszystkie Gry"] + list(self.groups.keys())
        # Bezpieczniej jest zniszczyć i stworzyć OptionMenu na nowo
        if hasattr(self, 'group_menu') and self.group_menu.winfo_exists():
            self.group_menu.destroy()

        # Użyj lambda, aby przekazać wartość i wywołać reset_and_update_grid
        command_func = lambda value: (self.group_var.set(value), self.reset_and_update_grid())
        self.group_menu = ttk.OptionMenu(self.header, self.group_var, "Wszystkie Gry", *groups, command=command_func)
        self.group_menu.grid(row=0, column=3, padx=10, pady=10)
        self.group_var.set("Wszystkie Gry") # Ustaw domyślną wartość

        # Wywołaj reset and update od razu po zmianie menu, jeśli grupa "Wszystkie Gry" była wybrana
        self.reset_and_update_grid()

    def add_to_group(self, game_name):
        groups = list(self.groups.keys())
        if not groups:
            messagebox.showwarning("Błąd", "Nie utworzono żadnych grup. Najpierw dodaj grupę.")
            return

        selected_group = simpledialog.askstring("Dodaj do Grupy", f"Wybierz grupę dla gry '{game_name}':\n" + "\n".join(groups))
        if selected_group in groups:
            if game_name not in self.groups[selected_group]:
                self.groups[selected_group].append(game_name)
                save_config(self.config)
                messagebox.showinfo("Sukces", f"Gra '{game_name}' została dodana do grupy '{selected_group}'.")
            else:
                messagebox.showwarning("Błąd", f"Gra '{game_name}' już znajduje się w grupie '{selected_group}'.")
        else:
            messagebox.showwarning("Błąd", "Wybrana grupa nie istnieje.")

    def remove_from_group(self, game_name):
        group = self.group_var.get()
        if group != "Wszystkie Gry":
            if game_name in self.groups.get(group, []):
                self.groups[group].remove(game_name)
                save_config(self.config)
                messagebox.showinfo("Sukces", f"Gra '{game_name}' została usunięta z grupy '{group}'.")
                # self.update_game_grid() # Zamiast tego:
                self.reset_and_update_grid() # Odśwież widok bieżącej grupy (teraz bez tej gry)
            else:
                messagebox.showwarning("Błąd", f"Gra '{game_name}' nie znajduje się w grupie '{group}'.")

    def show_home(self):
        self.home_frame.tkraise()
        self.current_frame = self.home_frame
        # --- ZMIANA ---
        self.current_section = "Na Stronie Głównej"
        self._update_discord_status(status_type="browsing", activity_details=self.current_section)
        # --- KONIEC ZMIANY ---

# W klasie GameLauncher

    def show_mod_manager(self):
        """Pokazuje Menedżera Modów, tworząc go przy pierwszym użyciu."""
        self._hide_library_components()
        self._ensure_mod_manager()
        if self.extended_mod_manager:
             # --- NOWE ZMIANY ---
             self.extended_mod_manager.frame.grid() # Upewnij się, że ramka Mod Managera jest w gridzie
             # --- KONIEC NOWYCH ZMIAN ---
             self.extended_mod_manager.frame.tkraise()
             self.current_frame = self.extended_mod_manager.frame
             # --- POPRAWIONE WCIĘCIE ---
             self.current_section = "Zarządza Modami"
             self._update_discord_status(status_type="browsing", activity_details=self.current_section)
             # --- KONIEC POPRAWKI ---
        else:
             logging.error("Nie udało się stworzyć lub pokazać Menedżera Modów.")
             # messagebox.showerror("Błąd", "Nie można otworzyć Menedżera Modów.")

# Dodaj metodę _show_developer_console w klasie GameLauncher
    def _show_developer_console(self):
        """
        Otwiera okno konsoli deweloperskiej z pomiarem czasu startu.
        """
        dev_console_window = tk.Toplevel(self.root)
        dev_console_window.title("Developer Console")
        dev_console_window.configure(bg="#1e1e1e")
        # --- NOWE ZMIANY ---
        # Zwiększona wysokość, aby pomieścić wszystkie informacje i przyszłe dodatki.
        # Nowe wartości są dostosowane, by pomieścić ~20-25 linii tekstu plus elementy sterujące.
        dev_console_window.geometry("500x700") 
        dev_console_window.minsize(400, 600) # Zwiększona minimalna wysokość
        # --- KONIEC NOWYCH ZMIAN ---
        dev_console_window.grab_set()

        # Sekcja czasu uruchomienia
        time_frame = ttk.LabelFrame(dev_console_window, text=" Czasy uruchomienia (ms) ", padding=(10,5))
        time_frame.pack(fill="both", expand=True, padx=10, pady=10)
        time_frame.columnconfigure(1, weight=1) # Kolumna z wartością rośnie

        current_row_idx = 0
        previous_time = 0

        # Wyświetl podsumowanie wszystkich punktów czasowych
        sorted_checkpoints = sorted(self.start_up_time_points.items(), key=lambda item: item[1])

        # Pierwsza linia jako suma total
        total_start_time = sorted_checkpoints[-1][1] if sorted_checkpoints else 0
        ttk.Label(time_frame, text="Całkowity czas uruchomienia:").grid(row=current_row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(time_frame, text=f"{total_start_time:.2f} ms", font=("Segoe UI", 9, "bold")).grid(row=current_row_idx, column=1, padx=5, pady=2, sticky="e")
        current_row_idx += 1
        
        # Oddzielnik
        ttk.Separator(time_frame, orient='horizontal').grid(row=current_row_idx, column=0, columnspan=2, sticky="ew", pady=(5,10))
        current_row_idx += 1


        for checkpoint_name, elapsed_time in sorted_checkpoints:
            duration_from_previous = elapsed_time - previous_time
            previous_time = elapsed_time

            ttk.Label(time_frame, text=f"-> {checkpoint_name}:").grid(row=current_row_idx, column=0, padx=5, pady=2, sticky="w")
            # Czas bezwzględny
            ttk.Label(time_frame, text=f"{elapsed_time:.2f} ms", font=("Segoe UI", 8)).grid(row=current_row_idx, column=1, padx=5, pady=2, sticky="e")
            # Opcjonalnie: czas trwania od poprzedniego punktu
            # ttk.Label(time_frame, text=f"(+{duration_from_previous:.2f} ms)").grid(row=current_row_idx, column=2, padx=5, pady=2, sticky="w")
            current_row_idx += 1

        # Przycisk "Zamknij"
        ttk.Button(dev_console_window, text="Zamknij", command=dev_console_window.destroy).pack(pady=10)

        dev_console_window.wait_window(dev_console_window) # Czekaj na zamknięcie okna

    # Modyfikacja metody _post_init_heavy_jobs (istniejącej)
    def _post_init_heavy_jobs(self):
        """Uruchamia zadania, które nie są krytyczne dla pierwszego wyświetlenia UI, z opóźnieniem."""
        logging.info("Uruchamianie zadań po inicjalizacji interfejsu (delayed heavy jobs)...")
        self.record_startup_time("post_init_heavy_jobs_start")

        # Uruchamiamy wszystkie wątki w tej funkcji, aby nie obciążały głównego wątku startowego.
        threading.Thread(target=self.controller_listener, daemon=True).start()
        self.record_startup_time("post_init_controller_listener")

        if self.local_settings.get("discord_rpc_enabled", False):
            self.root.after(100, self._start_discord_rpc) # Uruchom RPC z małym opóźnieniem
            self.record_startup_time("post_init_discord_rpc")
            
        if self.local_settings.get("remote_control_enabled", False):
            self.root.after(200, self._start_flask_server)
            self.record_startup_time("post_init_flask_server")

        self.root.after(500, self._register_music_hotkeys) # Zarejestruj skróty globalne z opóźnieniem
        self.record_startup_time("post_init_music_hotkeys")

        threading.Thread(target=self.perform_update_check, daemon=True).start()
        self.record_startup_time("post_init_update_check")

        threading.Thread(target=self.monitor_game_sessions, daemon=True).start()
        self.record_startup_time("post_init_game_sessions_monitor")

        threading.Thread(target=self.monitor_reminders, daemon=True).start()
        self.record_startup_time("post_init_reminders_monitor")

        threading.Thread(target=self._monitor_discord_connection, daemon=True).start()
        self.record_startup_time("post_init_discord_monitor")

        if self.settings.get("autoscan_on_startup", False):
             self.root.after(3000, self.start_scan_screenshots_thread)
             self.record_startup_time("post_init_screenshot_scan")

        self.root.after(1000, self._update_current_session_time_display)
        self.root.after(500, self._initialize_track_overlay_from_settings) # overlay też powinien poczekać
        self.record_startup_time("post_init_end")

    def show_library(self):
        # Upewnij się, że ramka Biblioteki jest w gridzie
        self.main_frame.grid() 
        self.main_frame.tkraise()
        self.current_frame = self.main_frame

        # --- NOWE ZMIANY ---
        if not self._library_initialized:
            logging.info("Tworzenie zawartości strony Biblioteki po raz pierwszy (lazy init).")
            # Tutaj wywołaj tworzenie UI SPECIFIC dla Biblioteki
            # Pamiętaj, create_header i create_game_grid były już przeniesione jako stubs.
            # Teraz wywołamy je, gdy strona będzie faktycznie potrzebna.
            self.create_header() 
            self.create_game_grid()
            self._library_initialized = True # Ustaw flagę, że już zainicjalizowano
            # Te wywołania prawdopodobnie wystąpią po "init_library_created"
        
        # update_game_grid zawsze aktualizuje zawartość
        self.update_game_grid() # Odśwież siatkę po wejściu
        # --- KONIEC NOWYCH ZMIAN ---

        self.current_section = "Przegląda Bibliotekę"
        self._update_discord_status(status_type="browsing", activity_details=self.current_section)
        
    def get_all_available_themes(self):
        """Zwraca połączony słownik motywów wbudowanych i niestandardowych (ładowanych z plików)."""
        all_themes = THEMES.copy() # Zacznij od kopii wbudowanych motywów

        # --- NOWE ZMIANY ---
        # Cache dla wczytanych motywów niestandardowych, aby uniknąć ciągłego czytania z dysku.
        # Format: {'filename': {'name': 'ThemeName', 'definition': {...}, '_mtime': timestamp}}
        if not hasattr(self, '_custom_themes_cache'):
            self._custom_themes_cache = {}
        
        # Skanuj folder CUSTOM_THEMES_DIR
        if not os.path.isdir(CUSTOM_THEMES_DIR): # Zabezpieczenie na wypadek, gdyby folder nie istniał
            os.makedirs(CUSTOM_THEMES_DIR, exist_ok=True)
            return all_themes # Jeśli dopiero co stworzyliśmy, nie ma w nim motywów

        for filename in os.listdir(CUSTOM_THEMES_DIR):
            if filename.lower().endswith(".json"):
                theme_filepath = os.path.join(CUSTOM_THEMES_DIR, filename)
                try:
                    current_mtime = os.path.getmtime(theme_filepath)
                except OSError as e:
                    logging.warning(f"Nie można odczytać czasu modyfikacji pliku motywu '{filename}': {e}. Pomijanie.")
                    continue # Pominięcie, jeśli nie można odczytać mtime

                # Wczytaj motyw tylko, jeśli nie ma go w cache LUB plik jest nowszy niż ten w cache.
                # Kluczem cache'a jest nazwa pliku.
                if filename not in self._custom_themes_cache or \
                   current_mtime > self._custom_themes_cache[filename].get('_mtime', 0):
                    
                    theme_data_from_file = _load_theme_from_file(theme_filepath)
                    if theme_data_from_file:
                        theme_name = theme_data_from_file["name"]
                        theme_def = theme_data_from_file["definition"]
                        
                        # Sprawdź, czy nazwa motywu z pliku nie koliduje z wbudowanym.
                        # Jeśli tak, logujemy ostrzeżenie i pomijamy ten niestandardowy motyw.
                        if theme_name in THEMES:
                            logging.warning(f"Niestandardowy motyw z pliku '{filename}' o nazwie '{theme_name}' koliduje z wbudowanym motywem. Wbudowany ma priorytet.")
                            continue # Pomiń ten plik niestandardowy, aby nie nadpisał wbudowanego.

                        self._custom_themes_cache[filename] = { # Użyj nazwy pliku jako klucza dla cache
                            "name": theme_name,
                            "definition": theme_def,
                            "_mtime": current_mtime
                        }
                        all_themes[theme_name] = theme_def # Dodaj do słownika wyników
                        logging.debug(f"Załadowano (lub odświeżono) niestandardowy motyw z pliku: {theme_name} ({filename})")
                else:
                    # Użyj motywu z cache, jeśli plik się nie zmienił
                    all_themes[self._custom_themes_cache[filename]["name"]] = self._custom_themes_cache[filename]["definition"]
        # --- KONIEC NOWYCH ZMIAN ---
        
        return all_themes

    def change_theme(self, selected_theme_name): # Zmieniono argument na nazwę
        # --- ZMIANA: Pobierz definicję motywu z połączonego słownika ---
        all_themes = self.get_all_available_themes()
        selected_theme_def = all_themes.get(selected_theme_name)

        if not selected_theme_def:
            logging.error(f"Nie znaleziono definicji dla motywu: {selected_theme_name}. Używam Dark.")
            selected_theme_name = "Dark"
            # --- ZMIANA: Usuń self. ---
            selected_theme_def = THEMES["Dark"]
            # --- KONIEC ZMIANY ---


        old_theme = self.settings.get("theme")
        if old_theme != selected_theme_name: # Porównaj nazwy
            self.settings["theme"] = selected_theme_name # Zapisz nazwę
            self.user["theme_change_count"] = self.user.get("theme_change_count", 0) + 1
            logging.info(f"Licznik zmian motywu: {self.user['theme_change_count']}")
            save_config(self.config)
            # --- ZMIANA: Przekaż definicję motywu ---
            self.apply_theme(selected_theme_def)
            # --- KONIEC ZMIANY ---
            self.check_and_unlock_achievements()



    # Zmodyfikuj apply_theme, aby upewnić się, że zawsze dostaje słownik
    def apply_theme(self, theme_def): # Argument to teraz słownik definicji
        # --- ZMIANA: Upewnij się, że theme_def jest słownikiem ---
        if not isinstance(theme_def, dict):
             logging.error(f"Błąd: apply_theme otrzymało nieprawidłowy typ danych: {type(theme_def)}. Stosuję motyw Dark.")
             # --- ZMIANA: Usuń self. ---
             theme_def = THEMES.get("Dark", {}) # Fallback
             # --- KONIEC ZMIANY ---

        style = ttk.Style(self.root)
        # Użyj .get() z wartością domyślną, na wypadek gdyby w motywie brakowało klucza
        default_bg = '#1e1e1e'
        default_fg = 'white'
        style.configure("TFrame", background=theme_def.get('background', default_bg))
        style.configure("TLabel", background=theme_def.get('background', default_bg), foreground=theme_def.get('foreground', default_fg))
        style.configure("TButton", background=theme_def.get('button_background', default_bg), foreground=theme_def.get('button_foreground', default_fg))
        style.configure("Game.TButton", background=theme_def.get('background', default_bg), foreground=theme_def.get('foreground', default_fg))
        # --- NOWE ZMIANY: Zaktualizuj więcej stylów ---
        style.configure("TEntry", fieldbackground=theme_def.get('entry_background', default_bg), foreground=theme_def.get('foreground', default_fg), insertbackground=theme_def.get('foreground', default_fg))
        
        # --- NOWE ZMIANY ---
        # Stylizacja TCombobox - użyj tych samych kolorów co TEntry
        # Potrzebujemy mapowania, aby lista rozwijana też miała kolory
        style.map('TCombobox', fieldbackground=[('readonly', theme_def.get('entry_background', default_bg))])
        style.map('TCombobox', foreground=[('readonly', theme_def.get('foreground', default_fg))])
        style.map('TCombobox', selectbackground=[('readonly', '#0078d7')]) # Kolor zaznaczenia w liście
        style.map('TCombobox', selectforeground=[('readonly', 'white')])
        # Ustawienie tła listy rozwijanej (może nie działać na wszystkich systemach/motywach Tk)
        # root.option_add('*TCombobox*Listbox.background', theme_def.get('entry_background', default_bg))
        # root.option_add('*TCombobox*Listbox.foreground', theme_def.get('foreground', default_fg))
        # root.option_add('*TCombobox*Listbox.selectBackground', '#0078d7')
        # root.option_add('*TCombobox*Listbox.selectForeground', 'white')
        # --- KONIEC NOWYCH ZMIAN ---
        style.configure("TSpinbox", fieldbackground=theme_def.get('entry_background', default_bg), foreground=theme_def.get('foreground', default_fg)) # Dodajmy też Spinbox
        try:
             style.configure("Treeview", background=theme_def.get('tree_background', default_bg), foreground=theme_def.get('foreground', default_fg), fieldbackground=theme_def.get('tree_background', default_bg))
             style.map("Treeview", background=[('selected', '#0078d7')]) # Na razie zostawmy domyślne zaznaczenie
             style.configure("Treeview.Heading", background=theme_def.get('tree_heading', default_bg), foreground=theme_def.get('foreground', default_fg))
        except tk.TclError as e:
             logging.warning(f"Nie można ustawić niektórych stylów Treeview: {e}")
        
        # Scrollbar
        style.configure("TScrollbar", background=theme_def.get('scrollbar_slider', '#555555'), troughcolor=theme_def.get('scrollbar_trough', default_bg), bordercolor=theme_def.get('background', default_bg), arrowcolor=theme_def.get('foreground', default_fg))
        # Linki
        style.configure("Link.TButton", foreground=theme_def.get('link_foreground', '#66b3ff'), background=theme_def.get('background', default_bg))
        # --- KONIEC NOWYCH ZMIAN ---

        # Zastosuj tło głównego okna i ramek bocznych
        self.root.configure(bg=theme_def.get('background', default_bg))
        if hasattr(self, 'sidebar'): self.sidebar.configure(style="TFrame") # Użyj stylu TFrame
        if hasattr(self, 'main_frame'): self.main_frame.configure(style="TFrame")
        if hasattr(self, 'home_frame'): self.home_frame.configure(style="TFrame")
        # Zaktualizuj tło canvasów (jeśli istnieją)
        if hasattr(self, 'canvas') and self.canvas.winfo_exists(): self.canvas.config(bg=theme_def.get('background', default_bg))
        if hasattr(self, 'settings_page_frame'):
             settings_canvas = self.settings_page_frame.winfo_children()[0] if self.settings_page_frame.winfo_children() else None
             if isinstance(settings_canvas, tk.Canvas): settings_canvas.config(bg=theme_def.get('background', default_bg))
        # Można dodać aktualizację innych ramek/canvasów...

        # Odśwież okno, aby zastosować zmiany (może powodować mignięcie)
        self.root.update_idletasks()
        # --- NOWE ZMIANY: Odśwież stronę muzyki, jeśli istnieje ---
        if hasattr(self, 'music_player_page_instance') and self.music_player_page_instance:
            if hasattr(self.music_player_page_instance, 'apply_theme_colors') and \
               self.music_player_page_instance.parent_frame.winfo_exists(): # Sprawdź, czy ramka strony muzyki wciąż istnieje
                logging.debug("apply_theme (GameLauncher): Wywoływanie apply_theme_colors dla MusicPlayerPage.")
                self.music_player_page_instance.apply_theme_colors()
            else:
                logging.debug("apply_theme (GameLauncher): Instancja MusicPlayerPage istnieje, ale brakuje metody apply_theme_colors lub ramka nie istnieje.")
        else:
            logging.debug("apply_theme (GameLauncher): Instancja MusicPlayerPage nie istnieje, nie ma czego odświeżać.")
        # --- KONIEC NOWYCH ZMIAN ---
        
    def _update_main_theme_selector(self):
        """Odświeża główny OptionMenu wyboru motywu."""
        if hasattr(self, 'theme_menu') and self.theme_menu.winfo_exists():
             menu = self.theme_menu["menu"]
             menu.delete(0, "end")
             all_themes = self.get_all_available_themes()
             current_theme_name = self.settings.get("theme", "Dark")

             # Upewnij się, że aktualnie wybrany motyw istnieje
             if current_theme_name not in all_themes:
                  current_theme_name = "Dark"
                  self.theme_var.set(current_theme_name) # Ustaw zmienną na domyślną
                  self.settings["theme"] = current_theme_name # Zaktualizuj ustawienia
                  save_config(self.config) # Zapisz zmianę

             for theme_name in sorted(all_themes.keys()):
                  menu.add_command(label=theme_name, command=tk._setit(self.theme_var, theme_name, self.change_theme))

             # Ustaw aktualną wartość (ponownie dla pewności)
             self.theme_var.set(current_theme_name)
        else:
             logging.warning("Nie można zaktualizować theme_menu - widget nie istnieje.")

    def _load_custom_themes_list(self):
        """Wczytuje nazwy niestandardowych motywów (z plików) do Listboxa w ustawieniach."""
        if hasattr(self, 'custom_themes_listbox') and self.custom_themes_listbox.winfo_exists():
            self.custom_themes_listbox.delete(0, tk.END)
            # --- NOWE ZMIANY ---
            custom_theme_names = []
            if os.path.isdir(CUSTOM_THEMES_DIR):
                for filename in os.listdir(CUSTOM_THEMES_DIR):
                    if filename.lower().endswith(".json"):
                        filepath = os.path.join(CUSTOM_THEMES_DIR, filename)
                        theme_data = _load_theme_from_file(filepath)
                        if theme_data:
                            # Sprawdź, czy nazwa motywu z pliku nie koliduje z wbudowanymi, aby uniknąć duplikatów w UI.
                            if theme_data["name"] not in THEMES: # THEMES to stała z wbudowanymi motywami
                                custom_theme_names.append(theme_data["name"])
                            else:
                                logging.warning(f"Motyw '{theme_data['name']}' z pliku '{filename}' koliduje z wbudowanym i zostanie pominięty na liście niestandardowych.")
            
            for theme_name in sorted(custom_theme_names, key=str.lower): # Sortuj dla czytelności
                self.custom_themes_listbox.insert(tk.END, theme_name)
            # --- KONIEC NOWYCH ZMIAN ---

    def _add_custom_theme(self):
        """Otwiera edytor dla nowego motywu niestandardowego i zapisuje go do pliku."""
        editor = ThemeEditorWindow(self.settings_page_frame, self)
        if editor.result:
            theme_name = editor.result["name"]
            theme_def = editor.result["theme_def"]

            # --- NOWE ZMIANY ---
            # Zapisz motyw do pliku JSON w CUSTOM_THEMES_DIR.
            # Normalizujemy nazwę pliku, aby była bezpieczna dla systemu plików.
            safe_filename = re.sub(r'[\\/*?:"<>|]', "_", theme_name).strip()
            theme_filepath = os.path.join(CUSTOM_THEMES_DIR, f"{safe_filename}.json")

            # Dodatkowa walidacja i pytanie o nadpisanie są w _process_theme_import (dla importu)
            # oraz w _edit_custom_theme (dla edycji, która robi nadpisanie).
            # Tutaj (add_custom_theme) zakładamy, że ThemeEditorWindow w trybie "add"
            # upewnił się, że nazwa nie koliduje z wbudowanymi, a jeśli kolidowała z niestandardowymi,
            # to użytkownik został o tym poinformowany (ta walidacja jest robiona np. w GameLauncher._process_theme_import
            # jeśli przez import albo musiałaby być w _save w ThemeEditorWindow jeśli tworzysz to tam).
            # Dla pewności, dodajemy walidację na nazwie pliku również tutaj.
            
            if theme_name in THEMES:
                messagebox.showerror("Błąd Nazwy", f"Nazwa '{theme_name}' jest zarezerwowana dla motywu wbudowanego.", parent=self.settings_page_frame)
                return
            
            # W `_add_custom_theme`, jeśli `theme_filepath` już istnieje, to oznacza duplikat
            # który powinien być wykryty w `ThemeEditorWindow` lub tu, przed próbą zapisu.
            if os.path.exists(theme_filepath):
                # Ten przypadek powinien być obsłużony przez walidację unikalności nazw w `ThemeEditorWindow` przed zwróceniem `result`.
                # Jeśli `ThemeEditorWindow` jest tak skonfigurowane, że `editor.result` zawiera nową, *unikalną* nazwę, to `os.path.exists` będzie tu zawsze fałszywe dla NOWEGO pliku.
                # Ale na wszelki wypadek (jeśli nazwę motywu można zmienić tak, by kolidowała z inną, już istniejącą w pliku).
                logging.warning(f"Plik motywu '{theme_filepath}' już istnieje, może wystąpił problem z walidacją nazwy.")
                # Nie nadpisujemy bez pytania; zakładamy, że `ThemeEditorWindow` dba o to, że wynik `result` jest prawidłowy.

            try:
                os.makedirs(CUSTOM_THEMES_DIR, exist_ok=True) # Upewnij się, że folder istnieje
                with open(theme_filepath, "w", encoding="utf-8") as f:
                    # Zapisz słownik zawierający klucze "name" i "definition"
                    json.dump({"name": theme_name, "definition": theme_def}, f, indent=2, ensure_ascii=False)
                logging.info(f"Zapisano nowy motyw niestandardowy do pliku: {theme_filepath}")
            except Exception as e:
                messagebox.showerror("Błąd Zapisu Motywu", f"Nie udało się zapisać motywu '{theme_name}' do pliku:\n{e}", parent=self.settings_page_frame)
                return # Zakończ, jeśli zapis się nie powiódł
            
            # Wyczyść cache motywów, aby `get_all_available_themes` odczytał nowy motyw z dysku
            if hasattr(self, '_custom_themes_cache'):
                del self._custom_themes_cache
            
            self._load_custom_themes_list() # Odśwież listę w ustawieniach (zczyta z pliku)
            self._update_main_theme_selector() # Odśwież główny wybór motywów (pobierze nowy motyw)
            # --- KONIEC NOWYCH ZMIAN ---

    def _edit_custom_theme(self):
        """Otwiera edytor dla wybranego motywu niestandardowego i aktualizuje plik."""
        if not hasattr(self, 'custom_themes_listbox'): return
        selection = self.custom_themes_listbox.curselection()
        if not selection:
            messagebox.showwarning("Brak zaznaczenia", "Zaznacz motyw niestandardowy, który chcesz edytować.", parent=self.settings_page_frame)
            return
        theme_name_to_edit = self.custom_themes_listbox.get(selection[0])
        
        # --- NOWE ZMIANY ---
        # Wczytaj dane motywu z PLIKU, nie ze słownika self.settings
        # Stary filepath (na wypadek zmiany nazwy)
        safe_old_filename = re.sub(r'[\\/*?:"<>|]', "_", theme_name_to_edit).strip()
        filepath_to_edit = os.path.join(CUSTOM_THEMES_DIR, f"{safe_old_filename}.json")
        
        if not os.path.exists(filepath_to_edit):
             messagebox.showerror("Błąd", f"Nie znaleziono pliku dla motywu '{theme_name_to_edit}'. Może został usunięty lub zmieniono nazwę.", parent=self.settings_page_frame)
             self._load_custom_themes_list() # Odśwież listę na wszelki wypadek
             return
             
        initial_data_from_file = _load_theme_from_file(filepath_to_edit)
        if not initial_data_from_file: # Jeśli plik jest, ale jest uszkodzony/ma złą strukturę
             messagebox.showerror("Błąd Wczytywania", f"Nie można wczytać danych z pliku motywu '{theme_name_to_edit}'. Plik jest uszkodzony lub ma nieprawidłową strukturę.", parent=self.settings_page_frame)
             self._load_custom_themes_list() # Odśwież listę, aby usunąć uszkodzony wpis z widoku
             return

        # Przekaż do edytora: name i definition z wczytanego pliku
        editor = ThemeEditorWindow(self.settings_page_frame, self, 
                                   theme_name=initial_data_from_file["name"], # Przekazujemy nazwę zapisaną w pliku
                                   theme_data=initial_data_from_file["definition"]) # Oraz definicję kolorów
        
        if editor.result:
            new_name = editor.result["name"]
            new_theme_def = editor.result["theme_def"]

            safe_new_filename = re.sub(r'[\\/*?:"<>|]', "_", new_name).strip()
            new_filepath = os.path.join(CUSTOM_THEMES_DIR, f"{safe_new_filename}.json")

            if new_name != theme_name_to_edit: # Jeśli nazwa motywu FAKTYCZNIE się zmieniła
                if new_name in THEMES: # Nowa nazwa koliduje z wbudowanym motywem
                     messagebox.showerror("Błąd Nazwy", f"Nowa nazwa '{new_name}' jest zarezerwowana dla motywu wbudowanego.", parent=self.settings_page_frame)
                     return
                # Sprawdź, czy nowy plik motywu już istnieje (np. jeśli użytkownik podał nazwę innego istniejącego motywu niestandardowego)
                if os.path.exists(new_filepath) and os.path.normcase(new_filepath) != os.path.normcase(filepath_to_edit):
                    if not messagebox.askyesno("Nadpisać?", f"Plik dla nowej nazwy '{new_name}' już istnieje.\nCzy chcesz go nadpisać?", parent=self.settings_page_frame):
                          return

                # Usuń stary plik (po upewnieniu się, że nowa nazwa jest poprawna i użytkownik ewentualnie potwierdził nadpisanie)
                # Działamy tylko jeśli stara nazwa jest inna, bo edycja bez zmiany nazwy nie powinna kasować.
                if os.path.exists(filepath_to_edit):
                    try:
                        os.remove(filepath_to_edit)
                        logging.info(f"Usunięto stary plik motywu: {filepath_to_edit}")
                    except OSError as e:
                        logging.error(f"Nie udało się usunąć starego pliku motywu '{filepath_to_edit}': {e}")
                        messagebox.showwarning("Błąd Usuwania", f"Nie udało się usunąć starego pliku motywu:\n{e}\n\nMotyw mógł nie zostać w pełni zaktualizowany.", parent=self.settings_page_frame)
                        # Kontynuuj, ale użytkownik może mieć niespójne pliki.

            try: # Zapisz nowy plik (lub nadpisz istniejący, jeśli nazwa nie zmieniła się lub user potwierdził nadpisanie)
                with open(new_filepath, "w", encoding="utf-8") as f:
                    json.dump({"name": new_name, "definition": new_theme_def}, f, indent=2, ensure_ascii=False)
                logging.info(f"Zapisano zaktualizowany motyw niestandardowy do pliku: {new_filepath}")
            except Exception as e:
                messagebox.showerror("Błąd Zapisu Motywu", f"Nie udało się zapisać zaktualizowanego motywu '{new_name}' do pliku:\n{e}", parent=self.settings_page_frame)
                return

            # Wyczyść cache motywów, aby GameLauncher załadował świeżą listę z dysku
            if hasattr(self, '_custom_themes_cache'):
                del self._custom_themes_cache
            
            self._load_custom_themes_list() # Odśwież listę w edytorze (zczyta z plików)
            self._update_main_theme_selector() # Odśwież główny wybór motywów (pobierze nowy)
            
            # Jeśli edytowano aktualnie używany motyw, zastosuj zmiany od razu.
            # Zmieniliśmy klucz dostępu do definicji (get_all_available_themes), ale styl pozostałby ten sam
            # w metodzie apply_theme.
            if self.settings.get("theme") == new_name:
                 # Odświeżanie głównego motywu przez `apply_theme` używa `get_all_available_themes`,
                 # która jest już zaktualizowana, bo wyczyściliśmy `_custom_themes_cache`.
                 # Więc wystarczy, że wywoła się apply_theme z nazwą:
                 self.apply_theme(self.get_all_available_themes().get(new_name, THEMES['Dark']))
                 
        # --- KONIEC NOWYCH ZMIAN ---

    def _delete_custom_theme(self):
        """Usuwa wybrany motyw niestandardowy (pliku)."""
        if not hasattr(self, 'custom_themes_listbox'): return
        selection = self.custom_themes_listbox.curselection()
        if not selection:
            messagebox.showwarning("Brak zaznaczenia", "Zaznacz motyw niestandardowy, który chcesz usunąć.", parent=self.settings_page_frame)
            return
        theme_name_to_delete = self.custom_themes_listbox.get(selection[0])

        if theme_name_to_delete in THEMES: # Stała THEMES zawiera wbudowane motywy
             messagebox.showerror("Błąd", f"Nie można usunąć wbudowanego motywu '{theme_name_to_delete}'.", parent=self.settings_page_frame)
             return

        if messagebox.askyesno("Potwierdź usunięcie", f"Czy na pewno chcesz usunąć motyw niestandardowy '{theme_name_to_delete}'?\nOperacja jest nieodwracalna!", parent=self.settings_page_frame):
            # --- NOWE ZMIANY ---
            # Usuń plik motywu z CUSTOM_THEMES_DIR.
            # Konwertujemy nazwę motywu na bezpieczną nazwę pliku, tak samo jak przy zapisie.
            safe_filename_to_delete = re.sub(r'[\\/*?:"<>|]', "_", theme_name_to_delete).strip()
            filepath_to_delete = os.path.join(CUSTOM_THEMES_DIR, f"{safe_filename_to_delete}.json")

            if os.path.exists(filepath_to_delete):
                try:
                    os.remove(filepath_to_delete)
                    logging.info(f"Usunięto plik motywu: {filepath_to_delete}")
                except OSError as e:
                    messagebox.showerror("Błąd Usuwania", f"Nie udało się usunąć pliku motywu '{filepath_to_delete}':\n{e}\n\nSpróbuj usunąć ręcznie.", parent=self.settings_page_frame)
                    logging.error(f"Nie udało się usunąć pliku motywu '{filepath_to_delete}': {e}")
                    return # Przerwij, jeśli błąd usuwania pliku
            else:
                # To się nie powinno zdarzyć, jeśli element był w listboxie i nie został w międzyczasie usunięty ręcznie.
                messagebox.showerror("Błąd", f"Nie znaleziono pliku motywu '{theme_name_to_delete}' do usunięcia. Może został usunięty ręcznie?", parent=self.settings_page_frame)
                self._load_custom_themes_list() # Odśwież, jeśli plik zniknął (np. tylko z Listboxa)
                return # Przerwij, jeśli plik nie istnieje

            # Jeśli aktywny motyw był tym, który został usunięty, przełącz na "Dark"
            active_theme = self.settings.get("theme")
            theme_changed_to_default = False
            if active_theme == theme_name_to_delete:
                self.settings["theme"] = "Dark" # Ustaw "Dark" jako domyślny motyw
                active_theme = "Dark"
                theme_changed_to_default = True
                logging.info(f"Aktywny motyw '{theme_name_to_delete}' został usunięty. Aplikacja przełączy się na motyw 'Dark'.")

            save_config(self.config) # Zapisz zaktualizowany `settings["theme"]`

            # Wyczyść cache motywów, aby `get_all_available_themes` załadowało nową listę z dysku.
            if hasattr(self, '_custom_themes_cache'):
                del self._custom_themes_cache
            
            self._load_custom_themes_list() # Odśwież Listbox z niestandardowymi motywami
            self._update_main_theme_selector() # Odśwież OptionMenu z głównym wyborem motywów

            # Zastosuj nowy aktywny motyw (jeśli nastąpiła zmiana)
            if theme_changed_to_default:
                 self.apply_theme(self.get_all_available_themes().get(active_theme, THEMES["Dark"])) # Zastosuj "Dark"
            # --- KONIEC NOWYCH ZMIAN ---

    def select_background_image(self):
        path = filedialog.askopenfilename(filetypes=[("Obrazy", "*.png;*.jpg;*.jpeg")])
        if path:
            self.background_image_var.set(path)
            self.settings["background_image"] = path
            save_config(self.config)
            self.apply_background_image(path)

    def apply_background_image(self, image_path):
        if os.path.exists(image_path):
            bg_image = Image.open(image_path)
            bg_photo = ImageTk.PhotoImage(bg_image)
            self.root.background_label = tk.Label(self.root, image=bg_photo)
            self.root.background_label.image = bg_photo
            self.root.background_label.place(x=0, y=0, relwidth=1, relheight=1)
            self.root.background_label.lower()  # Umieść tło za innymi widgetami
        else:
            if hasattr(self.root, 'background_label'):
                self.root.background_label.destroy()

    def update_genre_menu(self):
            """Aktualizuje listę dostępnych gatunków w OptionMenu."""
            # Sprawdzamy, czy OptionMenu już istnieje (powinien być tworzony w create_header)
            if not hasattr(self, 'filter_menu') or not self.filter_menu.winfo_exists():
                logging.warning("update_genre_menu: OptionMenu gatunków nie istnieje, pomijam aktualizację.")
                return

            self.genre_options = ["Wszystkie Gatunki"] + self.get_all_genres()
            current_selection = self.filter_var.get()

            # Usuń wszystkie obecne pozycje z menu
            menu = self.filter_menu["menu"]
            menu.delete(0, "end")
            
            # Dodaj nowe opcje
            for option in self.genre_options:
                menu.add_command(label=option, command=tk._setit(self.filter_var, option, self.reset_and_update_grid))
            
            # Jeśli poprzednio wybrana wartość nie istnieje, wróć do domyślnej
            if current_selection not in self.genre_options:
                self.filter_var.set("Wszystkie Gatunki") 


    def _open_folder(self, folder_path):
        """Bezpiecznie otwiera podany folder w eksploratorze plików."""
        if not folder_path:
            logging.warning("Próba otwarcia pustej ścieżki folderu.")
            messagebox.showwarning("Brak Ścieżki", "Ścieżka do folderu nie jest zdefiniowana.", parent=self.root)
            return

        norm_path = os.path.normpath(folder_path) # Normalizuj ścieżkę

        if not os.path.isdir(norm_path):
            logging.warning(f"Próba otwarcia ścieżki, która nie jest folderem: {norm_path}")
            messagebox.showerror("Błąd Ścieżki", f"Podana ścieżka nie jest prawidłowym folderem:\n{norm_path}", parent=self.root)
            return

        try:
            if sys.platform == "win32":
                os.startfile(norm_path)
            elif sys.platform == "darwin": # macOS
                subprocess.run(['open', norm_path])
            else: # linux variants
                subprocess.run(['xdg-open', norm_path])
            logging.info(f"Otwieranie folderu: {norm_path}")
        except Exception as e:
            logging.error(f"Nie można otworzyć folderu '{norm_path}': {e}")
            messagebox.showerror("Błąd", f"Nie można otworzyć folderu:\n{norm_path}\n\nBłąd: {e}", parent=self.root)
    # --- KONIEC NOWEJ METODY ---


    def show_settings(self):
        # Upewnij się, że ramka Ustawień jest w gridzie
        self.settings_page_frame.grid()
        self.settings_page_frame.tkraise()
        self.current_frame = self.settings_page_frame

        # --- NOWE ZMIANY ---
        if not self._settings_initialized:
            logging.info("Tworzenie zawartości strony Ustawień po raz pierwszy (lazy init).")
            self._create_settings_page_content() # To buduje UI strony Ustawień
            self._settings_initialized = True
        
        # Niezależnie od lazy init, te listy zawsze odświeżamy
        self.load_scan_folders_list()
        self.populate_rss_management_frame()
        self.load_ignored_folders()
        self.load_screenshot_ignored_folders()
        self._load_emulators_list()
        self._load_custom_themes_list()
        # Użytkownik i awatar - zawsze odświeżamy
        if hasattr(self, 'settings_username_label') and self.settings_username_label.winfo_exists():
             self.settings_username_label.config(text=f"Nazwa: {self.user.get('username', 'Gracz')}")
        if hasattr(self, 'settings_avatar_label') and self.settings_avatar_label.winfo_exists():
             self._load_and_display_settings_avatar()
        if hasattr(self, 'avatar_var'):
             self.avatar_var.set(self.user.get("avatar", ""))
        # --- KONIEC NOWYCH ZMIAN ---

        self.current_section = "Zmienia Ustawienia"
        self._update_discord_status(status_type="browsing", activity_details=self.current_section)

    def toggle_show_token(self):
        if self.github_token_entry['show'] == '*':
            self.github_token_entry['show'] = ''
        else:
            self.github_token_entry['show'] = '*'

    def save_github_token(self):
        token = self.github_token_entry.get().strip()
        if token:
            self.local_settings["github_token"] = token
            save_local_settings(self.local_settings)
            messagebox.showinfo("Sukces", "Token GitHub został zapisany.")
        else:
            messagebox.showwarning("Błąd", "Token GitHub nie może być pusty.")

    def show_github_token_help(self):
        message = (
            "Jak uzyskać GitHub Personal Access Token:\n\n"
            "1. Przejdź na stronę GitHub: https://github.com/settings/tokens\n"
            "2. Kliknij 'Personal access tokens', wybieramy 'Tokens (classic)' i klikamy 'Generate new token' wybierając 'Generate new token (classic)'.\n"
            "3. Nadaj tokenowi nazwę i ustaw odpowiednie uprawnienia:\n"
            "   - Dla tego programu potrzebujesz uprawnień 'repo'.\n"
            "4. Skopiuj wygenerowany token i wprowadź go w polu tokena w ustawieniach programu.\n\n"
            "**Pamiętaj, aby nie udostępniać swojego tokena publicznie!**"
        )
        messagebox.showinfo("Pomoc - GitHub Token", message)

    def show_progress_window(self, title):
        # --- NOWE ZMIANY ---
        # Jeśli okno postępu już istnieje, po prostu zaktualizuj tytuł i zresetuj
        if hasattr(self, 'progress_window') and self.progress_window.winfo_exists():
            self.progress_window.title(title)
            self.progress_label.config(text="Rozpoczynanie...")
            self.progress_bar['value'] = 0
            # Możesz też podnieść okno na wierzch: self.progress_window.lift()
            # i upewnić się, że jest widoczne, jeśli było zminimalizowane: self.progress_window.deiconify()
            self.progress_window.update_idletasks() # WAŻNE
            return # Nie twórz nowego
        # --- KONIEC NOWYCH ZMIAN ---

        self.progress_window = tk.Toplevel(self.root)
        self.progress_window.title(title)
        # --- NOWA ZMIANA: Ustawienie modalności (opcjonalne, ale może pomóc) ---
        # self.progress_window.grab_set() # To zablokuje interakcję z głównym oknem
        # --- KONIEC NOWEJ ZMIANY ---
        # ... (reszta geometrii, etykiet, paska postępu)
        self.progress_window.geometry("350x120") # Trochę szersze na dłuższy tekst
        self.progress_window.resizable(False, False)
        ttk.Label(self.progress_window, text=title, wraplength=330).pack(pady=5) # wraplength
        self.progress_bar = ttk.Progressbar(self.progress_window, orient='horizontal', mode='determinate', maximum=100)
        self.progress_bar.pack(pady=10, fill='x', padx=20)
        self.progress_label = ttk.Label(self.progress_window, text="0%", wraplength=330) # wraplength
        self.progress_label.pack()
        self.progress_window.protocol("WM_DELETE_WINDOW", self.disable_event)
        self.progress_window.update_idletasks() # WAŻNE: Wymuś narysowanie okna i jego zawartości


    def update_cloud_services(self):
        self.settings["cloud_service_google_drive"] = self.cloud_services["Google Drive"].get()
        self.settings["cloud_service_github"] = self.cloud_services["GitHub"].get()
        save_config(self.config)

    def toggle_autostart(self):
        if self.autostart_var.get():
            # Dodaj do rejestru
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\Run", 0, winreg.KEY_SET_VALUE)
            winreg.SetValueEx(key, "GameLauncher", 0, winreg.REG_SZ, sys.executable + " " + os.path.abspath(__file__))
            winreg.CloseKey(key)
        else:
            # Usuń z rejestru
            try:
                key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\Run", 0, winreg.KEY_ALL_ACCESS)
                winreg.DeleteValue(key, "GameLauncher")
                winreg.CloseKey(key)
            except FileNotFoundError:
                pass

        self.settings["autostart"] = self.autostart_var.get()
        save_config(self.config)

    def change_username(self):
        username = simpledialog.askstring("Zmień Nazwę Użytkownika", "Podaj nową nazwę użytkownika:")
        if username:
            self.user["username"] = username
            save_config(self.config)
            messagebox.showinfo("Sukces", "Nazwa użytkownika została zmieniona.")
            # --- NOWE ZMIANY: Aktualizacja UI ---
            self.create_home_page()  # Odświeżenie strony głównej
            # Zaktualizuj etykietę w ustawieniach, jeśli istnieje
            if hasattr(self, 'settings_username_label') and self.settings_username_label.winfo_exists():
                self.settings_username_label.config(text=f"Nazwa: {username}")
            # --- KONIEC NOWYCH ZMIAN ---
        else:
            messagebox.showwarning("Błąd", "Nazwa użytkownika nie może być pusta.")

    def setup_google_drive(self):
        from google_auth_oauthlib.flow import InstalledAppFlow
        from google.auth.transport.requests import Request
        import pickle

        SCOPES = ['https://www.googleapis.com/auth/drive.file']
        creds = None
        if os.path.exists('token_google_drive.pickle'):
            with open('token_google_drive.pickle', 'rb') as token:
                creds = pickle.load(token)
        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                creds.refresh(Request())
            else:
                if not os.path.exists('credentials.json'):
                    messagebox.showerror("Błąd", "Brak pliku credentials.json dla Google Drive.")
                    return
                flow = InstalledAppFlow.from_client_secrets_file('credentials.json', SCOPES)
                creds = flow.run_local_server(port=0)
            with open('token_google_drive.pickle', 'wb') as token:
                pickle.dump(creds, token)
        self.google_drive_creds = creds
        messagebox.showinfo("Sukces", "Google Drive zostało skonfigurowane.")

    def setup_github(self):
        token = self.local_settings.get("github_token")
        if not token:
            token = simpledialog.askstring("GitHub Token", "Podaj swój GitHub Personal Access Token:", show='*')
            if token:
                self.local_settings["github_token"] = token
                save_local_settings(self.local_settings)
                messagebox.showinfo("Sukces", "GitHub został skonfigurowany.")
            else:
                messagebox.showwarning("Błąd", "Token GitHub jest wymagany.")
        else:
            messagebox.showinfo("Informacja", "GitHub jest już skonfigurowany.")


    def upload_to_cloud(self):
        services = []
        if self.settings.get("cloud_service_google_drive"):
            services.append("Google Drive")
        if self.settings.get("cloud_service_github"):
            services.append("GitHub")
        if not services:
            messagebox.showwarning("Błąd", "Nie wybrano żadnej usługi chmurowej.")
            return

        # Sprawdź, czy token GitHub jest dostępny przed rozpoczęciem wątku
        if "GitHub" in services:
            token = self.local_settings.get("github_token")
            if not token:
                self.setup_github()
                token = self.local_settings.get("github_token")
                if not token:
                    messagebox.showwarning("Błąd", "Brak tokenu GitHub.")
                    return

        # Tworzenie okna paska postępu
        self.show_progress_window("Przesyłanie do chmury")

        # Rozpocznij wątek roboczy
        threading.Thread(target=self.upload_to_cloud_thread, args=(services,), daemon=True).start()

        # Rozpocznij sprawdzanie kolejki z postępem
        self.check_progress_queue()

    # --- NOWA METODA ---
    def _save_remote_port(self):
        """Zapisuje nowy port i restartuje serwer, jeśli jest aktywny."""
        try:
            new_port = self.remote_port_var.get()
            if not (1024 < new_port < 65535): # Podstawowa walidacja zakresu portów
                raise ValueError("Port musi być liczbą między 1025 a 65534.")

            current_port = self.local_settings.get("remote_control_port", 5000)

            if new_port != current_port:
                 self.local_settings["remote_control_port"] = new_port
                 save_local_settings(self.local_settings)
                 self.remote_server_port = new_port # Zaktualizuj atrybut instancji
                 logging.info(f"Zmieniono port zdalnego sterowania na: {new_port}")

                 # Restartuj serwer, jeśli był uruchomiony
                 if self._server_running:
                      messagebox.showinfo("Restart Serwera", "Port został zmieniony. Serwer zdalny zostanie teraz zrestartowany.", parent=self.settings_page_frame)
                      self._stop_flask_server()
                      # Poczekaj chwilę przed ponownym uruchomieniem
                      self.root.after(500, self._start_flask_server)
                 else:
                      messagebox.showinfo("Zapisano Port", f"Nowy port ({new_port}) został zapisany. Serwer zostanie uruchomiony na tym porcie przy następnym włączeniu.", parent=self.settings_page_frame)
            else:
                 # Port się nie zmienił
                 pass

        except tk.TclError: # Błąd, jeśli wpisano nie-liczbę
            messagebox.showerror("Błąd Wartości", "Port musi być liczbą całkowitą.", parent=self.settings_page_frame)
        except ValueError as e: # Błąd zakresu
             messagebox.showerror("Błąd Wartości", str(e), parent=self.settings_page_frame)
        except Exception as e:
            logging.exception("Nieoczekiwany błąd podczas zapisywania portu.")
            messagebox.showerror("Błąd", f"Wystąpił nieoczekiwany błąd: {e}", parent=self.settings_page_frame)
    # --- KONIEC NOWEJ METODY ---

    def check_progress_queue(self):
        try:
            while True:
                item = self.progress_queue.get_nowait()
                if item == "DONE":
                    self.progress_window.destroy()
                    messagebox.showinfo("Sukces", "Pliki zostały przesłane do chmury.")
                    return
                elif str(item).startswith("ERROR:"):
                    self.progress_window.destroy()
                    messagebox.showerror("Błąd", item[6:])
                    return
                else:
                    percent = item
                    self.update_progress(percent)
        except queue.Empty:
            pass
        # Harmonogram następnego sprawdzenia
        self.root.after(100, self.check_progress_queue)

    def update_filter_group_menu(self):
        """Tworzy lub aktualizuje OptionMenu z grupami statycznymi i filtrami zaawansowanymi."""
        # Usuń stare menu, jeśli istnieje
        if hasattr(self, 'filter_group_menu') and self.filter_group_menu.winfo_exists():
            self.filter_group_menu.destroy()

        options = ["Wszystkie Gry"]
        # Dodaj grupy statyczne
        static_groups = sorted(list(self.groups.keys()))
        if static_groups:
             options.append("--- Grupy Statyczne ---") # Separator
             options.extend(static_groups)

        # Dodaj filtry zaawansowane
        saved_filters = sorted(list(self.config.get("saved_filters", {}).keys()))
        if saved_filters:
             options.append("--- Filtry Zaawansowane ---") # Separator
             options.extend(saved_filters)

        # Sprawdź, czy aktualnie wybrana wartość istnieje na nowej liście
        current_selection = self.filter_or_group_var.get()
        if current_selection not in options:
            self.filter_or_group_var.set("Wszystkie Gry") # Wróć do domyślnej, jeśli zniknęła

        # Utwórz nowe OptionMenu
        self.filter_group_menu = ttk.OptionMenu(
            self.header,
            self.filter_or_group_var,
            self.filter_or_group_var.get(), # Aktualnie wybrana wartość
            *options,
            command=self._on_filter_or_group_selected # Nowa funkcja obsługująca wybór
        )
        self.filter_group_menu.grid(row=0, column=3, padx=10, pady=10, sticky="ew") # Umieść w odpowiedniej kolumnie

        # Wyłącz opcje, które są separatorami
        try:
            menu_widget = self.filter_group_menu["menu"]
            for i, option in enumerate(options):
                if option.startswith("---"):
                    menu_widget.entryconfigure(i, state="disabled")
        except tk.TclError:
            pass # Ignoruj, jeśli menu nie ma jeszcze opcji

    def _on_filter_or_group_selected(self, selected_value):
        """Obsługuje wybór z menu Grup/Filtrów."""
        # Sprawdź, czy to nie separator
        if selected_value.startswith("---"):
             # Przywróć poprzednią wartość? Albo nic nie rób. Na razie nic.
             # Może od razu ustawić poprzednią?
             # current_value = self.filter_or_group_var.get() # Pobierz tę, która została ustawiona (separator)
             # Potrzebujemy przechować poprzednią wartość, żeby ją przywrócić
             # Na razie po prostu zaktualizujmy siatkę, co nie powinno nic zmienić dla separatora
             pass

        # Niezależnie od tego, co wybrano (nawet separator), odśwież siatkę
        self.reset_and_update_grid()

    # --- NOWE METODY DLA STEROWANIA MUZYKĄ Z ZASOBNIKA ---
    def _music_control_play_pause(self):
        """Wywołuje play/pause w odtwarzaczu muzyki, jeśli jest dostępny."""
        if hasattr(self, 'music_player_page_instance') and self.music_player_page_instance:
            # Użyj after, aby upewnić się, że wykonuje się w głównym wątku GUI
            self.root.after(0, self.music_player_page_instance._toggle_play_pause)
            logging.info("Polecenie Play/Pause wysłane do odtwarzacza z zasobnika.")
        else:
            logging.warning("Próba sterowania muzyką z zasobnika, ale instancja odtwarzacza nie istnieje.")
            # Można opcjonalnie poinformować użytkownika lub otworzyć stronę muzyki
            # self.show_window()
            # self.show_music_page()
        self.root.after(100, self._update_overlay_regularly) # Wymuś aktualizację overlay'a

    def _music_control_next_track(self):
        """Wywołuje następny utwór w odtwarzaczu muzyki, jeśli jest dostępny."""
        if hasattr(self, 'music_player_page_instance') and self.music_player_page_instance:
            self.root.after(0, self.music_player_page_instance._next_track)
            logging.info("Polecenie Następny Utwór wysłane do odtwarzacza z zasobnika.")
        else:
            logging.warning("Próba sterowania muzyką z zasobnika (następny), ale instancja odtwarzacza nie istnieje.")
        self.root.after(100, self._update_overlay_regularly)

    def _music_control_prev_track(self):
        """Wywołuje poprzedni utwór w odtwarzaczu muzyki, jeśli jest dostępny."""
        if hasattr(self, 'music_player_page_instance') and self.music_player_page_instance:
            self.root.after(0, self.music_player_page_instance._prev_track)
            logging.info("Polecenie Poprzedni Utwór wysłane do odtwarzacza z zasobnika.")
        else:
            logging.warning("Próba sterowania muzyką z zasobnika (poprzedni), ale instancja odtwarzacza nie istnieje.")
        self.root.after(100, self._update_overlay_regularly)

    def show_music_page_from_tray(self):
        """Pokazuje okno launchera i przechodzi do strony odtwarzacza muzyki."""
        self.show_window()
        self.root.after_idle(self.show_music_page) # Użyj after_idle dla pewności po deiconify
    # --- KONIEC NOWYCH METOD ---


    def download_from_cloud(self):
        services = []
        if self.settings.get("cloud_service_google_drive"):
            services.append("Google Drive")
        if self.settings.get("cloud_service_github"):
            services.append("GitHub")
        if not services:
            messagebox.showwarning("Błąd", "Nie wybrano żadnej usługi chmurowej.")
            return
        for service in services:
            if service == "Google Drive":
                self.download_from_google_drive()
            elif service == "GitHub":
                self.download_from_github()

    def upload_to_google_drive(self):
        from googleapiclient.discovery import build
        from googleapiclient.http import MediaFileUpload

        if not hasattr(self, 'google_drive_creds'):
            self.setup_google_drive()
        service = build('drive', 'v3', credentials=self.google_drive_creds)
        file_metadata = {'name': CONFIG_FILE}
        media = MediaFileUpload(CONFIG_FILE, mimetype='application/json')
        file = service.files().create(body=file_metadata, media_body=media, fields='id').execute()
        messagebox.showinfo("Sukces", "Plik został przesłany do Google Drive.")

# W klasie GameLauncher

    def check_and_unlock_achievements(self):
        """Sprawdza warunki odblokowania osiągnięć, aktualizuje postęp i odblokowuje (Rozbudowana)."""
        if not self.achievement_definitions: return

        user_achievements = self.user.setdefault("achievements", {})
        something_changed = False

        # --- Oblicz aktualne statystyki użytkownika ---
        library_size = len(self.games)
        total_playtime_seconds = sum(g.get('play_time', 0) for g in self.games.values())
        total_playtime_hours = round(total_playtime_seconds / 3600, 2)
        games_launched_count = sum(1 for g in self.games.values() if g.get('play_count', 0) > 0)
        games_completed_100 = sum(1 for g in self.games.values() if g.get('completion', 0) >= 100)
        # NOWE STATYSTYKI
        max_single_game_playtime_hours = max((g.get('play_time', 0) / 3600 for g in self.games.values()), default=0)
        roadmap_completed = len(self.archive) # Proste założenie
        rated_count = sum(1 for g in self.games.values() if g.get('rating') is not None)
        groups_created_count = len(self.groups)
        games_with_tags_count = sum(1 for g in self.games.values() if g.get('tags'))
        themes_changed_count = self.user.get('theme_change_count', 0)
        # --- NOWE: Poprawione zliczanie modów (liczba unikalnych nazw modów?) ---
        # Lub prostsze: łączna liczba wpisów modów we wszystkich profilach
        mods_installed_count = sum(len(p.get('mods', {}))
                                   for g_data in self.mods_data.values() # Użyj self.mods_data
                                   for p in g_data.get('profiles', {}).values())
        # --- KONIEC NOWEGO ---
        consecutive_days = self.local_settings.get('consecutive_days', 0) # Przenieś odczyt tutaj dla spójności

        # Sprawdź każde zdefiniowane osiągnięcie
        for achievement_def in self.achievement_definitions:
            ach_id = achievement_def.get("id")
            if not ach_id: continue

            ach_progress_data = user_achievements.setdefault(ach_id, {"unlocked": False, "timestamp": None, "current_progress": 0})

            if ach_progress_data.get("unlocked"): continue

            rule_type = achievement_def.get("rule_type")
            target_value = achievement_def.get("target_value")
            current_value = 0
            update_progress = False
            unlocked_now = False

            try:
                # --- ROZBUDOWANE SPRAWDZANIE WARUNKÓW ---
                if rule_type == "games_launched_count":
                    current_value = games_launched_count; update_progress = True
                    try: target_value = int(target_value)
                    except ValueError: raise ValueError("Wartość docelowa musi być liczbą całkowitą")
                elif rule_type == "library_size":
                    current_value = library_size; update_progress = True
                    try: target_value = int(target_value)
                    except ValueError: raise ValueError("Wartość docelowa musi być liczbą całkowitą")
                elif rule_type == "total_playtime_hours":
                    current_value = total_playtime_hours; update_progress = True
                    try: target_value = float(target_value)
                    except ValueError: raise ValueError("Wartość docelowa musi być liczbą")
                elif rule_type == "games_completed_100":
                    current_value = games_completed_100; update_progress = True
                    try: target_value = int(target_value)
                    except ValueError: raise ValueError("Wartość docelowa musi być liczbą całkowitą")
                # --- NOWE TYPY ---
                elif rule_type == "playtime_single_game_hours":
                    current_value = round(max_single_game_playtime_hours, 2); update_progress = True
                    try: target_value = float(target_value)
                    except ValueError: raise ValueError("Wartość docelowa musi być liczbą")
                elif rule_type == "genre_played_count":
                    required_genre = achievement_def.get("genre")
                    if required_genre:
                         current_value = sum(1 for g_name, g_data in self.games.items()
                                            if g_data.get('play_count', 0) > 0 and required_genre in g_data.get('genres', []))
                         update_progress = True
                         try: target_value = int(target_value)
                         except ValueError: raise ValueError("Wartość docelowa musi być liczbą całkowitą")
                    else: logging.warning(f"Brak parametru 'genre' w definicji osiągnięcia {ach_id}"); continue
                elif rule_type == "roadmap_completed_count":
                     current_value = roadmap_completed; update_progress = True
                     try: target_value = int(target_value)
                     except ValueError: raise ValueError("Wartość docelowa musi być liczbą całkowitą")
                elif rule_type == "games_rated_count":
                     current_value = rated_count; update_progress = True
                     try: target_value = int(target_value)
                     except ValueError: raise ValueError("Wartość docelowa musi być liczbą całkowitą")
                # --- NOWE TYPY z dodatkowym parametrem ---
                elif rule_type in ["genre_played_count", "genre_completed_100"]:
                    required_genre = achievement_def.get("genre")
                    if required_genre:
                        if rule_type == "genre_played_count":
                             current_value = sum(1 for g_data in self.games.values()
                                                 if g_data.get('play_count', 0) > 0 and required_genre in g_data.get('genres', []))
                        else: # genre_completed_100
                             current_value = sum(1 for g_data in self.games.values()
                                                 if g_data.get('completion', 0) >= 100 and required_genre in g_data.get('genres', []))
                        update_progress = True
                        try: target_value = int(target_value)
                        except ValueError: raise ValueError("Wartość docelowa musi być liczbą całkowitą")
                    else: logging.warning(f"Brak parametru 'genre' dla {ach_id}"); continue

                elif rule_type in ["tag_played_count", "tag_completed_100"]:
                     required_tag = achievement_def.get("tag")
                     if required_tag:
                          if rule_type == "tag_played_count":
                              current_value = sum(1 for g_data in self.games.values()
                                                  if g_data.get('play_count', 0) > 0 and required_tag in g_data.get('tags', []))
                          else: # tag_completed_100
                              current_value = sum(1 for g_data in self.games.values()
                                                  if g_data.get('completion', 0) >= 100 and required_tag in g_data.get('tags', []))
                          update_progress = True
                          try: target_value = int(target_value)
                          except ValueError: raise ValueError("Wartość docelowa musi być liczbą całkowitą")
                     else: logging.warning(f"Brak parametru 'tag' dla {ach_id}"); continue

                elif rule_type in ["group_played_count", "group_completed_100"]:
                     required_group = achievement_def.get("group")
                     if required_group and required_group in self.groups:
                          group_games = self.groups[required_group]
                          if rule_type == "group_played_count":
                              current_value = sum(1 for g_name in group_games
                                                  if self.games.get(g_name, {}).get('play_count', 0) > 0)
                          else: # group_completed_100
                              current_value = sum(1 for g_name in group_games
                                                  if self.games.get(g_name, {}).get('completion', 0) >= 100)
                          update_progress = True
                          try: target_value = int(target_value)
                          except ValueError: raise ValueError("Wartość docelowa musi być liczbą całkowitą")
                     else: logging.warning(f"Brak parametru 'group' lub grupa nie istnieje dla {ach_id}"); continue

                # --- Pozostałe NOWE TYPY ---
                elif rule_type == "groups_created":
                    current_value = groups_created_count; update_progress = True
                    try: target_value = int(target_value)
                    except ValueError: raise ValueError("Wartość docelowa musi być liczbą całkowitą")
                elif rule_type == "games_with_tags":
                     current_value = games_with_tags_count; update_progress = True
                     try: target_value = int(target_value)
                     except ValueError: raise ValueError("Wartość docelowa musi być liczbą całkowitą")
                elif rule_type == "roadmap_items_added":
                     current_value = len(self.roadmap); update_progress = True # Liczba aktualnych zadań w roadmapie
                     try: target_value = int(target_value)
                     except ValueError: raise ValueError("Wartość docelowa musi być liczbą całkowitą")
                elif rule_type == "themes_changed":
                     current_value = themes_changed_count; update_progress = True
                     try: target_value = int(target_value)
                     except ValueError: raise ValueError("Wartość docelowa musi być liczbą całkowitą")
                elif rule_type == "game_launched_at_night":
                     current_value = 1 if ach_progress_data.get("_triggered_at_night") else 0
                     target_value = 1
                # --- NOWY BLOK: Dni z rzędu ---
                elif rule_type == "consecutive_days_used":
                     # Wartość jest przechowywana w local_settings
                     current_value = self.local_settings.get('consecutive_days', 0)
                     update_progress = True # Chcemy aktualizować postęp
                     try: target_value = int(target_value)
                     except ValueError: raise ValueError("Wartość docelowa musi być liczbą całkowitą")
                # --- KONIEC NOWEGO BLOKU ---
                # --- NOWE: Obsługa mods_installed ---
                elif rule_type == "mods_installed":
                      current_value = mods_installed_count
                      update_progress = True
                      try: target_value = int(target_value)
                      except ValueError: raise ValueError("Wartość docelowa musi być liczbą całkowitą")
                # --- KONIEC NOWEGO ---
                # Aktualizacja postępu
                if update_progress and ach_progress_data.get("current_progress") != current_value:
                     ach_progress_data["current_progress"] = current_value
                     something_changed = True
                     logging.debug(f"Zaktualizowano postęp dla '{ach_id}': {current_value} / {target_value}")

                # Sprawdzenie warunku odblokowania
                epsilon = 0.001 # Tolerancja dla float
                if isinstance(target_value, float):
                     if current_value >= target_value - epsilon: unlocked_now = True
                elif isinstance(target_value, int):
                     if current_value >= target_value: unlocked_now = True

            except ValueError as ve: logging.error(f"Błąd wartości docelowej dla '{ach_id}': {ve}"); continue
            except Exception as e: logging.error(f"Błąd sprawdzania '{ach_id}': {e}"); continue

            # Odblokowanie
            if unlocked_now and not ach_progress_data.get("unlocked"):
                # ... (logika odblokowania i powiadomienia jak poprzednio) ...
                logging.info(f"Odblokowano osiągnięcie: {ach_id}!")
                timestamp = time.time(); ach_progress_data["unlocked"] = True; ach_progress_data["timestamp"] = timestamp
                ach_progress_data["current_progress"] = target_value # Ustaw na max
                ach_progress_data.pop("_triggered_at_night", None) # Usuń flagę, jeśli była
                something_changed = True
                ach_name = achievement_def.get("name", ach_id); ach_desc = achievement_def.get("description", "")
                try: self.root.after(100, lambda name=ach_name, desc=ach_desc: notification.notify(title="Osiągnięcie Odblokowane!", message=f"{name}\n{desc}", app_name="Game Launcher", timeout=10 ))
                except Exception as e_notify: logging.error(f"Błąd powiadomienia: {e_notify}")


        # Zapis konfiguracji
        if something_changed:
            save_config(self.config)
            if hasattr(self, 'achievements_frame') and self.current_frame == self.achievements_frame:
                 if hasattr(self, 'create_achievements_page'):
                      self.root.after(50, self.create_achievements_page)


    def download_from_google_drive(self):
        from googleapiclient.discovery import build
        from googleapiclient.http import MediaIoBaseDownload
        import io

        if not hasattr(self, 'google_drive_creds'):
            self.setup_google_drive()
        service = build('drive', 'v3', credentials=self.google_drive_creds)
        # Wyszukaj plik
        results = service.files().list(q=f"name='{CONFIG_FILE}'", spaces='drive', fields='files(id, name)').execute()
        items = results.get('files', [])
        if not items:
            messagebox.showwarning("Błąd", "Nie znaleziono pliku w Google Drive.")
            return
        file_id = items[0]['id']
        request = service.files().get_media(fileId=file_id)
        fh = io.FileIO(CONFIG_FILE, 'wb')
        downloader = MediaIoBaseDownload(fh, request)
        done = False
        while done is False:
            status, done = downloader.next_chunk()
        fh.close()
        self.config = load_config()
        self.games = self.config.setdefault("games", {})
        self.settings = self.config.setdefault("settings", {})
        self.groups = self.config.setdefault("groups", {})
        self.user = self.config.setdefault("user", {})
        self.update_game_grid()
        self.create_home_page()
        messagebox.showinfo("Sukces", "Plik został pobrany z Google Drive.")

    def _upload_single_file_to_github(self, repo, local_path, repo_path):
        """Pomocnicza funkcja do wysyłania pojedynczego pliku na GitHub."""
        if not os.path.exists(local_path):
            logging.warning(f"Plik lokalny '{local_path}' nie istnieje, pomijam wysyłanie.")
            return True # Zwróć True, aby kontynuować, ale nic nie rób

        # Odczytaj jako tekst - zakładamy, że pliki konfiguracyjne to tekst (JSON)
        # Dla innych typów plików (np. bazy danych SQLite) trzeba by użyć 'rb' i przesłać content binarny
        try:
            with open(local_path, 'r', encoding='utf-8') as file:
                content = file.read()
        except Exception as e:
             error_msg = f"Nie można odczytać pliku lokalnego {local_path}: {e}"
             logging.error(error_msg)
             self.progress_queue.put(f"ERROR: {error_msg}")
             return False # Zwróć False, aby zasygnalizować błąd

        try:
            contents = repo.get_contents(repo_path)
            # Porównaj SHA, aby uniknąć niepotrzebnego update'u? Na razie upraszczamy i zawsze próbujemy update.
            repo.update_file(contents.path, f"Update {os.path.basename(repo_path)}", content, contents.sha)
            logging.info(f"Zaktualizowano plik '{repo_path}' na GitHub.")
        except GithubException as e:
            if e.status == 404: # File not found, create it
                repo.create_file(repo_path, f"Create {os.path.basename(repo_path)}", content)
                logging.info(f"Utworzono plik '{repo_path}' na GitHub.")
            else: # Inny błąd GitHub API
                error_msg = f"Nie udało się przesłać pliku {repo_path}: {e}"
                logging.error(error_msg)
                self.progress_queue.put(f"ERROR: {error_msg}")
                return False # Zwróć False, aby zasygnalizować błąd
        except Exception as e:
             error_msg = f"Nieoczekiwany błąd przy wysyłaniu {repo_path}: {e}"
             logging.exception(error_msg)
             self.progress_queue.put(f"ERROR: {error_msg}")
             return False # Zwróć False

        return True # Sukces

    def do_upload_to_github(self):
        # ZMIANA: Zmieniono importy, aby były lokalne dla metody
        from github import Github, GithubException

        token = self.local_settings.get("github_token")
        if not token:
            self.progress_queue.put("ERROR: Brak tokenu GitHub")
            return
        g = Github(token)
        try:
            user = g.get_user()
            repo_name = "game_launcher_saves"
            try:
                repo = user.get_repo(repo_name)
            except GithubException:
                logging.info(f"Repozytorium '{repo_name}' nie istnieje. Tworzenie nowego.")
                repo = user.create_repo(repo_name)

            # --- ZMIANA: Użycie funkcji pomocniczej do wysyłania plików ---
            # Przesłanie plików konfiguracyjnych - przerwij, jeśli któryś zawiedzie
            if not self._upload_single_file_to_github(repo, CONFIG_FILE, CONFIG_FILE):
                 return # Przerwij, jeśli config.json się nie udał
            if not self._upload_single_file_to_github(repo, "achievements_def.json", "achievements_def.json"):
                 return # Przerwij, jeśli definicje się nie udały

            # Opcjonalne wysyłanie local_settings.json
            if self.settings.get("sync_local_settings_to_cloud", False): # Dodaj to ustawienie w UI!
                 if not self._upload_single_file_to_github(repo, LOCAL_SETTINGS_FILE, LOCAL_SETTINGS_FILE):
                      return # Przerwij, jeśli się nie udało
            else:
                 logging.info("Pomijam wysyłanie local_settings.json do chmury (zgodnie z ustawieniami).")
            # --- KONIEC ZMIANY ---

            # Przesłanie folderów (bez zmian - używają upload_folder_to_github)
            logging.info("Rozpoczynanie wysyłania folderu games_saves...")
            self.upload_folder_to_github(repo, GAMES_FOLDER, GAMES_FOLDER)
            logging.info("Rozpoczynanie wysyłania folderu images...")
            self.upload_folder_to_github(repo, IMAGES_FOLDER, IMAGES_FOLDER)

        except GithubException as e:
             error_msg = f"Błąd GitHub API podczas operacji: {e}"
             logging.error(error_msg)
             self.progress_queue.put(f"ERROR: {error_msg}")
             return # Przerwij
        except Exception as e:
            error_msg = f"Nieoczekiwany błąd podczas wysyłania do GitHub: {e}"
            logging.exception(error_msg)
            self.progress_queue.put(f"ERROR: {error_msg}")
            return # Przerwij

        # Wskaźnik zakończenia (tylko jeśli wszystko poszło OK)
        self.progress_queue.put("DONE")



    def upload_folder_to_github(self, repo, local_folder, repo_folder):
        files = []
        for root, dirs, filenames in os.walk(local_folder):
            for filename in filenames:
                files.append(os.path.join(root, filename))
        total_files = len(files)
        for idx, local_file_path in enumerate(files):
            with open(local_file_path, 'rb') as file:
                content = file.read()
            repo_file_path = os.path.join(repo_folder, os.path.relpath(local_file_path, local_folder)).replace("\\", "/")
            try:
                contents = repo.get_contents(repo_file_path)
                repo.update_file(contents.path, f"Update {repo_file_path}", content, contents.sha)
            except GithubException as e:
                if e.status == 404:
                    repo.create_file(repo_file_path, f"Create {repo_file_path}", content)
                else:
                    self.progress_queue.put(f"ERROR: Nie udało się przesłać pliku {repo_file_path}: {e}")
                    return
            # Aktualizacja postępu
            percent = int(((idx + 1) / total_files) * 100)
            self.progress_queue.put(percent)



    # --- NOWA FUNKCJA POMOCNICZA (lub umieść ją wewnątrz download_from_github) ---
    def _download_single_file_from_github(self, repo, repo_path, local_path):
         """Pomocnicza funkcja do pobierania pojedynczego pliku z GitHub."""
         try:
             contents = repo.get_contents(repo_path)
             content = contents.decoded_content.decode('utf-8') # Zakładamy tekst
             # Utwórz katalogi nadrzędne, jeśli nie istnieją
             os.makedirs(os.path.dirname(local_path), exist_ok=True)
             with open(local_path, 'w', encoding='utf-8') as file:
                 file.write(content)
             logging.info(f"Pobrano i zapisano plik '{repo_path}' z GitHub do '{local_path}'.")
             return True
         except GithubException as e:
             if e.status == 404:
                  logging.warning(f"Nie znaleziono pliku '{repo_path}' w repozytorium GitHub.")
             else:
                  logging.error(f"Błąd GitHub podczas pobierania '{repo_path}': {e}")
             return False # Zwróć False przy błędzie 404 lub innym błędzie API
         except Exception as e:
              logging.exception(f"Nieoczekiwany błąd podczas pobierania/zapisu '{repo_path}': {e}")
              return False


    def download_from_github(self):
        # ZMIANA: Zmieniono importy, aby były lokalne
        from github import Github, GithubException

        self.show_progress_window("Pobieranie z GitHub")
        self.progress_bar['value'] = 0; self.progress_label.config(text="0%")

        token = self.local_settings.get("github_token"); # etc.
        if not token: self.setup_github(); token = self.local_settings.get("github_token")
        if not token: messagebox.showwarning("Błąd", "Brak tokenu GitHub."); self.progress_window.destroy(); return
        g = Github(token)

        try:
            user = g.get_user()
            repo_name = "game_launcher_saves"
            try:
                repo = user.get_repo(repo_name)
            except GithubException:
                messagebox.showwarning("Błąd", f"Repozytorium '{repo_name}' nie istnieje.")
                self.progress_window.destroy()
                return

            # --- ZMIANA: Użycie funkcji pomocniczej do pobierania plików ---
            logging.info("Pobieranie plików konfiguracyjnych...")
            config_ok = self._download_single_file_from_github(repo, CONFIG_FILE, CONFIG_FILE)
            ach_def_ok = self._download_single_file_from_github(repo, "achievements_def.json", "achievements_def.json")
            local_settings_ok = False
            if self.settings.get("sync_local_settings_to_cloud", False): # Dodaj opcję w UI
                local_settings_ok = self._download_single_file_from_github(repo, LOCAL_SETTINGS_FILE, LOCAL_SETTINGS_FILE)
            else:
                logging.info("Pomijam pobieranie local_settings.json z chmury.")
            # --- KONIEC ZMIANY ---

            # Pobranie folderów
            logging.info("Pobieranie folderu games_saves...")
            self.download_folder_from_github(repo, GAMES_FOLDER, GAMES_FOLDER, progress_callback=self.update_progress)
            logging.info("Pobieranie folderu images...")
            self.download_folder_from_github(repo, IMAGES_FOLDER, IMAGES_FOLDER, progress_callback=self.update_progress)

            # --- ZMIANA: Lepsze ponowne wczytanie konfiguracji ---
            logging.info("Ponowne wczytywanie konfiguracji i odświeżanie UI...")
            # Wczytaj główny config tylko jeśli został pobrany
            if config_ok:
                 self.config = load_config() # load_config ustawi domyślne, jeśli trzeba
                 self.settings = self.config.setdefault("settings", {})
                 self.games = self.config.setdefault("games", {})
                 self.groups = self.config.setdefault("groups", {})
                 self.user = self.config.setdefault("user", {})
                 self.mods_data = self.config.setdefault("mods_data", {})
                 self.archive = self.config.setdefault("archive", [])
                 self.roadmap = self.config.setdefault("roadmap", [])

            # Wczytaj definicje, jeśli pobrano
            if ach_def_ok:
                 self._load_achievement_definitions()

            # Wczytaj ustawienia lokalne, jeśli pobrano
            if local_settings_ok:
                 self.local_settings = load_local_settings()
                 # Zastosuj ustawienia zależne od local_settings
                 self.apply_font_settings()
                 # Przywracanie stanu okna/geometrii wymaga restartu lub bardziej złożonej logiki

            # Napraw ścieżki i odśwież UI
            self.repair_save_paths()
            self.refresh_ui() # Użyj pełnego odświeżenia UI
            self.show_home() # Pokaż stronę główną po odświeżeniu

            self.progress_window.destroy()
            messagebox.showinfo("Sukces", "Pliki zostały pobrane z GitHub.")
            # --- KONIEC ZMIANY ---

        except GithubException as e:
             error_msg = f"Błąd GitHub API podczas pobierania: {e}"
             logging.error(error_msg)
             if hasattr(self, 'progress_window') and self.progress_window.winfo_exists(): self.progress_window.destroy()
             messagebox.showerror("Błąd Pobierania", error_msg)
        except Exception as e:
             error_msg = f"Nieoczekiwany błąd podczas pobierania z GitHub: {e}"
             logging.exception(error_msg)
             if hasattr(self, 'progress_window') and self.progress_window.winfo_exists(): self.progress_window.destroy()
             messagebox.showerror("Błąd Pobierania", error_msg)

    def download_folder_from_github(self, repo, repo_folder, local_folder, progress_callback=None):
        contents = repo.get_contents(repo_folder)
        files = []
        while contents:
            file_content = contents.pop(0)
            if file_content.type == 'dir':
                contents.extend(repo.get_contents(file_content.path))
            else:
                files.append(file_content)
        total_files = len(files)
        for idx, file_content in enumerate(files):
            file_path = os.path.join(local_folder, os.path.relpath(file_content.path, repo_folder))
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            with open(file_path, 'wb') as file:
                file.write(file_content.decoded_content)
            # Aktualizacja postępu
            if progress_callback:
                percent = int(((idx + 1) / total_files) * 100)
                self.root.after(0, progress_callback, percent)

    def disable_event(self):
        pass

    def update_progress(self, percent):
        if hasattr(self, 'progress_bar') and self.progress_bar.winfo_exists():
            self.progress_bar['value'] = percent
            self.progress_label.config(text=f"{percent}%")
            self.progress_window.update_idletasks()

    def upload_to_cloud_thread(self, services):
        for service in services:
            if service == "Google Drive":
                self.do_upload_to_google_drive()
            elif service == "GitHub":
                self.do_upload_to_github()
        # Wskaźnik zakończenia
        self.progress_queue.put("DONE")

    def check_progress_queue(self):
        try:
            while True:
                item = self.progress_queue.get_nowait()
                if item == "DONE":
                    self.progress_window.destroy()
                    messagebox.showinfo("Sukces", "Pliki zostały przesłane do chmury.")
                    return
                elif str(item).startswith("ERROR:"):
                    self.progress_window.destroy()
                    messagebox.showerror("Błąd", item[6:])
                    return
                else:
                    percent = item
                    self.update_progress(percent)
        except queue.Empty:
            pass
        # Harmonogram następnego sprawdzenia
        self.root.after(100, self.check_progress_queue)



    def start_fetch_details_thread(self, game_name, details_window, force=False):
        # 1️⃣ Pozbywamy się pierwszego wątku z self._fetch_details_worker

        api_key = self.local_settings.get("rawg_api_key")
        if not api_key:
            messagebox.showerror(
                "Brak klucza API",
                "Nie znaleziono klucza API RAWG.io w ustawieniach.",
                parent=details_window
            )
            return

        if hasattr(details_window, 'fetch_api_button'):
            details_window.fetch_api_button.config(text="Pobieranie...", state=tk.DISABLED)

        def on_complete(result):
            if details_window.winfo_exists():
                details_window._on_details_fetched(result)
                if hasattr(details_window, 'fetch_api_button'):
                    details_window.fetch_api_button.config(text="Pobierz dane", state=tk.NORMAL)

        threading.Thread(
            target=self.fetch_rawg_game_details,
            args=(game_name, api_key, on_complete, force),
            daemon=True
        ).start()

    def open_advanced_filter_manager(self):
        """Otwiera okno zarządzania filtrami zaawansowanymi."""
        # Sprawdź, czy okno już nie jest otwarte
        if hasattr(self, '_filter_manager_window') and self._filter_manager_window.winfo_exists():
            self._filter_manager_window.lift()
            self._filter_manager_window.focus_force()
        else:
            self._filter_manager_window = AdvancedFilterManager(self.root, self)

    def fetch_rawg_game_details(self, game_name, api_key, callback, force=False):
        """Pobiera dane gry z RAWG API i wywołuje callback z wynikiem."""
        base_url = "https://api.rawg.io/api/games"
        params = {"key": api_key}
        headers = {'User-Agent': f'GameLauncher/{PROGRAM_VERSION}'} # Dobra praktyka
        result_data = {"success": False, "error": None, "data": None}

        try:
            # --- Krok 1: Wyszukaj grę po nazwie, aby uzyskać ID ---
            search_params = {**params, "search": game_name, "page_size": 1}
            logging.info(f"Wyszukiwanie gry w RAWG: {game_name}")
            search_response = requests.get(base_url, params=search_params, headers=headers, timeout=15)
            search_response.raise_for_status() # Rzuci błąd dla statusów 4xx/5xx
            search_results = search_response.json()

            if not search_results.get("results"):
                logging.warning(f"Nie znaleziono gry '{game_name}' w RAWG.")
                result_data["error"] = "Nie znaleziono gry w bazie RAWG."
                self.root.after(0, callback, result_data)
                return

            game_id = search_results["results"][0].get("id")
            rawg_slug = search_results["results"][0].get("slug") # Slug może być przydatny
            if not game_id:
                logging.error("Pierwszy wynik wyszukiwania RAWG nie ma ID.")
                result_data["error"] = "Błąd odpowiedzi API RAWG (brak ID)."
                self.root.after(0, callback, result_data)
                return

            logging.info(f"Znaleziono ID gry: {game_id} (slug: {rawg_slug})")
            self.games[game_name]['rawg_id'] = game_id # Zapisz ID dla przyszłości
            self.games[game_name]['rawg_slug'] = rawg_slug

            # --- Krok 2: Pobierz szczegóły gry używając ID ---
            details_url = f"{base_url}/{game_id}"
            logging.info(f"Pobieranie szczegółów z: {details_url}")
            details_response = requests.get(details_url, params=params, headers=headers, timeout=15)
            details_response.raise_for_status()
            details = details_response.json()

            # --- Krok 3: Ekstrakcja Danych ---
            extracted_data = {}
            extracted_data["description"] = details.get("description_raw") # Surowy opis
            extracted_data["release_date"] = details.get("released")
            extracted_data["website"] = details.get("website")
            extracted_data["developers"] = [dev.get("name") for dev in details.get("developers", []) if dev.get("name")]
            extracted_data["publishers"] = [pub.get("name") for pub in details.get("publishers", []) if pub.get("name")]
            extracted_data["genres_api"] = [gen.get("name") for gen in details.get("genres", []) if gen.get("name")] # Zapisz jako genres_api
            extracted_data["tags_api"] = [tag.get("name") for tag in details.get("tags", []) if tag.get("name")]       # Zapisz jako tags_api
            extracted_data["platforms"] = [p.get("platform", {}).get("name") for p in details.get("platforms", []) if p.get("platform", {}).get("name")]

            # Wymagania systemowe (tylko PC)
            pc_platform = next((p for p in details.get("platforms", []) if p.get("platform", {}).get("slug") == "pc"), None)
            if pc_platform and pc_platform.get("requirements"):
                extracted_data["requirements_pc"] = {
                    "minimum": pc_platform["requirements"].get("minimum"),
                    "recommended": pc_platform["requirements"].get("recommended")
                }

            # --- NOWE: Pobieranie okładki ---
            background_image_url = details.get("background_image")
            downloaded_cover_path = None # Domyślnie None
            if background_image_url:
                 # Wywołaj funkcję pomocniczą
                 downloaded_cover_path = self._download_and_save_rawg_cover(game_name, background_image_url)
                 # Dodaj klucz do danych wynikowych TYLKO jeśli pobieranie się powiodło
                 if downloaded_cover_path:
                      extracted_data["downloaded_cover_path"] = downloaded_cover_path
                 else:
                      logging.warning(f"Nie udało się pobrać okładki RAWG dla '{game_name}' z URL: {background_image_url}")
            # --- Koniec pobierania okładki ---

            result_data["success"] = True
            result_data["data"] = extracted_data
            result_data["force_cover"] = force
            logging.info(f"Pomyślnie pobrano i sparsowano dane dla ID: {game_id}")

        except requests.exceptions.Timeout:
            logging.error("Przekroczono czas oczekiwania na odpowiedź z RAWG API.")
            result_data["error"] = "Przekroczono czas odpowiedzi serwera RAWG."
        except requests.exceptions.RequestException as e:
            logging.error(f"Błąd połączenia z RAWG API: {e}")
            result_data["error"] = f"Błąd połączenia z RAWG: {e}"
        except (json.JSONDecodeError, KeyError, IndexError) as e:
             logging.error(f"Błąd przetwarzania odpowiedzi JSON z RAWG: {e}")
             result_data["error"] = "Błąd przetwarzania danych z RAWG."
        except Exception as e:
            logging.exception("Nieoczekiwany błąd podczas pobierania danych z RAWG.")
            result_data["error"] = f"Nieoczekiwany błąd: {e}"

        # Wywołaj callback w głównym wątku
        self.root.after(0, callback, result_data)

    def select_avatar(self):
        path = filedialog.askopenfilename(filetypes=[("Obrazy", "*.png;*.jpg;*.jpeg")])
        if path:
            try:
                os.makedirs(IMAGES_FOLDER, exist_ok=True)
                destination = os.path.join(IMAGES_FOLDER, "avatar.png")
                shutil.copy(path, destination)
                self.avatar_var.set(destination) # Zaktualizuj pole Entry
                self.user["avatar"] = destination
                save_config(self.config)
                # --- NOWE ZMIANY: Aktualizacja UI ---
                self.create_home_page()  # Odśwież stronę główną
                self._load_and_display_settings_avatar() # Odśwież podgląd w ustawieniach
                # --- KONIEC NOWYCH ZMIAN ---
                messagebox.showinfo("Sukces", "Awatar został ustawiony.")
            except Exception as e:
                messagebox.showerror("Błąd", f"Nie udało się ustawić awatara: {e}")



    def create_news_page(self):
        # Wyczyść zawartość news_frame
        for widget in self.news_frame.winfo_children():
            widget.destroy()

        # Nagłówek
        header = ttk.Frame(self.news_frame)
        header.grid(row=0, column=0, sticky="ew")
        ttk.Label(header, text="Newsy Gier", font=("Helvetica", 20, "bold")).pack(pady=10)

        # Obszar na newsy
        self.news_content = HTMLLabel(
            self.news_frame,
            html="<h1 style='font-size:24px; text-align:center; color:white;'>Ładowanie newsów...</h1>",
            background=self.settings.get("background", "#1e1e1e"),
            foreground=self.settings.get("foreground", "white")
        )
        self.news_content.grid(row=1, column=0, padx=10, pady=10, sticky="nsew")

        self.news_frame.columnconfigure(0, weight=1)
        self.news_frame.rowconfigure(1, weight=1)

        # Wczytaj newsy w osobnym wątku




    def load_news(self, content_widget):
        # Użyj tylko aktywnych RSS feedów
        active_feeds = [feed for feed in self.settings.get("rss_feeds", []) if feed.get("active", False)]
        rss_feeds = [feed["url"] for feed in active_feeds]
        post_limit = self.settings.get("news_post_limit", 10)

        logging.info(f"Rozpoczynanie ładowania newsów z {len(rss_feeds)} RSS Feeds.")
        print(f"Loading news from {len(rss_feeds)} feeds.")

        all_entries = []

        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'}

        for feed_url in rss_feeds:
            logging.info(f"Pobieranie newsów z: {feed_url}")
            try:
                response = requests.get(feed_url, headers=headers, timeout=10)
                response.raise_for_status()
                feed = feedparser.parse(response.content)
                if feed.bozo:
                    logging.error(f"Błąd podczas parsowania RSS feed: {feed_url}")
                    continue  # Pomijamy ten feed
                for entry in feed.entries:
                    # Dodajemy datę publikacji
                    entry_date = None
                    if 'published_parsed' in entry and entry.published_parsed:
                        entry_date = time.mktime(entry.published_parsed)
                    elif 'updated_parsed' in entry and entry.updated_parsed:
                        entry_date = time.mktime(entry.updated_parsed)
                    else:
                        entry_date = time.time()  # Jeśli brak daty, ustawiamy na teraz
                    entry['entry_date'] = entry_date
                    all_entries.append(entry)
            except requests.exceptions.RequestException as req_err:
                logging.error(f"Błąd podczas pobierania RSS feed: {feed_url} - {req_err}")
                continue  # Pomijamy ten feed

        # Sortowanie wszystkich wpisów według daty publikacji (najświeższe pierwsze)
        all_entries.sort(key=lambda x: x.get('entry_date', time.time()), reverse=True)

        # Ograniczenie do określonej liczby postów
        selected_entries = all_entries[:post_limit]

        # Tworzenie HTML z newsami
        news_html = f"""
        <h1 style='font-size:24px; text-align:center; color:white;'>Newsy Gier</h1>
        """

        for entry in selected_entries:
            title = entry.get('title', 'Brak tytułu')
            summary = entry.get('summary', 'Brak opisu')
            link = entry.get('link', '#')
            date_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(entry.get('entry_date', time.time())))

            news_html += f"""
            <div style='margin-bottom: 20px;'>
                <h2 style='font-size:18px; color:#ffcc00;'>{title}</h2>
                <div style='font-size:12px; color:#888888;'>{date_str}</div>
                <p style='font-size:14px; color:white;'>{summary}</p>
                <a href="{link}" style='color:#1e90ff; text-decoration:none;'>Czytaj więcej</a>
                <hr style='border:0; height:1px; background:#333; margin:10px 0;'>
            </div>
            """

        logging.info("Newsy zostały poprawnie załadowane i przetworzone.")

        # Aktualizacja zawartości w głównym wątku
        self.root.after(0, lambda: content_widget.set_html(news_html))



# W klasie GameLauncher

    def show_news(self):
        # Upewnij się, że ramka Newsów jest w gridzie
        self.news_frame.grid()
        self.news_frame.tkraise()
        self.current_frame = self.news_frame

        # --- NOWE ZMIANY ---
        if not self._news_initialized:
            logging.info("Tworzenie zawartości strony Newsów po raz pierwszy (lazy init).")
            self.create_news_page() # Buduje szkielet (ramkę, HTMLLabel)
            self._news_initialized = True
        
        # Wczytywanie samych newsów (operacja sieciowa) zawsze jest asynchroniczna
        # i może być uruchamiana po zbudowaniu szkieletu strony
        if not getattr(self, "_news_loaded", False): # Użyj flagi kontrolującej ładowanie danych
            logging.info("Uruchamianie ładowania newsów w tle.")
            if hasattr(self, 'news_content') and self.news_content.winfo_exists():
                threading.Thread(
                    target=self.load_news,
                    args=(self.news_content,),
                    daemon=True
                ).start()
                self._news_loaded = True 
            else:
                logging.error("Nie można załadować newsów - widget news_content nie istnieje.")
        else:
            logging.debug("Newsy były już ładowane.")
        # --- KONIEC NOWYCH ZMIAN ---

        self.current_section = "Czyta Newsy"
        self._update_discord_status(status_type="browsing", activity_details=self.current_section)

    def show_reminders(self):
        self.reminders_frame.grid()
        self.reminders_frame.tkraise()
        self.current_frame = self.reminders_frame

        # --- NOWE ZMIANY ---
        if not self._reminders_initialized:
            logging.info("Tworzenie zawartości strony Przypomnienia po raz pierwszy (lazy init).")
            self.create_reminders_page() # To buduje UI
            self._reminders_initialized = True
        else:
            self.load_reminders() # Jeśli już zbudowana, tylko załaduj/odśwież dane
        # --- KONIEC NOWYCH ZMIAN ---
        
        self.current_section = "Sprawdza Przypomnienia" 
        self._update_discord_status(status_type="browsing", activity_details=self.current_section)
        self.load_reminders() # Wczytaj przypomnienia po pokazaniu strony (było wcześniej)

    def load_reminders(self):
        self.reminders = self.config.setdefault("reminders", [])
        self.reminders_listbox.delete(0, tk.END)
        for reminder in self.reminders:
            reminder_time = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(reminder['time']))
            self.reminders_listbox.insert(tk.END, f"{reminder_time} - {reminder['message']}")

    def add_reminder(self):
        # Formularz do dodawania przypomnienia
        reminder_window = tk.Toplevel(self.root)
        reminder_window.title("Dodaj Przypomnienie")
        reminder_window.configure(bg="#1e1e1e")
        reminder_window.grab_set()
        reminder_window.resizable(False, False)

        ttk.Label(reminder_window, text="Data i Godzina (YYYY-MM-DD HH:MM:SS):", background="#1e1e1e", foreground="white").grid(row=0, column=0, padx=10, pady=10, sticky="w")
        date_entry = ttk.Entry(reminder_window, width=20)
        date_entry.grid(row=0, column=1, padx=10, pady=10, sticky="w")

        ttk.Label(reminder_window, text="Wiadomość:", background="#1e1e1e", foreground="white").grid(row=1, column=0, padx=10, pady=10, sticky="w")
        message_entry = ttk.Entry(reminder_window, width=40)
        message_entry.grid(row=1, column=1, padx=10, pady=10, sticky="w")

        def save_reminder():
            date_str = date_entry.get().strip()
            message = message_entry.get().strip()
            try:
                reminder_time = time.mktime(time.strptime(date_str, '%Y-%m-%d %H:%M:%S'))
                if reminder_time < time.time():
                    raise ValueError("Data i godzina muszą być w przyszłości.")
                self.reminders.append({"time": reminder_time, "message": message})
                save_config(self.config)
                self.reminders_listbox.insert(tk.END, f"{date_str} - {message}")
                reminder_window.destroy()
            except ValueError as ve:
                messagebox.showerror("Błąd", f"Nieprawidłowy format daty/godziny lub czas w przeszłości.\n\nSzczegóły: {ve}")

        save_btn = ttk.Button(reminder_window, text="Zapisz", command=save_reminder)
        save_btn.grid(row=2, column=0, columnspan=2, pady=10)

    def delete_reminder(self):
        selected = self.reminders_listbox.curselection()
        if selected:
            index = selected[0]
            del self.reminders[index]
            self.reminders_listbox.delete(index)
            save_config(self.config)
        else:
            messagebox.showwarning("Błąd", "Nie wybrano żadnego przypomnienia.")


    def update_genre_menu(self):
        self.genre_options = ["Wszystkie Gatunki"] + self.get_all_genres()
        # Usuń istniejący widżet OptionMenu
        self.filter_menu.destroy()
        # Ponownie utwórz OptionMenu z zaktualizowanymi opcjami
        self.filter_menu = ttk.OptionMenu(self.header, self.filter_var, "Wszystkie Gatunki", *self.genre_options, command=self.update_game_grid)
        self.filter_menu.grid(row=1, column=1, padx=10, pady=5, sticky="w")
        self.filter_var.set("Wszystkie Gatunki")
        self.update_game_grid()

    def create_game_tile(self, parent, game_name, game_data, tile_width=200, tile_height=300):
        target_size = (tile_width, tile_height)
        original_cover_path = game_data.get("cover_image")

        # 1. Pobierz ścieżkę do miniaturki (utworzy ją, jeśli trzeba)
        thumbnail_path = self.get_or_create_thumbnail(original_cover_path, game_name, target_size)

        # Jeśli get_or_create_thumbnail zwróciło ścieżkę domyślną, zaktualizuj config
        if thumbnail_path != original_cover_path and "default_cover" in thumbnail_path: # Zakładając, że domyślna ma specyficzną nazwę
             # Lub jeśli original_cover_path był None/nie istniał, a thumbnail_path teraz istnieje
             if not original_cover_path or not os.path.exists(original_cover_path):
                 if thumbnail_path and os.path.exists(thumbnail_path): # Sprawdź czy domyślny cover został faktycznie utworzony
                     # UWAGA: Ostrożnie z zapisywaniem tutaj, może spowolnić.
                     # Lepsze może być zapisanie tylko raz, gdy create_default_cover jest wywołane.
                     # game_data["cover_image"] = thumbnail_path # Zapisz ścieżkę do domyślnej okładki
                     # save_config(self.config) # Potencjalnie wolne!
                     pass # Na razie nie zapisujemy tutaj

        # 2. Załaduj PhotoImage (z cache LUB z pliku miniaturki)
        photo = load_photoimage_from_path(thumbnail_path, target_size)

        # --- Reszta kodu create_game_tile bez zmian ---
        frame = ttk.Frame(parent, style="Game.TFrame")
        frame.pack(fill="both", expand=True)
        parent.columnconfigure(0, weight=1)
        parent.rowconfigure(0, weight=1)

        # Wyświetlanie okładki gry jako przycisku
        cover_label = ttk.Button(frame, image=photo, style="Game.TButton", command=lambda gn=game_name: self.launch_game(gn))
        if photo: # Sprawdź czy ładowanie PhotoImage się powiodło
            cover_label.image = photo # Trzymaj referencję
        else:
             # Można ustawić tekst zamiast obrazu, jeśli ładowanie się nie powiodło
             cover_label.config(text="Brak\nOkładki")
        cover_label.grid(row=0, column=0, columnspan=2, sticky="nsew")

        # Wyświetlanie nazwy gry, czasu gry i procentu ukończenia
        completion = game_data.get('completion', 0)
        vr_mode = game_data.get('vr_mode', False)
        vr_text = " (VR)" if vr_mode else ""
        game_version = game_data.get('version', '')
        game_tags = ", ".join(game_data.get('tags', []))

        # Zbuduj tekst etykiety
        label_text = f"{game_name}{vr_text}\n" # Zawsze zaczynaj od nazwy gry
        label_text += f"Czas gry: {self.format_play_time(game_data.get('play_time', 0))}\n"
        label_text += f"Ukończenie: {completion}%\n"
        if game_version:
            label_text += f"Wersja: {game_version}\n"
        if game_tags:
            max_tag_len = 25
            if len(game_tags) > max_tag_len:
                game_tags = game_tags[:max_tag_len] + "..."
            label_text += f"Tagi: {game_tags}"

        label_text = label_text.strip()

        name_label = ttk.Label(frame, text=label_text, anchor="w", wraplength=tile_width-10)
        name_label.grid(row=1, column=0, columnspan=2, sticky="ew", padx=5)

        # Ramka na przyciski
        btn_frame = ttk.Frame(frame)
        btn_frame.grid(row=2, column=0, columnspan=2, pady=5, sticky="ew")
        btn_frame.columnconfigure(0, weight=1)
        btn_frame.columnconfigure(1, weight=1)

        # Przycisk Uruchom/Zamknij z dwoma stanami
        if self.is_game_running(game_name):
            launch_btn = ttk.Button(btn_frame, text="Zamknij", style="Red.TButton", command=lambda gn=game_name: self.close_game(gn))
        else:
            launch_btn = ttk.Button(btn_frame, text="Uruchom", style="Green.TButton", command=lambda gn=game_name: self.launch_game(gn))
        launch_btn.grid(row=0, column=0, padx=5, sticky="ew")

        # Przyciski: Zapis, Edytuj, Usuń, Resetuj Statystyki, Dodaj do Grupy
        saves_btn = ttk.Button(btn_frame, text="Zapis", command=lambda gn=game_name: self.manage_saves(gn))
        saves_btn.grid(row=0, column=1, padx=5, sticky="ew")

        edit_btn = ttk.Button(btn_frame, text="Edytuj", command=lambda gn=game_name: self.edit_game(gn))
        edit_btn.grid(row=1, column=0, padx=5, sticky="ew")

        delete_btn = ttk.Button(btn_frame, text="Usuń", command=lambda gn=game_name: self.delete_game(gn))
        delete_btn.grid(row=1, column=1, padx=5, sticky="ew")

        reset_stats_btn = ttk.Button(btn_frame, text="Resetuj Statystyki", command=lambda gn=game_name: self.reset_stats(gn))
        reset_stats_btn.grid(row=2, column=0, padx=5, sticky="ew")

        add_to_group_btn = ttk.Button(btn_frame, text="Dodaj do Grupy", command=lambda gn=game_name: self.add_to_group(gn))
        add_to_group_btn.grid(row=2, column=1, padx=5, sticky="ew")

        # Opcjonalny przycisk: Usuń z Grupy (jeśli gra jest w grupie)
        if self.group_var.get() != "Wszystkie Gry":
            remove_from_group_btn = ttk.Button(btn_frame, text="Usuń z Grupy", command=lambda gn=game_name: self.remove_from_group(gn))
            remove_from_group_btn.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="ew")


    def delete_avatar(self):
        avatar_path = self.user.get("avatar", "")
        if avatar_path and os.path.exists(avatar_path):
            try:
                os.remove(avatar_path)
                self.user["avatar"] = ""
                self.avatar_var.set("") # Wyczyść pole Entry
                save_config(self.config)
                # --- NOWE ZMIANY: Aktualizacja UI ---
                self.create_home_page()  # Odśwież stronę główną
                self._load_and_display_settings_avatar() # Odśwież podgląd (pokaże domyślny)
                # --- KONIEC NOWYCH ZMIAN ---
                messagebox.showinfo("Sukces", "Awatar został usunięty.")
            except Exception as e:
                messagebox.showerror("Błąd", f"Nie udało się usunąć awatara: {e}")
        else:
            messagebox.showwarning("Błąd", "Nie ma ustawionego awatara do usunięcia.")


# W klasie GameLauncher, w metodzie update_game_grid:

    def update_game_grid(self):
        # --- Krok 1: Inicjalizacja i czyszczenie ---
        if hasattr(self, '_search_timer_id') and self._search_timer_id:
            try:
                self.root.after_cancel(self._search_timer_id)
            except tk.TclError: pass
            self._search_timer_id = None
        logging.debug("Rozpoczynanie update_game_grid...")
        self._launch_buttons.clear()

        # --- Krok 2: Pobranie filtrów i sortowania ---
        search_query = self.search_var.get().lower()
        # --- ZMIANA: Pobierz wybraną grupę LUB filtr ---
        selected_filter_or_group = self.filter_or_group_var.get()
        # --- KONIEC ZMIANY ---
        selected_genre = self.filter_var.get()
        selected_tag = self.tag_filter_var.get().strip()
        selected_game_type_filter = self.game_type_filter_var.get()
        sort_by = self.sort_var.get()

# W metodzie update_game_grid klasy GameLauncher

        # --- Krok 3: Filtrowanie i sortowanie GŁÓWNEJ listy gier ---
        selected_filter_or_group = self.filter_or_group_var.get()
        is_static_group = selected_filter_or_group in self.groups
        is_advanced_filter = selected_filter_or_group in self.config.get("saved_filters", {})

        games_to_filter = list(self.games.keys()) # Zacznij od wszystkich gier
        active_filter_rules = None

        if is_static_group:
             games_to_filter = list(self.groups.get(selected_filter_or_group, []))
             logging.debug(f"Filtrowanie według grupy statycznej: {selected_filter_or_group}")
        elif is_advanced_filter:
             # --- ZMIANA: Pobierz reguły filtra ---
             active_filter_rules = self.config["saved_filters"][selected_filter_or_group].get("rules", [])
             logging.debug(f"Stosowanie filtra zaawansowanego: {selected_filter_or_group}")
             # Filtrowanie według reguł nastąpi w pętli poniżej
             # --- KONIEC ZMIANY ---
        # W przeciwnym razie użyj wszystkich gier (games_to_filter = list(self.games.keys()))

        # Filtruj listę `games_to_filter` według pozostałych kryteriów ORAZ reguł filtra
        filtered_games = []
        for game_name in games_to_filter:
            game_data = self.games.get(game_name)
            if not game_data: continue

            # --- ZMIANA: Zastosuj reguły filtra zaawansowanego (jeśli aktywny) ---
            if active_filter_rules: # active_filter_rules jest ustawiane na początku metody
                if not self._check_game_against_rules(game_data, active_filter_rules):
                    continue # Pomiń grę, jeśli nie pasuje do reguł filtra
            # --- KONIEC ZMIANY ---

            # Filtrowanie po typie gry
            # ... (kod filtrowania typu gry) ...
            game_type = game_data.get("game_type", "pc"); type_match = False
            if selected_game_type_filter == "Wszystkie Typy": type_match = True
            elif selected_game_type_filter == "Gry PC" and game_type == "pc": type_match = True
            elif selected_game_type_filter == "Gry Emulowane" and game_type == "emulator": type_match = True
            if not type_match: continue

            # Pozostałe filtry (Gatunek, Tag, Wyszukiwanie)
            # ... (kod filtrowania gatunku, tagu, wyszukiwania) ...
            if search_query and search_query not in game_name.lower(): continue
            if selected_genre != "Wszystkie Gatunki" and selected_genre not in game_data.get("genres", []): continue
            if selected_tag and selected_tag != "Wszystkie Tagi":
                 if not any(selected_tag.lower() == tag.lower() for tag in game_data.get("tags", [])): continue

            filtered_games.append(game_name) # Dodaj grę, jeśli przeszła wszystkie filtry

        # Sortowanie
        if sort_by == "Nazwa": filtered_games.sort(key=str.lower)
        elif sort_by == "Data Dodania": filtered_games.sort(key=lambda x: self.games[x].get("date_added", 0), reverse=True)
        elif sort_by == "Czas Gry": filtered_games.sort(key=lambda x: self.games[x].get("play_time", 0), reverse=True)
        elif sort_by == "Ocena": filtered_games.sort(key=lambda x: self.games[x].get("rating", 0) or -1, reverse=True)

        # --- Krok 4: Logika Wyboru Widoku i wyświetlanie ---
        view_mode = self.library_view_mode.get()
        logging.debug(f"Aktualizowanie widoku: {view_mode}")

        if view_mode == 'tiles':
            # === Widok Kafelków ===
            self.list_view_frame.grid_remove()
            self.canvas.grid(row=0, column=0, sticky="nsew")
            self.scrollbar.grid(row=0, column=1, sticky="ns")
            self.pagination_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(5, 10))

            total_items = len(filtered_games)
            self.update_pagination_controls(total_items)

            start_index = (self.current_page - 1) * self.items_per_page
            end_index = start_index + self.items_per_page
            games_on_this_page = filtered_games[start_index:end_index]

            # --- NOWA LOGIKA: Obliczanie siatki na podstawie ustawienia ---
            num_columns = self.local_settings.get("tiles_per_row", 4) # Odczytaj z ustawień
            tile_width = 200 # Domyślna szerokość, jeśli canvas nie jest dostępny
            canvas_width = 1
            try:
                if hasattr(self, 'canvas') and self.canvas.winfo_exists():
                    self.canvas.update_idletasks()
                    canvas_width = self.canvas.winfo_width()
                if canvas_width > 1 and num_columns > 0:
                    # Oblicz szerokość kafelka, aby zmieścić num_columns
                    default_padding_x = 10 # Użyj tego samego paddingu co przy tworzeniu
                    total_padding_width = (num_columns + 1) * default_padding_x
                    available_width = canvas_width - total_padding_width
                    if available_width > 0:
                         tile_width = available_width // num_columns
                    # Upewnij się, że kafelek nie jest za mały
                    tile_width = max(200, tile_width)
                    self.current_tile_width = tile_width # Zapisz obliczoną szerokość
                else:
                     # Fallback, jeśli szerokość canvasa jest niedostępna
                     self.current_tile_width = 200

            except Exception as e:
                logging.exception(f"Błąd podczas obliczania szerokości kafelka na podstawie ustawień: {e}")
                self.current_tile_width = 200 # Użyj domyślnej w razie błędu
            logging.debug(f"Grid (z ustawień): tile_width={self.current_tile_width}, num_columns={num_columns}")
            # --- KONIEC NOWEJ LOGIKI ---

            # Czyszczenie ramki kafelków
            for widget in self.games_frame.winfo_children():
                 if hasattr(widget, 'game_info') and 'name' in widget.game_info:
                      self._clear_launch_button_ref(widget.game_info['name'])
                 widget.destroy()
            self._loaded_tile_ids.clear()

            # Tworzenie kafelków-placeholderów
            row, col = 0, 0
            default_padding_x = 10 # Zgodnie z obliczeniami
            default_padding_y = 10
            if not games_on_this_page:
                 logging.info("Brak gier do wyświetlenia na tej stronie (kafelki).")
                 for i in range(num_columns): self.games_frame.columnconfigure(i, weight=1)
            else:
                for idx, game_name in enumerate(games_on_this_page):
                    padx_config = default_padding_x
                    pady_config = default_padding_y
                    # Przekaż obliczoną szerokość kafelka
                    self._create_tile_placeholder(self.games_frame, game_name, row, col, padx_config, pady_config, self.current_tile_width, self.tile_height)
                    col += 1
                    if col >= num_columns: col = 0; row += 1
                # Konfiguracja wag kolumn
                for i in range(num_columns): self.games_frame.columnconfigure(i, weight=1)

            # Aktualizacja scrollregion i lazy load
            self.root.after(10, self._update_canvas_scrollregion)
            self.root.after(50, self._trigger_lazy_load)

        elif view_mode == 'list':
            # === Widok Listy (bez zmian) ===
            self.canvas.grid_remove(); self.scrollbar.grid_remove(); self.pagination_frame.grid_remove(); self.list_view_frame.grid(row=0, column=0, columnspan=2, sticky="nsew")
            self.list_view_tree.delete(*self.list_view_tree.get_children())
            if not filtered_games: logging.info("Brak gier do wyświetlenia (lista).")
            else:
                # Zastosuj sortowanie z _sort_list_view_by_column przed wypełnieniem
                # Zamiast sortować tutaj, _sort_list_view_by_column samo wypełni listę
                if hasattr(self, '_list_sort_column'):
                     self._sort_list_view_by_column(self._list_sort_column) # Wywołaj sortowanie z zapamiętanymi ustawieniami
                else: # Jeśli nie było sortowania, wypełnij domyślnie
                     for game_name in filtered_games:
                          game_data = self.games.get(game_name)
                          if game_data:
                              play_time_str = self.format_play_time(game_data.get('play_time', 0)); rating_str = str(game_data.get('rating', ''))
                              genres_str = ", ".join(game_data.get('genres', [])); version_str = game_data.get('version', ''); tags_str = ", ".join(game_data.get('tags', []))
                              try: added_timestamp = game_data.get('date_added'); added_date_str = datetime.datetime.fromtimestamp(added_timestamp).strftime('%Y-%m-%d %H:%M') if added_timestamp else ""
                              except Exception: added_date_str = ""
                              values = (game_name, play_time_str, rating_str, genres_str, version_str, tags_str, added_date_str)
                              self.list_view_tree.insert("", "end", iid=game_name, values=values)


        logging.debug("Zakończono update_game_grid.")

    def _update_canvas_scrollregion(self):
         """Aktualizuje scrollregion canvasa po zmianach w games_frame."""
         if hasattr(self, 'canvas') and self.canvas.winfo_exists():
             self.canvas.update_idletasks() # Upewnij się, że wymiary są aktualne
             bbox = self.canvas.bbox("all")
             if bbox:
                 self.canvas.config(scrollregion=bbox)
             else:
                 # Jeśli ramka jest pusta, ustaw minimalny region
                 self.canvas.config(scrollregion=(0, 0, 1, 1))
                 logging.warning("Bbox is None for canvas, setting minimal scrollregion.")

    def show_home_from_tray(self):
        self.show_window()
        self.show_home()

    def show_library_from_tray(self):
        self.show_window()
        self.show_library()

    def exit_program(self, icon=None, item=None):
        # --- NOWE ZMIANY: wywołaj poprawne zamknięcie ---
        self.on_closing()            # zapisze czas, ustawi flagi, wyłączy RPC itp.
        # --- KONIEC NOWYCH ZMIAN ---


    def minimize_to_tray(self):
        self.root.withdraw()
        self.create_system_tray_icon()

    def create_default_icon(self):
        image = Image.new('RGB', (64, 64), color='blue')
        draw = ImageDraw.Draw(image)
        draw.text((10, 20), "GL", fill='white')
        return image

    # --- NOWE METODY DLA ZASOBNIKA ---
    def show_roadmap_from_tray(self):
        self.show_window()
        self.show_roadmap()

    def show_mods_from_tray(self):
        self.show_window()
        self.show_mod_manager()

    def show_achievements_from_tray(self):
        self.show_window()
        self.show_achievements_page()

    def show_news_from_tray(self):
        self.show_window()
        self.show_news()

    def show_settings_from_tray(self):
        self.show_window()
        self.show_settings()
    # --- KONIEC NOWYCH METOD ---
    # --- NOWA METODA DLA ZASOBNIKA ---
    def show_statistics_from_tray(self):
        """Pokazuje okno launchera i przechodzi do strony Statystyk."""
        # --- NOWE ZMIANY 2: okno → after_idle → ramka ---
        self.show_window()                       # ← patrz pkt 1
        self.root.after_idle(self.show_statistics_page)
        # --- KONIEC NOWYCH ZMIAN 2 ---

    def show_window(self):
        """Przywraca okno z zasobnika i uaktywnia je."""
        # --- NOWE ZMIANY: natychmiastowe przywrócenie okna ---
        if hasattr(self, 'tray_icon'):
            self.tray_icon.stop()          # schowaj ikonę z zasobnika
        self.root.deiconify()              # bez after(0)
        self.root.lift()                   # na wierzch wszystkich
        self.root.focus_force()            # i od razu fokus
        self.root.update_idletasks()       # dorysuj UI
        # --- KONIEC NOWYCH ZMIAN ---


    def on_minimize(self, event):
        if self.root.state() == 'iconic':
            self.root.withdraw()
            self.create_system_tray_icon()

# W klasie GameLauncher

    def on_closing(self):
        if messagebox.askokcancel("Wyjście", "Czy na pewno chcesz wyjść?"):

            # --- Oblicz i przygotuj DANE do zapisu ---
            try:
                # 1. Czas launchera
                elapsed_launcher_time = time.time() - self.launcher_start_time
                current_total_usage = self.local_settings.get("total_launcher_usage_seconds", 0)
                if elapsed_launcher_time > 1:
                    new_total_usage = current_total_usage + elapsed_launcher_time
                    # --- WAŻNE: zaktualizuj wartość w słowniku przed zapisem ---
                    self.local_settings["total_launcher_usage_seconds"] = new_total_usage
                    # --- KONIEC WAŻNEGO ---
                    logging.info(f"Przygotowano łączny czas do zapisu: {new_total_usage:.0f}s")
                else:
                    logging.debug("Sesja launchera zbyt krótka, nie aktualizuję łącznego czasu.")

                # 2. Stan okna, widoku, Discord RPC itp.
                is_zoomed = False
                try:
                    is_zoomed = bool(self.root.wm_attributes('-zoomed'))
                except tk.TclError:
                    if self.root.state() == 'zoomed':
                        is_zoomed = True
                self.local_settings["window_state"] = "zoomed" if is_zoomed else "normal"
                if not is_zoomed and self.root.state() == 'normal':
                    self.local_settings["window_geometry"] = self.root.geometry()

                self.local_settings["library_view_mode"] = self.library_view_mode.get()
                if hasattr(self, 'discord_status_text_var'):
                    self.local_settings["discord_status_text"] = self.discord_status_text_var.get()
                # self.local_settings["discord_rpc_enabled"] = self.discord_rpc_enabled_var.get()  # przykładowe pole

            except Exception as e:
                logging.error(f"Błąd podczas przygotowywania danych do zapisu w on_closing: {e}")

            # --- NOWE ZMIANY: dzienne zużycie launchera ---
                session_start = self.launcher_start_time; session_end = time.time()
                cur_date = datetime.date.fromtimestamp(session_start); last_date = datetime.date.fromtimestamp(session_end)
                daily_usage = self.local_settings.setdefault("launcher_daily_usage_seconds", {})
                while cur_date <= last_date:
                    day_start_ts = time.mktime(cur_date.timetuple()); day_end_ts = day_start_ts + 86400
                    overlap_start = max(session_start, day_start_ts); overlap_end = min(session_end, day_end_ts)
                    seconds_on_day = max(0, overlap_end - overlap_start)
                    if seconds_on_day: daily_usage[cur_date.isoformat()] = daily_usage.get(cur_date.isoformat(), 0) + seconds_on_day
                    cur_date += datetime.timedelta(days=1)

                # --- Zapis ustawień odtwarzacza muzyki ---
                if hasattr(self, 'music_player_page_instance') and self.music_player_page_instance:
                    try:
                        self.music_player_page_instance._save_player_settings()
                        logging.info("Zapisano ustawienia odtwarzacza muzyki.")
                    except Exception as e_music_save:
                        logging.error(f"Błąd podczas zapisywania ustawień odtwarzacza muzyki: {e_music_save}")
                
                # --- Zapis pozycji overlay'a, jeśli istnieje i jest widoczny ---
                if hasattr(self, 'track_overlay') and self.track_overlay and self.track_overlay.winfo_exists() and self.track_overlay.winfo_viewable():
                    try:
                        self.local_settings["overlay_x_pos"] = self.track_overlay.winfo_x()
                        self.local_settings["overlay_y_pos"] = self.track_overlay.winfo_y()
                        logging.debug("Zapisano pozycję overlay'a przed zamknięciem.")
                    except tk.TclError: 
                        logging.warning("Nie można było odczytać pozycji overlay'a (mógł zostać zniszczony).")
                
                # --- ZMIANA: Zapisz stan checkboxa overlay'a (show_track_overlay) ---
                # Upewnij się, że `show_track_overlay_var` jest atrybutem GameLauncher
                if hasattr(self, 'show_track_overlay_var'):
                    self.local_settings["show_track_overlay"] = self.show_track_overlay_var.get()
                    logging.debug(f"Zapisano stan overlay'a: {self.show_track_overlay_var.get()}")
                # --- KONIEC ZMIANY ---

            except Exception as e_prep:
                logging.error(f"Błąd podczas przygotowywania danych do zapisu w on_closing: {e_prep}")
            
            # --- ZMIANA: Przeniesienie zapisu i zamknięcia POZA warunek overlay'a ---
            # Zapisz CAŁY słownik local_settings (zawiera teraz wszystko, co powyżej)
            try:
                save_local_settings(self.local_settings)
                logging.info("Zapisano ustawienia lokalne przy zamykaniu.")
            except Exception as e_save:
                logging.error(f"Błąd zapisu ustawień lokalnych przy zamykaniu: {e_save}")

            # Zatrzymania (Flask, RPC, tray‑icon)
            if hasattr(self, '_server_running') and self._server_running:
                self._stop_flask_server()
            
            if hasattr(self, '_stop_discord_rpc'): # Sprawdź, czy metoda istnieje
                self._stop_discord_rpc() 
            
            if hasattr(self, 'key_combination_listener') and self.key_combination_listener and self.key_combination_listener.is_alive():
                logging.info("Zatrzymywanie listenera przechwytywania nowego skrótu...")
                try: self.key_combination_listener.stop()
                except Exception as e_pynput_stop_capture: logging.error(f"Błąd zatrzymywania listenera przechwytywania: {e_pynput_stop_capture}")
            
            if hasattr(self, 'global_hotkeys_listener') and self.global_hotkeys_listener and self.global_hotkeys_listener.is_alive():
                logging.info("Zatrzymywanie listenera GlobalHotKeys...")
                try: self.global_hotkeys_listener.stop()
                except Exception as e_pynput_stop: logging.error(f"Błąd zatrzymywania GlobalHotKeys: {e_pynput_stop}")

            if hasattr(self, 'tray_icon') and hasattr(self.tray_icon, 'visible') and self.tray_icon.visible:
                try:
                    self.tray_icon.stop()
                except Exception as e_tray:
                    logging.error(f"Błąd zatrzymywania ikony zasobnika: {e_tray}")
            
            self.root.quit() # Zamknij aplikację
            # --- KONIEC ZMIANY ---




    def create_system_tray_icon(self):
        # Utwórz obraz ikony (bez zmian)
        try: image = Image.open("icon.png")
        except FileNotFoundError: image = self.create_default_icon()

        # --- NOWE ZMIANY: Dodanie podmenu Muzyka ---
        music_submenu_items = [
            pystray.MenuItem("Odtwórz / Pauza", self._music_control_play_pause),
            pystray.MenuItem("Poprzedni", self._music_control_prev_track),
            pystray.MenuItem("Następny", self._music_control_next_track),
            pystray.Menu.SEPARATOR,
            pystray.MenuItem("Pokaż Odtwarzacz", self.show_music_page_from_tray)
        ]
        music_submenu = pystray.Menu(*music_submenu_items)
        # --- KONIEC NOWYCH ZMIAN ---

        # --- ZMIANA: Rozbudowane menu ---
        menu = pystray.Menu(
            pystray.MenuItem(self.translator.gettext("Strona Główna"), self.show_home_from_tray),
            pystray.MenuItem(self.translator.gettext("Biblioteka"), self.show_library_from_tray),
            # --- NOWE ZMIANY: Dodanie podmenu Muzyka do głównego menu ---
            pystray.MenuItem("Muzyka", music_submenu), # Dodano podmenu Muzyka
            # --- KONIEC NOWYCH ZMIAN ---
            pystray.Menu.SEPARATOR,
            pystray.MenuItem(self.translator.gettext("Roadmapa"), self.show_roadmap_from_tray),
            # ... (reszta istniejących MenuItem bez zmian) ...
            pystray.MenuItem(self.translator.gettext("Menedżer Modów"), self.show_mods_from_tray),
            pystray.MenuItem(self.translator.gettext("Osiągnięcia"), self.show_achievements_from_tray),
            pystray.MenuItem(self.translator.gettext("Newsy"), self.show_news_from_tray),
            pystray.MenuItem("Statystyki", self.show_statistics_from_tray),
            pystray.Menu.SEPARATOR,
            pystray.MenuItem(self.translator.gettext("Ustawienia"), self.show_settings_from_tray),
            pystray.Menu.SEPARATOR,
            pystray.MenuItem(self.translator.gettext("Wyjdź z Programu"), self.exit_program)
        )

        # --- KONIEC ZMIANY ---

        self.tray_icon = pystray.Icon("GameLauncher", image, "Game Launcher", menu)
        # Uruchom w osobnym wątku (bez zmian)
        threading.Thread(target=self.tray_icon.run, daemon=True).start() # Użyj daemon=True




    def create_reminders_page(self):
        # Wyczyść zawartość reminders_frame
        for widget in self.reminders_frame.winfo_children():
            widget.destroy()

        # Nagłówek
        header = ttk.Frame(self.reminders_frame)
        header.grid(row=0, column=0, sticky="ew")
        ttk.Label(header, text="Przypomnienia", font=("Helvetica", 14)).pack(pady=10)

        # Obszar na listę przypomnień
        list_frame = ttk.Frame(self.reminders_frame)
        list_frame.grid(row=1, column=0, padx=10, pady=10, sticky="nsew")
        list_frame.columnconfigure(0, weight=1)
        list_frame.rowconfigure(0, weight=1)

        self.reminders_listbox = tk.Listbox(list_frame)
        self.reminders_listbox.pack(side="left", fill="both", expand=True)

        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.reminders_listbox.yview)
        scrollbar.pack(side="right", fill="y")
        self.reminders_listbox.config(yscrollcommand=scrollbar.set)

        # Przyciski do zarządzania przypomnieniami
        btn_frame = ttk.Frame(self.reminders_frame)
        btn_frame.grid(row=2, column=0, pady=10)

        add_btn = ttk.Button(btn_frame, text="Dodaj Przypomnienie", command=self.add_reminder)
        add_btn.pack(side="left", padx=5)

        delete_btn = ttk.Button(btn_frame, text="Usuń Przypomnienie", command=self.delete_reminder)
        delete_btn.pack(side="left", padx=5)

        # Załaduj istniejące przypomnienia
        self.load_reminders()


    def delete_reminder(self):
        selected = self.reminders_listbox.curselection()
        if selected:
            index = selected[0]
            del self.reminders[index]
            self.reminders_listbox.delete(index)
            save_config(self.config)
        else:
            messagebox.showwarning("Błąd", "Nie wybrano żadnego przypomnienia.")

    def monitor_reminders(self):
        while True:
            now = time.time()
            to_notify = [r for r in self.reminders if r['time'] <= now and not r.get('notified', False)]
            for reminder in to_notify:
                notification.notify(
                    title="Przypomnienie",
                    message=reminder['message'],
                    timeout=10  # Czas trwania powiadomienia w sekundach
                )
                reminder['notified'] = True
                save_config(self.config)
            time.sleep(60)  # Sprawdzaj co minutę
    
    def add_rss_feed(self):
        new_feed_url = simpledialog.askstring("Dodaj RSS Feed", "Podaj URL RSS Feed:")
        if new_feed_url:
            # Opcjonalnie: zapytaj o nazwę feeda
            new_feed_name = simpledialog.askstring("Nazwa RSS Feed", "Podaj nazwę RSS Feed (opcjonalnie):")
            if not new_feed_name:
                new_feed_name = new_feed_url
            # Sprawdź, czy feed już istnieje
            if any(feed["url"] == new_feed_url for feed in self.settings["rss_feeds"]):
                messagebox.showwarning("Błąd", "Ten RSS Feed już istnieje.")
                return
            # Dodaj nowy feed jako aktywny
            self.settings["rss_feeds"].append({"url": new_feed_url, "active": True, "name": new_feed_name})
            save_config(self.config)
            messagebox.showinfo("Sukces", "RSS Feed został dodany.")
            self.show_settings()  # Odśwież okno ustawień

            # Sprawdź, czy aktualnie wyświetlana jest strona "Newsy"
            if self.current_frame == self.news_frame:
                self.load_news_threaded()





    def remove_rss_feed(self):
        selected = self.rss_listbox.curselection()
        if selected:
            index = selected[0]
            feed = self.rss_listbox.get(index)
            confirm = messagebox.askyesno("Usuń RSS Feed", f"Czy na pewno chcesz usunąć RSS Feed:\n{feed}?")
            if confirm:
                self.settings["rss_feeds"].remove(feed)
                self.rss_listbox.delete(index)
                save_config(self.config)
                messagebox.showinfo("Sukces", "RSS Feed został usunięty.")
        else:
            messagebox.showwarning("Błąd", "Nie wybrano żadnego RSS Feed.")

    def update_post_limit(self):
        try:
            limit = self.post_limit_var.get()
            if limit < 1:
                raise ValueError
            self.settings["news_post_limit"] = limit
            save_config(self.config)
            self.load_news_threaded()  # Odśwież newsy
        except:
            messagebox.showwarning("Błąd", "Proszę podać prawidłową liczbę.")


    def load_news_threaded(self):
        if hasattr(self, 'news_content') and self.news_content:
            threading.Thread(target=self.load_news, args=(self.news_content,), daemon=True).start()
        else:
            logging.error("Nie znaleziono widgetu news_content.")



    def update_rss_feeds(self):
        for idx, feed in enumerate(self.settings["rss_feeds"]):
            self.settings["rss_feeds"][idx]["active"] = self.rss_vars[idx].get()
        save_config(self.config)
        messagebox.showinfo("Sukces", "Ustawienia RSS Feeds zostały zaktualizowane.")

        # Automatyczne odświeżenie newsów, jeśli aktualna strona to "Newsy"
        if self.current_frame == self.news_frame:
            self.load_news_threaded()


    def remove_specific_rss_feed(self, feed):
        confirm = messagebox.askyesno("Usuń RSS Feed", f"Czy na pewno chcesz usunąć RSS Feed:\n{feed.get('name', feed['url'])}?")
        if confirm:
            self.settings["rss_feeds"].remove(feed)
            save_config(self.config)
            messagebox.showinfo("Sukces", "RSS Feed został usunięty.")
            self.show_settings()  # Odśwież okno ustawień

            # Sprawdź, czy aktualnie wyświetlana jest strona "Newsy"
            if self.current_frame == self.news_frame:
                self.load_news_threaded()


    def create_roadmap_page(self):
        """Tworzy strukturę UI strony Roadmapy, ładowanie danych jest odroczone."""
        if not hasattr(self, 'roadmap_frame'):
            self.roadmap_frame = ttk.Frame(self.root)
            self.roadmap_frame.grid(row=0, column=1, sticky="nsew")
            self.roadmap_frame.columnconfigure(0, weight=1)
            self.roadmap_frame.rowconfigure(1, weight=1) # Zmieniono na wiersz 1 dla zawartości
        else:
            # Nie niszcz i nie twórz na nowo całej ramki przy każdym pokazaniu
            self.roadmap_frame.tkraise()
            # Jeśli dane były już ładowane, nie musimy ich ładować ponownie,
            # chyba że chcemy odświeżać za każdym razem.
            # Na razie zakładamy, że dane ładują się raz przy tworzeniu.
            # Jeśli chcesz odświeżać, dodaj wywołanie root.after tutaj.
            # self.root.after(100, self._populate_roadmap_and_archive_data)
            return # Zakończ, jeśli ramka już istnieje

        # Wyczyść istniejącą zawartość TYLKO jeśli tworzymy od nowa
        for widget in self.roadmap_frame.winfo_children():
            widget.destroy()

        # Nagłówek (w wierszu 0)
        header = ttk.Label(self.roadmap_frame, text=self.translator.gettext("Roadmapa Gier"), font=("Helvetica", 20, "bold"))
        header.grid(row=0, column=0, pady=10, sticky="n") # Użyj grid

        # Opcjonalnie: Wskaźnik ładowania
        # self.roadmap_loading_label = ttk.Label(self.roadmap_frame, text="Ładowanie danych...")
        # self.roadmap_loading_label.grid(row=1, column=0, pady=20)

        # Utwórz Notebook (w wierszu 1)
        notebook = ttk.Notebook(self.roadmap_frame)
        notebook.grid(row=1, column=0, sticky="nsew", padx=5, pady=5) # Użyj grid

        # Zakładka Obecne Gry
        current_frame = ttk.Frame(notebook)
        notebook.add(current_frame, text=self.translator.gettext("Obecne"))

        # Zakładka Archiwum
        archive_frame = ttk.Frame(notebook)
        notebook.add(archive_frame, text=self.translator.gettext("Archiwum"))

        # Tworzenie interfejsu dla Obecnych Gier (bez ładowania danych)
        self.create_current_games_ui(current_frame)

        # Tworzenie interfejsu dla Archiwum (bez ładowania danych)
        self.create_archive_ui(archive_frame)

        # --- ODROCZENIE ŁADOWANIA DANYCH ---
        # Wywołaj ładowanie danych po krótkiej chwili
        self.root.after(150, self._populate_roadmap_and_archive_data) # Dajmy trochę więcej czasu (150ms)
        # --- KONIEC ODROCZENIA ---


    def create_current_games_ui(self, parent_frame):
        # Główna ramka zawartości z PanedWindow
        paned_window = ttk.PanedWindow(parent_frame, orient=tk.HORIZONTAL)
        paned_window.pack(fill='both', expand=True)

        # Lewa ramka dla dodawania gier i listy
        left_frame = ttk.Frame(paned_window)
        paned_window.add(left_frame, weight=1)

        # Prawa ramka dla kalendarza
        right_frame = ttk.Frame(paned_window)
        paned_window.add(right_frame, weight=1)

        # Sekcja dodawania gry
        self.create_add_game_section(left_frame)

        # Lista Roadmapy (Treeview)
        self.create_roadmap_tree(left_frame)

        # Przyciski zarządzania Roadmapą
        self.create_roadmap_buttons(left_frame)

        # Kalendarz w prawej ramce
        # --- ZMIANA: Dodaj locale='pl_PL' ---
        self.roadmap_calendar = Calendar(
            right_frame,
            selectmode='day',
            date_pattern='yyyy-MM-dd',
            locale='pl_PL' # Ustawienie języka polskiego
        )
        # --- KONIEC ZMIANY ---
        self.roadmap_calendar.pack(fill="both", expand=True)

        # Załaduj istniejące gry
 

    def create_archive_ui(self, parent_frame):
        # Nagłówek
        archive_header = ttk.Label(parent_frame, text="Archiwum Gier", font=("Helvetica", 16, "bold"))
        archive_header.pack(pady=10)

        # Okno z podziałem na lewą i prawą część
        paned_window = ttk.PanedWindow(parent_frame, orient=tk.HORIZONTAL)
        paned_window.pack(fill='both', expand=True)

        # Lewa ramka dla Treeview
        left_frame = ttk.Frame(paned_window)
        paned_window.add(left_frame, weight=1)

        # Prawa ramka dla Kalendarza
        right_frame = ttk.Frame(paned_window)
        paned_window.add(right_frame, weight=1)

        # Lista Archiwum (Treeview)
        self.archive_tree = ttk.Treeview(
            left_frame,
            columns=("Nazwa Gry", "Data Rozpoczęcia", "Data Ukończenia", "Czas Spędzony"),
            show='headings'
        )
        self.archive_tree.heading("Nazwa Gry", text="Nazwa Gry")
        self.archive_tree.heading("Data Rozpoczęcia", text="Data Rozpoczęcia")
        self.archive_tree.heading("Data Ukończenia", text="Data Ukończenia")
        self.archive_tree.heading("Czas Spędzony", text="Czas Spędzony")
        self.archive_tree.pack(fill="both", expand=True)

        # Pionowy pasek przewijania dla tabeli
        scrollbar = ttk.Scrollbar(left_frame, orient="vertical", command=self.archive_tree.yview)
        scrollbar.pack(side="right", fill="y")
        self.archive_tree.configure(yscrollcommand=scrollbar.set)

        # Kalendarz w prawej ramce
        # --- ZMIANA: Dodaj locale='pl_PL' ---
        self.archive_calendar = Calendar(
            right_frame,
            selectmode='day',
            date_pattern='yyyy-MM-dd',
            locale='pl_PL' # Ustawienie języka polskiego
        )
        # --- KONIEC ZMIANY ---
        self.archive_calendar.pack(fill="both", expand=True)

        # Dodaj legendę do kolorów
        self.create_archive_legend(parent_frame)


# W klasie GameLauncher

    def load_archive(self):
        """Ładuje archiwalne gry do Treeview archiwum z dynamicznym kolorem czcionki."""
        self.archive_tree.delete(*self.archive_tree.get_children())
        for game in self.archive:
            game_name = game.get("game_name", "")
            start_date = game.get("start_date", "")
            completion_date = game.get("completion_date", "")
            time_spent = self.format_play_time(game.get("time_spent", 0))

            try:
                completion_month = datetime.datetime.strptime(completion_date, '%Y-%m-%d').month
            except:
                completion_month = None

            if completion_month:
                tag = f"month_{completion_month}"
                self.archive_tree.insert("", "end", values=(game_name, start_date, completion_date, time_spent), tags=(tag,))
            else:
                self.archive_tree.insert("", "end", values=(game_name, start_date, completion_date, time_spent))

        # Konfiguracja stylów dla tagów miesiąca
        for month, color in MONTH_COLORS.items():
            tag = f"month_{month}"
            # --- NOWE: Pobierz kolor kontrastowy ---
            fg_color = get_contrast_color(color)
            # --- KONIEC NOWEGO ---
            # --- ZMIANA: Użyj fg_color dla foreground ---
            self.archive_tree.tag_configure(tag, background=color, foreground=fg_color)
            # --- KONIEC ZMIANY ---



    
    def update_archive_calendar(self):
        """Aktualizuje kalendarz w Archiwum z dynamicznym kolorem czcionki."""
        self.archive_calendar.calevent_remove('all')
        for game in self.archive:
            try:
                completion_date = datetime.datetime.strptime(game["completion_date"], '%Y-%m-%d').date()
                completion_month = completion_date.month
                tag = f"month_{completion_month}"
                # Upewnij się, że tag jest przekazywany jako krotka lub lista
                self.archive_calendar.calevent_create(completion_date, game['game_name'], tags=[tag])
            except Exception as e:
                logging.error(f"Nie udało się oznaczyć daty ukończenia dla gry {game['game_name']}: {e}")

        # Konfiguracja stylów dla tagów miesiąca w kalendarzu
        for month, color in MONTH_COLORS.items():
            tag = f"month_{month}"
            # --- NOWE: Pobierz kolor kontrastowy ---
            fg_color = get_contrast_color(color)
            # --- KONIEC NOWEGO ---
            # --- ZMIANA: Użyj fg_color dla foreground w tag_config ---
            try:
                # tkcalendar powinien obsługiwać foreground i background w tag_config
                self.archive_calendar.tag_config(tag, background=color, foreground=fg_color)
            except Exception as e_cal:
                 logging.warning(f"Nie można ustawić dynamicznych kolorów dla tagu kalendarza '{tag}': {e_cal}")
                 self.archive_calendar.tag_config(tag, background=color) # Fallback
            # --- KONIEC ZMIANY ---

    
    def create_archive_legend(self, parent_frame):
        """Dodaje legendę do sekcji Archiwum z dynamicznym kolorem czcionki."""
        legend_frame = ttk.Frame(parent_frame)
        legend_frame.pack(pady=5)

        ttk.Label(legend_frame, text="Legenda:").pack(side="left", padx=(0, 5))

        for month in range(1, 13):
            bg_color = MONTH_COLORS.get(month, "white")
            month_name = MONTH_NAMES_PL.get(month, "")
            # --- NOWE: Pobierz kolor kontrastowy ---
            fg_color = get_contrast_color(bg_color) # Wywołaj funkcję pomocniczą
            # --- KONIEC NOWEGO ---
            # --- ZMIANA: Użyj fg_color dla foreground ---
            # Dodajemy też padding, aby tekst nie stykał się z krawędziami
            label = ttk.Label(legend_frame, text=month_name, background=bg_color, foreground=fg_color, padding=(4, 2), anchor='center')
            # --- KONIEC ZMIANY ---
            label.pack(side="left", padx=3) # Zmniejszono padx




    def load_roadmap(self):
        """Ładuje gry z Roadmapy do Treeview."""
        self.roadmap_tree.delete(*self.roadmap_tree.get_children())
        for game in self.roadmap:
            game_name = game.get("game_name", "")
            start_date = game.get("start_date", "")
            end_date = game.get("end_date", "")
            status = game.get("status", "Planowana")
            time_spent = self.format_play_time(game.get("time_spent", 0))
            self.roadmap_tree.insert("", "end", values=(game_name, start_date, end_date, status, time_spent))
            self.mark_calendar_dates(game)


    def _hide_library_components(self):
        """Ukrywa komponenty specyficzne dla widoku Biblioteki."""
        if hasattr(self, 'canvas') and self.canvas.winfo_ismapped():
            self.canvas.grid_remove()
        if hasattr(self, 'scrollbar') and self.scrollbar.winfo_ismapped():
            self.scrollbar.grid_remove()
        if hasattr(self, 'pagination_frame') and self.pagination_frame.winfo_ismapped():
            self.pagination_frame.grid_remove()
        if hasattr(self, 'list_view_frame') and self.list_view_frame.winfo_ismapped():
            self.list_view_frame.grid_remove()

    def mark_calendar_dates(self, game):
        """Oznacza daty w kalendarzu związane z Roadmapą."""
        try:
            start_date = datetime.datetime.strptime(game["start_date"], '%Y-%m-%d').date()
            end_date = datetime.datetime.strptime(game["end_date"], '%Y-%m-%d').date()
            delta = end_date - start_date
            for i in range(delta.days + 1):
                day = start_date + datetime.timedelta(days=i)
                self.roadmap_calendar.calevent_create(day, game['game_name'], 'planned_game')
            # Konfiguracja wyglądu tagu
            self.roadmap_calendar.tag_config('planned_game', background='blue', foreground='white')
        except Exception as e:
            logging.error(f"Nie udało się oznaczyć dat dla gry {game['game_name']}: {e}")

    def update_calendar(self):
        """Aktualizuje kalendarz z wydarzeniami z Roadmapy."""
        self.roadmap_calendar.calevent_remove('all')  # Usuń istniejące wydarzenia
        for game in self.roadmap:
            self.mark_calendar_dates(game)

    # --- NOWE ZMIANY: Metody dla ignorowanych folderów screenshotów ---
    def load_screenshot_ignored_folders(self):
        """Wczytuje listę ignorowanych folderów screenshotów do pola Text."""
        if hasattr(self, 'ss_ignored_folders_text') and self.ss_ignored_folders_text.winfo_exists():
            ignored_list = self.settings.get("screenshot_scan_ignore_folders", []) # Użyj nowego klucza
            self.ss_ignored_folders_text.delete("1.0", tk.END)
            self.ss_ignored_folders_text.insert("1.0", "\n".join(ignored_list))

    def save_screenshot_ignored_folders(self):
        """Pobiera nazwy z pola Text, czyści je i zapisuje do konfiguracji (screenshoty)."""
        if hasattr(self, 'ss_ignored_folders_text') and self.ss_ignored_folders_text.winfo_exists():
            raw_text = self.ss_ignored_folders_text.get("1.0", tk.END)
            # Użyj list comprehension dla zwięzłości, konwersja na małe litery
            ignored_list = [line.strip().lower() for line in raw_text.splitlines() if line.strip()]
            unique_ignored_list = sorted(list(set(ignored_list)))

            self.settings["screenshot_scan_ignore_folders"] = unique_ignored_list # Użyj nowego klucza
            save_config(self.config)
            self.load_screenshot_ignored_folders() # Przeładuj, aby pokazać oczyszczoną listę
            messagebox.showinfo("Zapisano", "Lista ignorowanych folderów dla screenshotów została zapisana.", parent=self.settings_page_frame) # Parent
            logging.info(f"Zapisano ignorowane foldery screenshotów: {unique_ignored_list}")
    # --- KONIEC NOWYCH ZMIAN ---

    def create_add_game_section(self, parent_frame):
        """Tworzy sekcję dodawania gry do Roadmapy."""
        add_frame = ttk.LabelFrame(parent_frame, text="Dodaj grę do Roadmapy")
        add_frame.pack(pady=10, padx=10, fill="x")

        # Nazwa gry jako Combobox
        ttk.Label(add_frame, text="Nazwa Gry:").grid(row=0, column=0, padx=5, pady=5, sticky="e")
        self.roadmap_game_name = ttk.Combobox(add_frame, values=list(self.games.keys()), state="readonly")
        self.roadmap_game_name.grid(row=0, column=1, padx=5, pady=5, sticky="w")
        self.roadmap_game_name.set("Wybierz grę")

        # Data rozpoczęcia z DateEntry
        ttk.Label(add_frame, text="Data Rozpoczęcia:").grid(row=1, column=0, padx=5, pady=5, sticky="e")
        self.roadmap_start_cal = DateEntry(add_frame, date_pattern='yyyy-MM-dd')
        self.roadmap_start_cal.grid(row=1, column=1, padx=5, pady=5, sticky="w")

        # Planowana data zakończenia z DateEntry
        ttk.Label(add_frame, text="Planowana Data Zakończenia:").grid(row=2, column=0, padx=5, pady=5, sticky="e")
        self.roadmap_end_cal = DateEntry(add_frame, date_pattern='yyyy-MM-dd')
        self.roadmap_end_cal.grid(row=2, column=1, padx=5, pady=5, sticky="w")

        # Przycisk dodawania
        add_btn = ttk.Button(add_frame, text="Dodaj do Roadmapy", command=self.add_to_roadmap)
        add_btn.grid(row=3, column=0, columnspan=2, pady=10)

    def create_roadmap_tree(self, parent_frame):
        """Tworzy Treeview dla Roadmapy."""
        self.roadmap_tree = ttk.Treeview(
            parent_frame,
            columns=("Nazwa Gry", "Data Rozpoczęcia", "Data Zakończenia", "Status", "Czas Spędzony"),
            show='headings'
        )
        self.roadmap_tree.heading("Nazwa Gry", text="Nazwa Gry")
        self.roadmap_tree.heading("Data Rozpoczęcia", text="Data Rozpoczęcia")
        self.roadmap_tree.heading("Data Zakończenia", text="Data Zakończenia")
        self.roadmap_tree.heading("Status", text="Status")
        self.roadmap_tree.heading("Czas Spędzony", text="Czas Spędzony")
        self.roadmap_tree.pack(fill="both", expand=True)


        # Pionowy pasek przewijania dla tabeli
        scrollbar = ttk.Scrollbar(parent_frame, orient="vertical", command=self.roadmap_tree.yview)
        scrollbar.pack(side="right", fill="y")
        self.roadmap_tree.configure(yscrollcommand=scrollbar.set)

    def create_roadmap_buttons(self, parent_frame):
        """Tworzy przyciski zarządzania Roadmapą."""
        btn_frame = ttk.Frame(parent_frame)
        btn_frame.pack(pady=5)

        complete_btn = ttk.Button(btn_frame, text="Oznacz jako Ukończoną", command=self.mark_as_completed)
        complete_btn.pack(side="left", padx=5)

        delete_btn = ttk.Button(btn_frame, text="Usuń z Roadmapy", command=self.delete_from_roadmap)
        delete_btn.pack(side="left", padx=5)


# W klasie GameLauncher

    def _copy_or_delete_with_progress(self, operation_type, source_path, dest_path, operation_title, parent_window=None, callback_on_success=None): # Dodano callback
        """Wykonuje kopiowanie (copytree) lub usuwanie (rmtree) w tle z paskiem postępu."""
        if parent_window is None: parent_window = self.root

        logging.info(f"Rozpoczynanie operacji '{operation_type}' dla '{source_path}' -> '{dest_path}'")

        if not source_path or not os.path.exists(source_path):
             messagebox.showerror("Błąd", f"Ścieżka źródłowa nie istnieje:\n{source_path}", parent=parent_window)
             return False
        if operation_type == 'copy' and not dest_path:
             messagebox.showerror("Błąd", "Ścieżka docelowa jest wymagana do kopiowania.", parent=parent_window)
             return False

        try:
            total_files = 0
            if os.path.isdir(source_path) and operation_type == 'copy': # Dla kopiowania folderu
                for _, _, files_in_dir_count in os.walk(source_path):
                    total_files += len(files_in_dir_count)
            elif os.path.isfile(source_path) and operation_type == 'copy':
                total_files = 1
            elif operation_type == 'delete': 
                 total_files = 1 

            if total_files == 0 and operation_type == 'copy':
                 if dest_path: os.makedirs(dest_path, exist_ok=True)
                 messagebox.showinfo("Informacja", "Folder źródłowy jest pusty.", parent=parent_window)
                 if callback_on_success: # Wywołaj callback nawet jeśli nic nie skopiowano (bo operacja jako taka "się udała")
                     self.root.after(0, callback_on_success)
                 return True 

            self.show_progress_window(operation_title)
            self.progress_bar['maximum'] = total_files
            self.progress_bar['value'] = 0
            self.progress_bar['mode'] = 'determinate'
            self.progress_label.config(text=f"0 / {total_files}")

            op_thread = threading.Thread(
                 target=self._perform_file_operation_thread,
                 kwargs={
                     'operation_type': operation_type,
                     'src': source_path, # Zmieniono nazwę parametru na 'src'
                     'dst': dest_path,   # Zmieniono nazwę parametru na 'dst'
                     'total_files': total_files,
                     'callback_on_success': callback_on_success
                 },
                 daemon=True
            )
            op_thread.start()
            return True 

        except Exception as e:
            logging.exception(f"Błąd przed rozpoczęciem operacji '{operation_type}': {e}")
            if hasattr(self, 'progress_window') and self.progress_window.winfo_exists(): self.progress_window.destroy()
            messagebox.showerror(f"Błąd {operation_title}", f"Nie można rozpocząć operacji:\n{e}", parent=parent_window)
            return False

    def load_autoscan_folders_list(self):
        """Ładuje listę folderów do skanowania screenshotów do listboxa w ustawieniach."""
        if hasattr(self, 'autoscan_folders_listbox') and self.autoscan_folders_listbox.winfo_exists():
            self.autoscan_folders_listbox.delete(0, tk.END)
            scan_folders = self.settings.get("autoscan_screenshot_folders", [])
            for folder in scan_folders:
                self.autoscan_folders_listbox.insert(tk.END, folder)

    # --- NOWE ZMIANY ---
    def start_scan_screenshots_thread(self, game_to_scan=None):
        """Uruchamia skanowanie folderów screenshotów w osobnym wątku."""
        # --- USUNIĘTO SPRAWDZENIE TUTAJ ---
        # scan_folders = self.settings.get("autoscan_screenshot_folders", [])
        # if not scan_folders:
        #     messagebox.showinfo("Informacja", "Nie zdefiniowano żadnych folderów do skanowania screenshotów. Dodaj je w ustawieniach.", parent=self.root) # Poprzednio self.root
        #     return
        # --- KONIEC USUNIĘCIA ---

        # Sprawdź, czy inne okno postępu już nie istnieje
        if hasattr(self, 'progress_window') and self.progress_window.winfo_exists():
            # --- ZMIANA: Ustaw odpowiedniego rodzica dla komunikatu ---
            # Trudno jednoznacznie określić rodzica tutaj, użyjmy self.root
            messagebox.showwarning("Skanowanie w toku", "Inna operacja (np. synchronizacja, skanowanie) jest już w toku.", parent=self.root)
            # --- KONIEC ZMIANY ---
            return

        title = f"Skanowanie screenshotów dla: {game_to_scan}" if game_to_scan else "Skanowanie screenshotów..."
        self.show_progress_window(title)
        self.progress_bar['mode'] = 'indeterminate' # Zaczynamy jako nieokreślony
        self.progress_bar.start()
        self.progress_label.config(text="Przygotowywanie...")

        # Uruchom wątek skanowania
        scan_thread = threading.Thread(
            target=self._scan_for_screenshots_thread,
            args=(game_to_scan,), # Przekaż nazwę gry, jeśli skanujemy tylko jedną
            daemon=True
        )
        scan_thread.start()

    def _on_view_change(self, event=None):
        selected_display_view = self.stats_view_var.get()
        view_key = self.TRANSLATED_TO_STATS_VIEW.get(selected_display_view, "Playtime per Day")

        # Najpierw ukryj wszystkie dynamiczne kontrolki
        self.stats_game_select_frame.pack_forget() # Używamy pack wewnątrz dynamic_controls_frame
        self.show_time_details_button.grid_remove()
        self.dynamic_controls_frame.grid_remove() # Ukryj całą ramkę dynamicznych kontrolek

        # Pokaż odpowiednie kontrolki
        if view_key == "Playtime per Game (Selected)":
            self.dynamic_controls_frame.grid(row=0, column=4, padx=5, pady=5, sticky="w") # Pokaż ramkę
            self.stats_game_select_frame.pack(side=tk.LEFT) # Pokaż wybór gry
        elif view_key == "Playtime per Day":
            # Przycisk szczegółów czasu umieszczamy bezpośrednio w controls_frame
            self.show_time_details_button.grid(row=0, column=5, padx=5, pady=5, sticky="e") # Dopasuj kolumnę
        # Można dodać inne warunki, jeśli inne widoki wymagają specjalnych kontrolek

        # Ukryj ramkę detali, jeśli widok jej nie używa
        if view_key not in ["Games Played per Day", "Playtime per Day"]:
            if hasattr(self, 'details_frame') and self.details_frame.winfo_ismapped():
                self.details_frame.grid_remove()
                if hasattr(self, 'chart_container') and self.chart_container.winfo_exists():
                    self.chart_container.master.columnconfigure(0, weight=1)
                    self.chart_container.master.columnconfigure(1, weight=0)

    def _on_period_change(self, event=None):
        selected_display_period = self.stats_period_var.get()
        period_key = self.TRANSLATED_TO_STATS_PERIOD.get(selected_display_period)

        # Najpierw ukryj dynamiczne kontrolki, które są częścią dynamic_controls_frame
        self.custom_range_frame.pack_forget() # Używamy pack dla custom_range_frame

        if period_key == "Custom Range...":
            self.dynamic_controls_frame.grid(row=0, column=4, padx=5, pady=5, sticky="w") # Pokaż główną ramkę dynamiczną
            self.custom_range_frame.pack(side=tk.LEFT) # Pokaż wybór zakresu dat
        else:
            # Jeśli nie Custom Range, sprawdź czy dynamic_controls_frame musi być widoczna dla innych opcji
            # (np. dla wyboru gry)
            view_key = self.TRANSLATED_TO_STATS_VIEW.get(self.stats_view_var.get())
            if view_key != "Playtime per Game (Selected)": # Jeśli nie wybrano gry, można ukryć całą ramkę
                 self.dynamic_controls_frame.grid_remove()


        self._on_view_change() # Zawsze wywołaj, aby zsynchronizować widoczność

        # Opcjonalnie: Automatycznie odśwież wykres po zmianie widoku
        # self._on_refresh_stats_threaded()
    # --- KONIEC NOWEJ METODY ---

    def _scan_for_screenshots_thread(self, game_to_scan=None):
        """
        Skanuje skonfigurowane foldery w poszukiwaniu screenshotów pasujących do gier.
        Jeśli game_to_scan jest podane, skanuje tylko dla tej gry.
        """
        scan_folders = self.settings.get("autoscan_screenshot_folders", [])
        # --- DODANO PONOWNE SPRAWDZENIE PRZED PĘTLĄ ---
        if not scan_folders:
            logging.warning("Wykryto brak folderów do skanowania w wątku _scan_for_screenshots_thread (nie powinno się zdarzyć).")
            self.root.after(0, self._destroy_progress_window)
            # Nie pokazuj tu messagebox, bo powinien być pokazany wcześniej
            return
        # --- NOWE ZMIANY: Pobierz listę ignorowanych folderów ---
        ignored_folder_names = set(name.lower() for name in self.settings.get("screenshot_scan_ignore_folders", []))
        logging.info(f"Ignorowane foldery screenshotów: {ignored_folder_names}")
        # --- KONIEC NOWYCH ZMIAN ---
        # --- KONIEC DODATKU ---
        # Proste wzorce dopasowania (można rozbudować)
        supported_extensions = ('.png', '.jpg', '.jpeg', '.bmp', '.webp', '.gif')
        found_new_count_total = 0
        processed_files_count = 0
        scan_start_time = time.time()

        try:
            # 1. Zbierz listę gier do sprawdzenia
            games_to_check = {}
            if game_to_scan:
                 if game_to_scan in self.games:
                     games_to_check[game_to_scan] = self.games[game_to_scan]
                 else:
                     logging.error(f"Skanowanie screenshotów: Nie znaleziono gry '{game_to_scan}'")
                     self.root.after(0, lambda: messagebox.showerror("Błąd", f"Gra '{game_to_scan}' nie istnieje.", parent=self.root))
                     self.root.after(0, self._destroy_progress_window)
                     return
            else: # Skanuj dla wszystkich gier
                 games_to_check = self.games.copy() # Pracuj na kopii

            if not games_to_check:
                 logging.info("Brak gier w bibliotece do skanowania screenshotów.")
                 self.root.after(0, lambda: messagebox.showinfo("Informacja", "Biblioteka gier jest pusta.", parent=self.root))
                 self.root.after(0, self._destroy_progress_window)
                 return

            # Przygotuj dane do aktualizacji UI postępu
            total_folders_to_scan = len(scan_folders)
            current_folder_index = 0

            # Zaktualizuj UI paska postępu przed pętlą
            self.root.after(0, lambda: (
                self.progress_bar.stop(),
                self.progress_bar.config(mode='determinate', maximum=100, value=0), # Użyjemy % przetwarzanych plików
                self.progress_label.config(text="Rozpoczynanie skanowania...")
            ))
            time.sleep(0.1) # Daj czas na aktualizację UI

            something_changed = False # Flaga, czy zapisywać config

            # 2. Iteruj przez foldery do skanowania
            for folder_path in scan_folders:
                current_folder_index += 1
                folder_name = os.path.basename(folder_path)
                logging.info(f"Skanowanie folderu: {folder_path} ({current_folder_index}/{total_folders_to_scan})")
                # Aktualizuj etykietę folderu
                self.root.after(0, lambda f=folder_name, i=current_folder_index, t=total_folders_to_scan:
                                self.progress_label.config(text=f"Folder {i}/{t}: {f}"))

                if not os.path.isdir(folder_path):
                    logging.warning(f"Folder '{folder_path}' nie istnieje. Pomijanie.")
                    continue

                # Przejdź przez pliki w folderze (rekursywnie)
                files_in_folder = []
                for root, dirs, files in os.walk(folder_path):
                     # --- NOWE ZMIANY: Modyfikuj dirs w miejscu, aby pominąć ignorowane ---
                     # Sprawdź nazwy folderów w `dirs` i usuń te, które mają być ignorowane
                     dirs[:] = [d for d in dirs if d.lower() not in ignored_folder_names]
                     # --- KONIEC NOWYCH ZMIAN ---
                     for filename in files:
                         files_in_folder.append(os.path.join(root, filename))

                total_files_in_folder = len(files_in_folder)
                processed_files_in_folder = 0

                for file_path in files_in_folder:
                    processed_files_count += 1
                    processed_files_in_folder += 1

                    # Aktualizuj pasek postępu (co 50 plików lub co sekundę)
                    now = time.time()
                    if processed_files_count % 50 == 0 or now - scan_start_time > 1:
                         percent_overall = int((current_folder_index / total_folders_to_scan) * 100) # Procent folderów
                         # percent_files = int((processed_files_in_folder / total_files_in_folder) * 100) if total_files_in_folder > 0 else 0
                         self.root.after(0, lambda p=percent_overall, fn=os.path.basename(file_path): (
                              self.progress_bar.config(value=p),
                              self.progress_label.config(text=f"Folder {current_folder_index}/{total_folders_to_scan}: {fn} ({p}%)")
                         ))
                         scan_start_time = now # Resetuj timer dla aktualizacji co sekundę

                    # Sprawdź rozszerzenie
                    if not file_path.lower().endswith(supported_extensions):
                        continue

                    filename_lower = os.path.basename(file_path).lower()

                    # 3. Dopasuj plik do gier
                    for game_name, game_data in games_to_check.items():
                        game_name_lower = game_name.lower()
                        # Prosta logika dopasowania: czy nazwa pliku zaczyna się od nazwy gry?
                        # TODO: Rozważyć bardziej zaawansowane dopasowanie (regex, usuwanie daty itp.)
                        if filename_lower.startswith(game_name_lower):
                            # Znaleziono potencjalne dopasowanie
                            autoscan_list = game_data.setdefault("autoscan_screenshots", [])
                            abs_file_path = os.path.abspath(file_path)

                            # Dodaj, jeśli jeszcze nie ma na liście automatycznej
                            if abs_file_path not in autoscan_list:
                                # Dodatkowo sprawdź, czy nie ma już w liście ręcznej
                                manual_list = game_data.get("screenshots", [])
                                if abs_file_path not in manual_list:
                                    autoscan_list.append(abs_file_path)
                                    found_new_count_total += 1
                                    something_changed = True
                                    logging.info(f"Znaleziono nowy screenshot dla '{game_name}': {abs_file_path}")
                                else:
                                     logging.debug(f"Screenshot '{abs_file_path}' już istnieje w liście ręcznej dla '{game_name}'.")
                            # else:
                            #      logging.debug(f"Screenshot '{abs_file_path}' już jest na liście autoscan dla '{game_name}'.")

                            # Jeśli znaleziono dopasowanie, nie trzeba sprawdzać dla innych gier
                            break # Przejdź do następnego pliku

            # 4. Zapisz konfigurację, jeśli coś się zmieniło
            if something_changed:
                save_config(self.config)

            scan_duration = time.time() - scan_start_time
            logging.info(f"Skanowanie screenshotów zakończone w {scan_duration:.2f}s. Znaleziono {found_new_count_total} nowych screenshotów.")

            # Zakończ i zamknij okno postępu
            self.root.after(0, self._destroy_progress_window)
            # Pokaż podsumowanie
            self.root.after(10, lambda count=found_new_count_total:
                             messagebox.showinfo("Skanowanie Zakończone", f"Skanowanie zakończone.\nZnaleziono {count} nowych screenshotów.", parent=self.root))

            # Jeśli skanowanie było dla konkretnej gry, odśwież jej okno szczegółów
            if game_to_scan:
                self.root.after(50, lambda gn=game_to_scan: self._refresh_details_window_if_open(gn))

        except Exception as e:
            logging.exception("Błąd podczas skanowania screenshotów.")
            self.root.after(0, self._destroy_progress_window)
            self.root.after(0, lambda err=e: messagebox.showerror("Błąd Skanowania", f"Wystąpił nieoczekiwany błąd: {err}", parent=self.root))

    def _refresh_details_window_if_open(self, game_name):
        """Sprawdza, czy okno szczegółów dla danej gry jest otwarte i je odświeża."""
        details_title = f"Szczegóły Gry - {game_name}"
        for widget in self.root.winfo_children():
            if isinstance(widget, tk.Toplevel) and widget.title() == details_title:
                if isinstance(widget, GameDetailsWindow) and widget.winfo_exists():
                    logging.info(f"Odświeżanie otwartego okna szczegółów dla: {game_name} po skanowaniu screenshotów.")
                    widget.refresh_details_data()
                    # Opcjonalnie przełącz na zakładkę Screenshoty
                    self._show_game_details_and_select_tab(game_name, "Screenshoty")
                    break
    # --- KONIEC NOWYCH ZMIAN ---


    # --- NOWE METODY dla serwera Flask ---

    def _get_local_ip(self):
        """Próbuje znaleźć lokalny adres IP komputera."""
        s = None
        try:
            # Spróbuj połączyć się z publicznym adresem DNS, aby system wybrał odpowiedni interfejs
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.settimeout(0.1) # Unikaj długiego czekania
            s.connect(('8.8.8.8', 1)) # Nie wysyła danych, tylko ustala trasę
            ip = s.getsockname()[0]
            return ip
        except Exception as e:
            logging.error(f"Nie można automatycznie wykryć lokalnego IP: {e}")
            # Spróbuj hostname jako fallback (może nie działać poprawnie z IP)
            try:
                 return socket.gethostbyname(socket.gethostname())
            except socket.gaierror:
                 logging.error("Nie można pobrać IP nawet przez hostname.")
                 return "127.0.0.1" # Ostateczny fallback
        finally:
            if s:
                s.close()

    # Zmodyfikuj _flask_server_target, aby przyjmował port
    def _flask_server_target(self, port): # Dodano argument port
        """Funkcja docelowa dla wątku serwera Flask."""
        try:
            logging.info(f"Uruchamianie serwera Flask na porcie {port}...") # Użyj port z argumentu
            self._flask_app.run(host='0.0.0.0', port=port, debug=False, use_reloader=False) # Użyj port z argumentu
            logging.info("Serwer Flask zakończył działanie.")
        except OSError as e:
             if e.errno == 98 or e.errno == 10048:
                  logging.error(f"Port {port} jest już zajęty!")
                  self.root.after(0, lambda p=port: messagebox.showerror("Błąd Serwera", f"Port {p} jest już używany przez inną aplikację.", parent=self.root))
             else:
                  logging.exception("Błąd podczas uruchamiania serwera Flask.")
                  self.root.after(0, lambda err=e: messagebox.showerror("Błąd Serwera", f"Nie można uruchomić serwera Flask:\n{err}", parent=self.root))
             self.root.after(0, self._update_server_status_ui, False)
        except Exception as e:
            logging.exception("Nieoczekiwany błąd w wątku serwera Flask.")
            self.root.after(0, self._update_server_status_ui, False)
        finally:
             self._server_running = False
             self._flask_thread = None
             self._flask_app = None

# W klasie GameLauncher

    def _start_flask_server(self):
        """Tworzy i uruchamia serwer Flask w osobnym wątku."""
        if self._server_running or self._flask_thread is not None:
            logging.warning("Próba uruchomienia serwera Flask, gdy już działa.")
            return

        port_to_use = self.remote_server_port
        ip_address = self._get_local_ip()
        if not ip_address:
            messagebox.showerror("Błąd Sieci", "Nie można było ustalić lokalnego adresu IP.", parent=self.root)
            self._update_server_status_ui(False)
            return

        self._server_running = True
        self._flask_app = Flask(__name__)
        flask_log = logging.getLogger('werkzeug')
        flask_log.setLevel(logging.ERROR)


        # --- Definicja endpointów Flask ---

        # 1. Główna strona HTML (serwowana przez /)
        @self._flask_app.route('/')
        def index():
            if not self._server_running: return "Serwer został zatrzymany.", 503

            # Zaawansowany HTML z CSS i JavaScript (z dodanym filtrowaniem)
            html_content = """
            <!DOCTYPE html>
            <html lang="pl">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
                <title>Game Launcher Remote</title>
                <style>
                    :root {
                        --bg-color: #1e1e1e;
                        --text-color: #dddddd;
                        --text-muted-color: #888888;
                        --border-color: #333333;
                        --input-bg-color: #2e2e2e;
                        --link-color: #aabbff;
                        --link-visited-color: #99aaff;
                        --accent-green: #aaffaa;
                        --accent-red: #ffaaaa;
                        --cover-size: 60px;
                    }
                    body {
                        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                        background-color: var(--bg-color);
                        color: var(--text-color);
                        margin: 0;
                        padding: 10px;
                    }
                    .container { max-width: 800px; margin: 10px auto; }
                    h1 { text-align: center; color: #cccccc; margin-bottom: 15px; font-size: 1.5em; }
                    #status-bar {
                        text-align: center; padding: 8px; margin-bottom: 15px;
                        background-color: #2a2a2a; border-radius: 4px; font-size: 0.9em; min-height: 1.2em;
                    }
                    /* --- NOWE STYLE: Pole wyszukiwania --- */
                    #search-container { margin-bottom: 15px; }
                    #search-input {
                        width: calc(100% - 22px); /* Pełna szerokość minus padding */
                        padding: 10px;
                        background-color: var(--input-bg-color);
                        color: var(--text-color);
                        border: 1px solid var(--border-color);
                        border-radius: 4px;
                        font-size: 1em;
                    }
                    /* --- KONIEC NOWYCH STYLI --- */
                    #game-list-container { margin-top: 15px; }
                    ul#game-list { list-style: none; padding: 0; }
                    li.game-item {
                        margin: 5px 0; border-bottom: 1px solid var(--border-color); padding: 8px 5px;
                        display: flex; /* Zmieniono z none */
                        align-items: center; gap: 10px;
                    }
                    /* --- NOWE: Klasa do ukrywania --- */
                    li.game-item.hidden { display: none; }
                    /* --- KONIEC NOWEGO --- */
                    .game-cover img {
                        width: var(--cover-size); height: auto; max-height: calc(var(--cover-size) * 1.5);
                        object-fit: cover; vertical-align: middle; background-color: #333;
                    }
                    .game-info { flex-grow: 1; }
                    .game-name { font-size: 1.1em; display: block; margin-bottom: 3px; }
                    .game-playtime { font-size: 0.8em; color: var(--text-muted-color); display: block;}
                    .game-actions a {
                        font-weight: bold; text-decoration: none; padding: 5px 8px; margin-left: 5px;
                        border-radius: 3px; font-size: 0.9em; white-space: nowrap;
                    }
                    .launch-link { color: var(--accent-green); background-color: #3a4a3a; }
                    .close-link { color: var(--accent-red); background-color: #4a3a3a; }
                    a:visited { color: var(--link-visited-color); }
                    a { transition: opacity 0.2s ease; }
                    a:hover { opacity: 0.7; }
                </style>
            </head>
            <body>
                <div class="container">
                    <h1>Game Launcher</h1>
                    <div id="status-bar">Ładowanie statusu...</div>

                    <!-- NOWE: Pole wyszukiwania -->
                    <div id="search-container">
                        <input type="text" id="search-input" placeholder="Filtruj gry...">
                    </div>
                    <!-- KONIEC NOWEGO -->

                    <div id="game-list-container">
                        <ul id="game-list">
                            <li>Ładowanie listy gier...</li>
                        </ul>
                    </div>
                </div>

                <script>
                    const statusBar = document.getElementById('status-bar');
                    const gameListUl = document.getElementById('game-list');
                    const searchInput = document.getElementById('search-input'); // Nowy element
                    let currentRunningGame = null;
                    let allGameItems = []; // Przechowa wszystkie elementy LI

                    // --- Funkcja do pobierania i aktualizacji statusu (bez zmian) ---
                    async function updateStatus() { /* ... kod updateStatus ... */
                        try {
                            const response = await fetch('/api/status');
                            if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }
                            const data = await response.json();
                            currentRunningGame = data.running_game;
                            if (currentRunningGame) {
                                statusBar.textContent = `Uruchomiona Gra: ${currentRunningGame}`;
                                statusBar.style.color = 'var(--accent-green)';
                            } else {
                                statusBar.textContent = 'Brak uruchomionej gry';
                                statusBar.style.color = 'var(--text-muted-color)';
                            }
                            updateCloseButtonsVisibility();
                        } catch (error) {
                            console.error('Błąd pobierania statusu:', error);
                            statusBar.textContent = 'Błąd pobierania statusu';
                            statusBar.style.color = 'var(--accent-red)';
                            currentRunningGame = null;
                            updateCloseButtonsVisibility();
                        }
                    }

                    // --- Funkcja do pobierania i wyświetlania listy gier (modyfikacja) ---
                    async function loadGames() {
                        try {
                            const response = await fetch('/api/games');
                            if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }
                            const games = await response.json();

                            gameListUl.innerHTML = ''; // Wyczyść listę
                            allGameItems = []; // Wyczyść cache elementów

                            if (games.length === 0) {
                                gameListUl.innerHTML = '<li>Brak gier w bibliotece.</li>';
                                return;
                            }

                            games.forEach(game => {
                                const li = document.createElement('li');
                                li.classList.add('game-item');
                                li.dataset.gameName = game.name; // Zapisz nazwę gry

                                const coverDiv = document.createElement('div');
                                coverDiv.classList.add('game-cover');
                                const img = document.createElement('img');
                                img.src = game.cover_url;
                                img.alt = `Okładka ${game.name}`;
                                img.onerror = function() { this.style.display='none'; }
                                coverDiv.appendChild(img);

                                const infoDiv = document.createElement('div');
                                infoDiv.classList.add('game-info');
                                const nameSpan = document.createElement('span');
                                nameSpan.classList.add('game-name');
                                nameSpan.textContent = game.name;
                                const timeSpan = document.createElement('span');
                                timeSpan.classList.add('game-playtime');
                                timeSpan.textContent = `Czas gry: ${game.playtime}`;
                                infoDiv.appendChild(nameSpan);
                                infoDiv.appendChild(timeSpan);

                                const actionsDiv = document.createElement('div');
                                actionsDiv.classList.add('game-actions');
                                const launchLink = document.createElement('a');
                                launchLink.href = `/launch/${encodeURIComponent(game.name)}`;
                                launchLink.textContent = '▶ Uruchom';
                                launchLink.classList.add('launch-link');
                                const closeLink = document.createElement('a');
                                closeLink.href = `/close/${encodeURIComponent(game.name)}`;
                                closeLink.textContent = '■ Zamknij';
                                closeLink.classList.add('close-link');
                                closeLink.style.display = 'none';

                                actionsDiv.appendChild(launchLink);
                                actionsDiv.appendChild(closeLink);

                                li.appendChild(coverDiv);
                                li.appendChild(infoDiv);
                                li.appendChild(actionsDiv);
                                gameListUl.appendChild(li);
                                allGameItems.push(li); // Dodaj do cache'u elementów
                            });

                            updateStatus(); // Zaktualizuj status i przyciski Zamknij
                        } catch (error) {
                            console.error('Błąd pobierania listy gier:', error);
                            gameListUl.innerHTML = '<li>Błąd ładowania listy gier.</li>';
                        }
                    }

                    // --- Funkcja aktualizująca widoczność przycisków "Zamknij" (bez zmian) ---
                    function updateCloseButtonsVisibility() { /* ... kod updateCloseButtonsVisibility ... */
                        allGameItems.forEach(item => { // Użyj allGameItems
                            const closeButton = item.querySelector('.close-link');
                            if (closeButton) {
                                if (item.dataset.gameName === currentRunningGame) {
                                    closeButton.style.display = 'inline-block';
                                } else {
                                    closeButton.style.display = 'none';
                                }
                            }
                        });
                     }

                    // --- NOWA FUNKCJA: Filtrowanie listy gier ---
                    function filterGames() {
                        const searchTerm = searchInput.value.toLowerCase();
                        allGameItems.forEach(item => {
                            const gameName = item.dataset.gameName.toLowerCase();
                            if (gameName.includes(searchTerm)) {
                                item.classList.remove('hidden'); // Pokaż element
                            } else {
                                item.classList.add('hidden'); // Ukryj element
                            }
                        });
                    }
                    // --- KONIEC NOWEJ FUNKCJI ---

                    // --- Inicjalizacja ---
                    loadGames(); // Załaduj gry przy starcie
                    setInterval(updateStatus, 5000); // Aktualizuj status co 5 sekund
                    // --- NOWE: Dodaj nasłuchiwanie na zmiany w polu wyszukiwania ---
                    searchInput.addEventListener('input', filterGames);
                    // --- KONIEC NOWEGO ---
                </script>
            </body>
            </html>
            """
            return render_template_string(html_content)

        # 2. API Endpoint: Zwraca listę gier (bez zmian)
        @self._flask_app.route('/api/games')
        def api_games():
            # ... (kod api_games bez zmian) ...
             if not self._server_running: return jsonify({"error": "Server stopped"}), 503
             try:
                 game_list = []
                 sorted_game_names = sorted(list(self.games.keys()), key=str.lower)
                 for game_name in sorted_game_names:
                     game_data = self.games.get(game_name, {})
                     encoded_name = urllib.parse.quote(game_name.encode('utf-8'))
                     game_list.append({
                         "name": game_name,
                         "playtime": self.format_play_time(game_data.get("play_time", 0)),
                         "cover_url": f"/cover/{encoded_name}"
                     })
                 return jsonify(game_list)
             except Exception as e:
                  logging.exception("Błąd w endpoint /api/games")
                  return jsonify({"error": "Internal server error"}), 500


        # 3. API Endpoint: Zwraca status (bez zmian)
        @self._flask_app.route('/api/status')
        def api_status():
            # ... (kod api_status bez zmian) ...
            if not self._server_running: return jsonify({"error": "Server stopped"}), 503
            try:
                running_game = None
                if self.tracking_games:
                    running_game = next(iter(self.tracking_games))
                return jsonify({"running_game": running_game})
            except Exception as e:
                 logging.exception("Błąd w endpoint /api/status")
                 return jsonify({"error": "Internal server error"}), 500

        # 4. Endpoint do serwowania okładek (bez zmian)
        @self._flask_app.route('/cover/<encoded_game_name>')
        def serve_cover(encoded_game_name):
            # ... (kod serve_cover bez zmian) ...
            if not self._server_running: return "...", 503
            try:
                game_name = urllib.parse.unquote(encoded_game_name)
                game_data = self.games.get(game_name)
                if not game_data: abort(404)
                cover_rel_path = game_data.get("cover_image")
                if not cover_rel_path: abort(404)
                images_folder_abs = os.path.abspath(IMAGES_FOLDER)
                cover_abs_path = os.path.abspath(os.path.join(os.getcwd(), cover_rel_path))
                if os.path.commonpath([images_folder_abs, cover_abs_path]) == images_folder_abs and os.path.exists(cover_abs_path):
                    return send_file(cover_abs_path)
                else: abort(404)
            except Exception as e: abort(500)

        # 5. Endpoint do uruchamiania gry (bez zmian)
        @self._flask_app.route('/launch/<game_name>')
        def launch(game_name):
            # ... (kod launch bez zmian) ...
             if not self._server_running: return "...", 503
             decoded_game_name = urllib.parse.unquote(game_name)
             if decoded_game_name in self.games:
                 self.root.after(0, lambda gn=decoded_game_name: self.launch_game(gn))
                 return redirect(url_for('index'))
             else: return f"...", 404

        # 6. Endpoint do zamykania gry (bez zmian)
        @self._flask_app.route('/close/<game_name>')
        def close(game_name):
            # ... (kod close bez zmian) ...
             if not self._server_running: return "...", 503
             decoded_game_name = urllib.parse.unquote(game_name)
             if decoded_game_name in self.games:
                  self.root.after(0, lambda gn=decoded_game_name: self.close_game(gn))
                  return redirect(url_for('index'))
             else: return f"...", 404

        # --- Uruchomienie wątku serwera ---
        self._flask_thread = threading.Thread(
            target=self._flask_server_target,
            args=(port_to_use,),
            daemon=True
        )
        self._flask_thread.start()

        # Aktualizuj UI w głównym wątku
        self.root.after(100, lambda: self._update_server_status_ui(True, ip_address))

    def _stop_flask_server(self):
        """Zatrzymuje serwer Flask (na razie przez ustawienie flagi)."""
        if not self._server_running:
            logging.info("Serwer Flask nie jest uruchomiony.")
            return

        logging.info("Zatrzymywanie serwera Flask (ustawianie flagi)...")
        self._server_running = False # Ustaw flagę, aby nowe żądania były odrzucane

        # TODO: Implementacja czystego zatrzymania wątku serwera jest trudna
        # dla wbudowanego serwera Flask. Na razie polegamy na tym, że wątek
        # jest daemonem i zakończy się razem z aplikacją, a flaga
        # _server_running zapobiegnie obsłudze nowych żądań.
        # W przyszłości można użyć np. biblioteki 'waitress' lub innego mechanizmu.
        self._flask_thread = None # Usuń referencję do wątku (choć może jeszcze działać)
        self._flask_app = None    # Usuń referencję do aplikacji

        # Aktualizuj UI w głównym wątku
        self._update_server_status_ui(False)

    # W _update_server_status_ui używaj self.remote_server_port
    def _update_server_status_ui(self, is_running, ip_address=None):
        """Aktualizuje etykietę URL i stan Checkbuttona w UI."""
        if hasattr(self, 'remote_url_label') and self.remote_url_label.winfo_exists():
            if is_running and ip_address:
                # --- ZMIANA: Użyj self.remote_server_port ---
                url = f"http://{ip_address}:{self.remote_server_port}"
                # --- KONIEC ZMIANY ---
                self.remote_url_label.config(text=url, foreground="lightgreen")
            else:
                self.remote_url_label.config(text="Serwer wyłączony", foreground="gray")

        # Upewnij się, że stan Checkbuttona odpowiada stanowi serwera
        if hasattr(self, 'remote_server_enabled_var'):
             # Sprawdź, czy stan zmiennej różni się od stanu faktycznego
             if self.remote_server_enabled_var.get() != is_running:
                 self.remote_server_enabled_var.set(is_running)
                 # Zapisz zmianę w ustawieniach (bo stan mógł się zmienić np. przez błąd)
                 self.local_settings["remote_control_enabled"] = is_running
                 save_local_settings(self.local_settings)

    def _toggle_remote_server(self):
        """Włącza lub wyłącza serwer zdalny na podstawie Checkbuttona."""
        should_be_enabled = self.remote_server_enabled_var.get()

        # Zapisz zmianę w ustawieniach lokalnych
        if self.local_settings.get("remote_control_enabled") != should_be_enabled:
            self.local_settings["remote_control_enabled"] = should_be_enabled
            save_local_settings(self.local_settings)
            logging.info(f"Zmieniono ustawienie zdalnego sterowania na: {should_be_enabled}")

        if should_be_enabled:
            logging.info("Użytkownik włączył zdalne sterowanie. Uruchamianie serwera...")
            self._start_flask_server()
        else:
            logging.info("Użytkownik wyłączył zdalne sterowanie. Zatrzymywanie serwera...")
            self._stop_flask_server()

    # --- Koniec NOWYCH METOD ---


    def add_autoscan_folder(self):
        """Otwiera dialog wyboru folderu i dodaje go do listy skanowania screenshotów."""
        folder_selected = filedialog.askdirectory(title="Wybierz folder do skanowania screenshotów", parent=self.settings_page_frame) # Ustaw parent
        if folder_selected:
            scan_folders = self.settings.setdefault("autoscan_screenshot_folders", [])
            if folder_selected not in scan_folders:
                scan_folders.append(folder_selected)
                # Nie trzeba zapisywać self.settings["..."] bo setdefault modyfikuje oryginał
                save_config(self.config)
                self.load_autoscan_folders_list() # Odśwież listbox
                logging.info(f"Dodano folder do skanowania screenshotów: {folder_selected}")
            else:
                messagebox.showwarning("Informacja", "Ten folder jest już na liście.", parent=self.settings_page_frame)

    def remove_autoscan_folder(self):
        """Usuwa zaznaczony folder z listy skanowania screenshotów."""
        selected_indices = self.autoscan_folders_listbox.curselection()
        if selected_indices:
            index = selected_indices[0]
            folder_to_remove = self.autoscan_folders_listbox.get(index)
            scan_folders = self.settings.get("autoscan_screenshot_folders", [])
            if folder_to_remove in scan_folders:
                scan_folders.remove(folder_to_remove)
                save_config(self.config)
                self.load_autoscan_folders_list() # Odśwież listbox
                logging.info(f"Usunięto folder ze skanowania screenshotów: {folder_to_remove}")
        else:
            messagebox.showwarning("Błąd", "Nie wybrano folderu do usunięcia.", parent=self.settings_page_frame)

    def _save_autoscan_startup_setting(self):
        """Zapisuje ustawienie automatycznego skanowania screenshotów przy starcie."""
        self.settings["autoscan_on_startup"] = self.autoscan_on_startup_var.get()
        save_config(self.config)
        logging.info(f"Ustawienie autoscan_on_startup zmienione na: {self.autoscan_on_startup_var.get()}")


    def _perform_file_operation_thread(self, operation_type, src, dst, total_files, callback_on_success=None):
        """Wykonuje kopiowanie lub usuwanie plików w osobnym wątku."""
        processed_files = 0
        last_update_time = time.time()
        operation_completed_successfully = False # Zmieniono nazwę dla jasności i zainicjalizowano na False

        try:
            if operation_type == 'copy':
                os.makedirs(dst, exist_ok=True)
                for root_dir, dirs, files_in_dir_loop in os.walk(src):
                    relative_path_loop = os.path.relpath(root_dir, src)
                    dest_root_loop = os.path.join(dst, relative_path_loop)
                    os.makedirs(dest_root_loop, exist_ok=True)

                    for file_item_loop in files_in_dir_loop:
                        source_file_loop = os.path.join(root_dir, file_item_loop)
                        dest_file_loop = os.path.join(dest_root_loop, file_item_loop)
                        try:
                            shutil.copy2(source_file_loop, dest_file_loop)
                            processed_files += 1
                            now = time.time()
                            if now - last_update_time > 0.1 or processed_files == total_files:
                                percent = int((processed_files / total_files) * 100) if total_files > 0 else 100
                                progress_text = f"{processed_files} / {total_files}"
                                if hasattr(self, '_update_copy_progress_ui'):
                                    self.root.after(0, self._update_copy_progress_ui, percent, progress_text)
                                last_update_time = now
                        except Exception as copy_e:
                            logging.error(f"Błąd kopiowania {source_file_loop}: {copy_e}")
                            # Jeśli wystąpił błąd kopiowania pojedynczego pliku, cała operacja może nie być "sukcesem"
                            # Można tu rzucić wyjątek dalej lub ustawić operation_completed_successfully na False i przerwać
                            raise copy_e # Rzuć błąd dalej, aby został obsłużony przez główny except
                operation_completed_successfully = True # Ustaw na True dopiero po pomyślnym zakończeniu pętli

            elif operation_type == 'delete':
                if hasattr(self, 'progress_window') and self.progress_window.winfo_exists():
                    if hasattr(self, '_update_copy_progress_ui'):
                        self.root.after(0, self._update_copy_progress_ui, 50, "Usuwanie...")
                shutil.rmtree(src)
                processed_files = total_files 
                if hasattr(self, 'progress_window') and self.progress_window.winfo_exists():
                    if hasattr(self, '_update_copy_progress_ui'):
                        self.root.after(0, self._update_copy_progress_ui, 100, "Zakończono")
                operation_completed_successfully = True # Ustaw na True po pomyślnym usunięciu

            logging.info(f"Operacja '{operation_type}' zakończona. Przetworzono ~{processed_files} plików.")
            
            # Wywołaj callback tylko jeśli operacja zakończyła się sukcesem
            if operation_completed_successfully and callback_on_success:
                self.root.after(0, callback_on_success)

        except Exception as thread_e: 
            operation_completed_successfully = False # Błąd wystąpił, więc operacja nie zakończyła się sukcesem
            logging.exception(f"Błąd w wątku operacji '{operation_type}' dla '{src}': {thread_e}")
            # Informacja o błędzie zostanie pokazana w bloku finally
        finally:
            if hasattr(self, 'progress_window') and self.progress_window.winfo_exists():
                self.root.after(150, self._destroy_progress_window) 

            # Informuj użytkownika o wyniku operacji - pokaż błąd tylko jeśli wystąpił
            if not operation_completed_successfully: # Sprawdź zaktualizowaną flagę
                error_msg_final = f"Wystąpił błąd podczas operacji '{operation_type}'."
                # Próbujemy uzyskać bardziej szczegółowy komunikat, jeśli wyjątek został złapany
                # Jednakże, zmienna 'thread_e' z bloku 'except Exception as thread_e:'
                # nie jest bezpośrednio dostępna w 'finally', chyba że ją gdzieś zapiszemy.
                # Dla uproszczenia, jeśli 'operation_completed_successfully' jest False,
                # możemy założyć, że błąd został już zalogowany z logging.exception.
                
                parent_for_error = self.root 
                active_toplevels = [win for win in self.root.winfo_children() if isinstance(win, tk.Toplevel) and win.winfo_exists()]
                for tl in active_toplevels:
                    if hasattr(tl, 'game_name') and hasattr(tl, 'save_path'): 
                        parent_for_error = tl
                        break
                # Użyj bardziej ogólnego komunikatu, bo szczegóły błędu są już w logach
                self.root.after(200, lambda em_op=operation_type, pf=parent_for_error: messagebox.showerror(f"Błąd {em_op.capitalize()}", f"Wystąpił błąd podczas operacji {em_op}. Szczegóły w logach.", parent=pf))

    def add_to_roadmap(self):
        """Dodaje nową grę do Roadmapy."""
        game_name = self.roadmap_game_name.get()
        start_date_str = self.roadmap_start_cal.get_date().strftime('%Y-%m-%d')
        end_date_str = self.roadmap_end_cal.get_date().strftime('%Y-%m-%d')

        if game_name == "Wybierz grę" or not start_date_str or not end_date_str:
            messagebox.showwarning("Błąd", "Wszystkie pola są wymagane.")
            return

        # Sprawdź, czy gra już jest w Roadmapie
        for game in self.roadmap:
            if game["game_name"].lower() == game_name.lower():
                messagebox.showwarning("Błąd", "Ta gra już znajduje się w Roadmapie.")
                return

        # Walidacja dat
        try:
            start_date = datetime.datetime.strptime(start_date_str, '%Y-%m-%d').date()
            end_date = datetime.datetime.strptime(end_date_str, '%Y-%m-%d').date()
            if end_date < start_date:
                raise ValueError("Data zakończenia musi być późniejsza niż data rozpoczęcia.")
        except ValueError as ve:
            messagebox.showerror("Błąd", f"Nieprawidłowy format daty lub logika dat:\n{ve}")
            return

        # Dodaj grę do Roadmapy
        new_game = {
            "game_name": game_name,
            "start_date": start_date_str,
            "end_date": end_date_str,
            "time_spent": 0,
            "status": "Planowana"
        }
        self.roadmap.append(new_game)
        save_config(self.config)

        # Odśwież Roadmapę i kalendarz
        self.load_roadmap()
        self.update_calendar()

        # Wyczyść pola wejściowe
        self.roadmap_game_name.set("Wybierz grę")
        self.roadmap_start_cal.set_date(datetime.date.today())
        self.roadmap_end_cal.set_date(datetime.date.today())

    def _check_game_against_rules(self, game_data, rules):
        """Sprawdza, czy dane gry spełniają podaną listę reguł filtra (logika AND)."""
        if not rules:
            return True # Gra pasuje, jeśli filtr nie ma reguł

        # Definicja operatorów (można przenieść jako atrybut klasy dla wydajności)
        ops = {
            "text": {
                "zawiera": lambda val, field: str(val).lower() in str(field).lower(),
                "nie zawiera": lambda val, field: str(val).lower() not in str(field).lower(),
                "równa się": lambda val, field: str(field).lower() == str(val).lower(),
                "zaczyna się od": lambda val, field: str(field).lower().startswith(str(val).lower()),
                "kończy się na": lambda val, field: str(field).lower().endswith(str(val).lower()),
                "jest ustawione": lambda val, field: bool(field), # Czy nie None i nie pusty string/lista
                "nie jest ustawione": lambda val, field: not field,
            },
            "list": { # Dla Gatunków i Tagów
                "zawiera": lambda val, field: str(val) in field if isinstance(field, list) else False,
                "nie zawiera": lambda val, field: str(val) not in field if isinstance(field, list) else True,
                "jest ustawione": lambda val, field: bool(field), # Czy lista istnieje i nie jest pusta
                "nie jest ustawione": lambda val, field: not field,
            },
             "number": {
                "==": lambda val, field: float(field) == float(val) if field is not None else False,
                "!=": lambda val, field: float(field) != float(val) if field is not None else True,
                ">": lambda val, field: float(field) > float(val) if field is not None else False,
                "<": lambda val, field: float(field) < float(val) if field is not None else False,
                ">=": lambda val, field: float(field) >= float(val) if field is not None else False,
                "<=": lambda val, field: float(field) <= float(val) if field is not None else False,
                "jest ustawione": lambda val, field: field is not None, # Sprawdź tylko None dla liczb
                "nie jest ustawione": lambda val, field: field is None,
             },
            "date": { # Porównujemy daty jako stringi YYYY-MM-DD lub timestampy
                "jest równe": lambda val, field: str(field) == str(val) if field else False,
                "jest przed": lambda val, field: str(field) < str(val) if field and val else False,
                "jest po": lambda val, field: str(field) > str(val) if field and val else False,
                "jest ustawione": lambda val, field: bool(field), # Czy timestamp istnieje
                "nie jest ustawione": lambda val, field: not field,
             },
            "choice": { # Dla Typu Gry, Emulatora
                "jest": lambda val, field: str(field) == str(val),
                "nie jest": lambda val, field: str(field) != str(val),
                "jest ustawione": lambda val, field: bool(field),
                "nie jest ustawione": lambda val, field: not field,
            }
        }


        for rule in rules:
            field_key = rule.get("field")
            operator_key = rule.get("operator")
            rule_value = rule.get("value") # Wartość zdefiniowana w filtrze

            if not field_key or not operator_key:
                logging.warning(f"Pominięto niekompletną regułę: {rule}")
                continue

            # --- Pobierz i przygotuj wartość pola z danych gry ---
            field_value = game_data.get(field_key)
            field_type = None
            # Znajdź typ pola na podstawie klucza
            for name, data in self.FIELDS.items(): # Zakładając, że self.FIELDS istnieje w GameLauncher
                if data["db_field"] == field_key:
                    field_type = data["type"]
                    break

            if field_type is None: # Jeśli nie znaleziono typu (np. dla starych danych)
                # Spróbuj odgadnąć typ na podstawie wartości
                if isinstance(field_value, list): field_type = "list"
                elif isinstance(field_value, (int, float)): field_type = "number"
                # Prosta heurystyka dla daty w stringu
                elif isinstance(field_value, str) and re.match(r'^\d{4}-\d{2}-\d{2}$', field_value): field_type = "date"
                else: field_type = "text" # Domyślnie tekst
                logging.debug(f"Nie znaleziono typu dla pola '{field_key}', zgadnięto: {field_type}")

            # Konwersje specyficzne dla pola
            if field_key == "play_time":
                 field_value = round(game_data.get('play_time', 0) / 3600, 2)
                 field_type = "number" # Nadpisz typ dla czasu gry
            elif field_key in ["date_added", "last_played"]:
                 timestamp = game_data.get(field_key)
                 field_value = datetime.datetime.fromtimestamp(timestamp).strftime('%Y-%m-%d') if timestamp else None
                 field_type = "date" # Nadpisz typ
            elif field_key == "game_type":
                 field_value = game_data.get("game_type", "pc") # Ustaw domyślny
                 field_type = "choice"
            elif field_key == "emulator_name":
                 field_value = game_data.get("emulator_name")
                 field_type = "choice"
            # --- Koniec przygotowania wartości pola ---


            # Pobierz odpowiedni zestaw operatorów dla typu pola
            operator_set = ops.get(field_type)
            if not operator_set:
                logging.warning(f"Brak zdefiniowanych operatorów dla typu pola '{field_type}' (pole: {field_key})")
                return False # Nie można zastosować reguły

            # Specjalna obsługa dla list (używamy kluczy zdefiniowanych wyżej)
            if field_type == "list":
                if operator_key == "zawiera": op_func = operator_set.get("zawiera (lista)")
                elif operator_key == "nie zawiera": op_func = operator_set.get("nie zawiera (lista)")
                else: op_func = operator_set.get(operator_key) # Dla "jest/nie jest ustawione"
            else:
                op_func = operator_set.get(operator_key)


            if not op_func:
                logging.warning(f"Nieznany lub nieobsługiwany operator '{operator_key}' dla typu '{field_type}' w regule: {rule}")
                return False

            try:
                # Sprawdź warunek
                rule_met = False
                if operator_key in ["jest ustawione", "nie jest ustawione"]:
                     rule_met = op_func(None, field_value) # Przekaż None jako wartość reguły
                elif field_value is not None or field_type == 'text': # Dla tekstu porównujemy nawet jeśli pusty
                     # Konwertuj wartość z reguły na typ liczbowy, jeśli trzeba
                     compare_value = rule_value
                     if field_type == "number":
                          try: compare_value = float(rule_value)
                          except (ValueError, TypeError) as conv_err: raise ValueError(f"Wartość reguły '{rule_value}' nie jest poprawną liczbą: {conv_err}")

                     rule_met = op_func(compare_value, field_value)
                else: # Wartość pola to None, a operator wymaga wartości (np. >, <, ==)
                     rule_met = False # Traktuj jako niespełnioną

                if not rule_met:
                    logging.debug(f"Gra '{game_data.get('name')}' nie spełnia reguły: {rule} (wartość pola: {field_value})")
                    return False # Gra nie pasuje do filtra
            except ValueError as ve: # Błąd konwersji wartości reguły
                 logging.error(f"Błąd wartości w regule {rule} dla gry {game_data.get('name')}: {ve}")
                 return False
            except Exception as e:
                logging.exception(f"Błąd podczas stosowania reguły {rule} do gry {game_data.get('name')}: {e}")
                return False

        # Jeśli wszystkie reguły zostały spełnione
        logging.debug(f"Gra '{game_data.get('name')}' spełnia wszystkie reguły filtra.")
        return True


    def mark_as_completed(self):
        """Oznacza wybraną grę jako ukończoną i przenosi ją do archiwum."""
        selected_item = self.roadmap_tree.selection()
        if not selected_item:
            messagebox.showwarning("Błąd", "Nie wybrano żadnej gry.")
            return

        values = self.roadmap_tree.item(selected_item, "values")
        game_name = values[0]

        # Znajdź grę w Roadmapie
        for game in self.roadmap:
            if game["game_name"] == game_name:
                # Aktualizuj status i dodaj datę ukończenia
                game["status"] = "Ukończona"
                game["completion_date"] = datetime.date.today().strftime('%Y-%m-%d')
                # Przenieś grę do archiwum
                self.archive.append(game.copy())
                # Usuń grę z Roadmapy
                self.roadmap.remove(game)
                break

        # Zapisz zmiany
        self.config['roadmap'] = self.roadmap
        self.config['archive'] = self.archive
        save_config(self.config)
        # --- NOWE: Sprawdź osiągnięcia ---
        self.check_and_unlock_achievements()
        # --- KONIEC NOWEGO ---
        # Odśwież interfejsy
        self.load_roadmap()
        self.update_calendar()
        self.load_archive()
        self.update_archive_calendar()  # Dodaj tę linię, aby zaktualizować kalendarz archiwum

        messagebox.showinfo("Sukces", f"Gra '{game_name}' została oznaczona jako ukończona i przeniesiona do archiwum.")

    def _ensure_cover(self, game_name: str, game_data: dict, size: tuple):
        """
        Gwarantuje, że gra ma fizyczny plik okładki.
        Jeśli go nie ma – tworzy domyślną, zapisuje w configu i zwraca ścieżkę.
        """
        cover_path = game_data.get("cover_image") or ""
        if not os.path.isfile(cover_path):
            cover_path = create_default_cover(game_name, size=size)
            game_data["cover_image"] = cover_path
            game_data["_auto_cover"] = True     # zapisz w pamięci
            save_config(self.config)                  # zapisz na dysku
            load_photoimage_from_path.cache_clear()   # odśwież mini‑cache
            logging.info(f"Utworzono domyślną okładkę dla '{game_name}': {cover_path}")
        return cover_path


    def delete_from_roadmap(self):
        """Deletes the selected game from the roadmap."""
        selected_item = self.roadmap_tree.selection()
        if not selected_item:
            messagebox.showwarning("Błąd", "Nie wybrano żadnej gry.")
            return

        values = self.roadmap_tree.item(selected_item, "values")
        game_name = values[0]

        if messagebox.askyesno("Potwierdzenie", f"Czy na pewno chcesz usunąć grę '{game_name}' z Roadmapy?"):
            # Remove the game from the roadmap
            self.roadmap = [g for g in self.roadmap if g["game_name"] != game_name]

            # Save changes to the configuration file
            self.config['roadmap'] = self.roadmap
            save_config(self.config)

            # Refresh the roadmap and calendar
            self.load_roadmap()
            self.update_calendar()

            messagebox.showinfo("Sukces", f"Gra '{game_name}' została usunięta z Roadmapy.")




    def monitor_roadmap(self):
        """Monitoruje roadmapę i aktualizuje statusy gier."""
        while True:
            current_date = time.strftime('%Y-%m-%d')
            updated = False
            for game in self.roadmap:
                if game["status"] == "Planowana" and game["end_date"] < current_date:
                    game["status"] = "Nie ukończona na czas"
                    updated = True
            if updated:
                save_config(self.config)
                self.load_roadmap()
                self.update_calendar()
            time.sleep(86400)  # Sprawdzaj raz na dobę



    # W klasie GameLauncher:

    def show_roadmap(self):
        """Pokazuje kartę Roadmapy, tworząc UI tylko raz."""
        # Utwórz UI tylko jeśli ramka nie istnieje
        if not hasattr(self, 'roadmap_frame') or not self.roadmap_frame.winfo_exists():
            self.create_roadmap_page() # Stworzy UI i zaplanuje ładowanie danych
        # Zawsze podnoś ramkę do góry
        # --- NOWE ZMIANY ---
        self.roadmap_frame.grid() # Upewnij się, że ramka Roadmapy jest w gridzie
        # --- KONIEC NOWYCH ZMIAN ---
        self.roadmap_frame.tkraise()
        self.current_frame = self.roadmap_frame
        # --- ZMIANA ---
        self.current_section = "Sprawdza Roadmapę"
        self._update_discord_status(status_type="browsing", activity_details=self.current_section)
        # --- KONIEC ZMIANY ---




    def perform_update_check(self):
        """Wykonuje sprawdzanie aktualizacji i promuje je w GUI."""
        update_info = self.check_for_updates()
        if update_info.get("available"):
            self.root.after(0, lambda: self.prompt_update(update_info))
    


    def check_for_updates(self):
        try:
            current_version = PROGRAM_VERSION
            logging.info(f"Obecna wersja: {current_version}")

            # Poprawny adres API z małą literą w "releases"
            GITHUB_API_URL = "https://api.github.com/repos/snakex21/Game-Launcher/releases"
            response = requests.get(GITHUB_API_URL, timeout=10)
            response.raise_for_status()
            releases = response.json()
            logging.info(f"Pobrano {len(releases)} wydań")

            newer_versions = []
            for release in releases:
                release_version = release['tag_name'].lstrip('v')
                logging.info(f"Analizuję wydanie: {release_version}")
                try:
                    if version.parse(release_version) > version.parse(current_version):
                        if not release.get('assets'):
                            logging.warning(f"Wydanie {release_version} nie ma assetów")
                            continue
                        newer_versions.append({
                            "version": release_version,
                            "download_url": release['assets'][0]['browser_download_url'],
                            "release": release
                        })
                except version.InvalidVersion:
                    logging.warning(f"Nieprawidłowy format wersji: {release_version}")

            if not newer_versions:
                logging.info("Brak dostępnych aktualizacji")
                return {"available": False}

            newer_versions.sort(key=lambda x: version.parse(x['version']))
            next_update = newer_versions[0]
            logging.info(f"Znaleziono aktualizację: {next_update['version']}")
            return {
                "available": True,
                "latest_version": next_update['version'],
                "download_url": next_update['download_url']
            }
        except requests.RequestException as e:
            logging.error(f"Błąd sieciowy: {e}")
            return {"available": False}
        except Exception as e:
            logging.error(f"Nieoczekiwany błąd: {e}")
            return {"available": False}

    def _ensure_mod_manager(self):
        """Tworzy instancję ExtendedModManager, jeśli jeszcze nie istnieje."""
        if self.extended_mod_manager is None:
            logging.info("Leniwa inicjalizacja ExtendedModManager...")
            self.extended_mod_manager = ExtendedModManager(self, self.root)
            # Opcjonalnie: Upewnij się, że ramka jest pod spodem na początku
            self.extended_mod_manager.frame.lower()
        # Jeśli już istnieje, nic nie rób

    def _load_achievement_def_list(self):
        """Wczytuje definicje osiągnięć do Treeview w Ustawieniach."""
        if not hasattr(self, 'achievements_def_tree') or not self.achievements_def_tree.winfo_exists(): return
        for item in self.achievements_def_tree.get_children(): self.achievements_def_tree.delete(item)
        if not hasattr(self, 'achievement_definitions') or not self.achievement_definitions: self._load_achievement_definitions()

        # Upewnij się, że mapowanie istnieje
        if not hasattr(self, 'ACHIEVEMENT_RULE_TYPES_TRANSLATED'):
             self.ACHIEVEMENT_RULE_TYPES_TRANSLATED = { # Fallback, gdyby __init__ nie zdążył
                 "games_launched_count": "Liczba uruchomionych gier", "library_size": "Rozmiar biblioteki",
                 "total_playtime_hours": "Łączny czas gry (godziny)", "games_completed_100": "Gry ukończone w 100%"
             }

        for ach_def in self.achievement_definitions:
            ach_id = ach_def.get("id", "-")
            name = ach_def.get("name", "Brak Nazwy")
            desc = ach_def.get("description", "")
            rule_type = ach_def.get("rule_type", "N/A")
            target = ach_def.get("target_value", "-")
            # --- ZMIANA: Pokaż przetłumaczoną nazwę reguły ---
            condition_str = f"{self.ACHIEVEMENT_RULE_TYPES_TRANSLATED.get(rule_type, rule_type)}: {target}"
            # --- KONIEC ZMIANY ---

            self.achievements_def_tree.insert("", "end", iid=ach_id, values=(ach_id, name, desc, condition_str))

# W klasie GameLauncher


    def _delete_achievement_def(self):
        """Usuwa zaznaczoną definicję osiągnięcia (wybraną w Ustawieniach)."""
        # --- ZMIANA: Użyj drzewa definicji z Ustawień do wyboru ---
        parent_window = self.settings_page_frame # Dla messageboxów
        if not hasattr(self, 'achievements_def_tree') or not self.achievements_def_tree.winfo_exists():
             messagebox.showerror("Błąd", "Lista definicji w Ustawieniach nie jest dostępna.", parent=parent_window)
             return
        selection = self.achievements_def_tree.selection()
        # --- KONIEC ZMIANY ---
        if not selection:
            messagebox.showwarning("Brak zaznaczenia", "Zaznacz osiągnięcie na liście w Ustawieniach, które chcesz usunąć.", parent=parent_window)
            return

        ach_id = selection[0]
        ach_name = self.achievements_def_tree.item(ach_id, "values")[1]

        if messagebox.askyesno("Potwierdź usunięcie", f"Czy na pewno chcesz usunąć definicję osiągnięcia:\n'{ach_name}' ({ach_id})?", parent=parent_window):
            original_length = len(self.achievement_definitions)
            self.achievement_definitions = [ach for ach in self.achievement_definitions if ach.get("id") != ach_id]

            if len(self.achievement_definitions) < original_length:
                 if self._save_achievement_definitions_to_file():
                      self._reset_single_achievement_progress(ach_id)
                      self.check_and_unlock_achievements()
                      logging.info(f"Usunięto definicję osiągnięcia: {ach_id}")
                 else:
                      self._load_achievement_definitions() # Przywróć z pliku w razie błędu zapisu
                      self._load_achievement_def_list()
            else:
                 messagebox.showerror("Błąd", "Nie znaleziono osiągnięcia do usunięcia.", parent=parent_window)


    # --- NOWA METODA: Zapis definicji do pliku ---
    def _save_achievement_definitions_to_file(self):
         """Zapisuje aktualny stan self.achievement_definitions do pliku JSON."""
         definitions_file = "achievements_def.json"
         try:
              with open(definitions_file, "w", encoding="utf-8") as f:
                   json.dump(self.achievement_definitions, f, indent=2, ensure_ascii=False) # Użyj indent=2 dla czytelności
              logging.info(f"Zapisano {len(self.achievement_definitions)} definicji osiągnięć do pliku {definitions_file}.")
              return True
         except TypeError as e:
              logging.error(f"Błąd serializacji definicji osiągnięć do JSON: {e}")
              messagebox.showerror("Błąd Zapisu Osiągnięć", f"Nie można zapisać definicji osiągnięć z powodu błędu typu danych: {e}", parent=self.settings_page_frame)
              return False
         except Exception as e:
              logging.exception("Nieoczekiwany błąd podczas zapisu definicji osiągnięć.")
              messagebox.showerror("Błąd Zapisu Osiągnięć", f"Wystąpił nieoczekiwany błąd podczas zapisu definicji osiągnięć: {e}", parent=self.settings_page_frame)
              return False

    def prompt_update(self, update_info):
        if update_info.get("available"):
            latest_version = update_info['latest_version']
            if messagebox.askyesno("Aktualizacja Dostępna", f"Dostępna jest nowa wersja ({latest_version}). Czy chcesz ją pobrać i zainstalować?"):
                self.download_and_update(update_info['download_url'])
        else:
            logging.info("Nie ma dostępnych aktualizacji.")

    def download_and_update(self, download_url):
        import tempfile, shutil, subprocess, os, sys, threading
        try:
            response = requests.get(download_url, stream=True)
            response.raise_for_status()

            current_exe = sys.executable
            temp_dir = tempfile.gettempdir()
            new_exe_path = os.path.join(temp_dir, "GameLauncher_Update.exe")

            with open(new_exe_path, 'wb') as file:
                shutil.copyfileobj(response.raw, file)

            updater_script = os.path.join(temp_dir, "updater.bat")
            with open(updater_script, 'w', encoding='cp1250') as script:
                script.write(
                    f"""@echo off
    timeout /t 3 /nobreak > NUL
    echo Aktualizuję...
    copy /Y "{new_exe_path}" "{current_exe}"
    start "" "{current_exe}"
    del "{new_exe_path}"
    del "%~f0"
    """
                )

            # 1) Uruchamiamy batch
            subprocess.Popen(["cmd", "/c", updater_script], shell=True)
            # 2) Zamykamy starą instancję
            self.root.quit()

        except Exception as e:
            logging.error(f"Błąd podczas pobierania aktualizacji: {e}")
            messagebox.showerror("Błąd", f"Nie udało się pobrać aktualizacji: {e}")



    def manual_check_updates(self):
        """Ręczne sprawdzanie aktualizacji przez użytkownika."""
        update_info = self.check_for_updates()
        self.prompt_update(update_info)




    
    def fix_user_in_path(self, old_path: str) -> str:
        """
        Zamienia fragment 'C:/Users/<ktoś>' w old_path 
        na ścieżkę do aktualnie zalogowanego użytkownika 
        (os.path.expanduser("~")), zachowując resztę ścieżki.
        Jeśli old_path nie zaczyna się od 'C:/Users/...',
        pozostaje bez zmian.
        """
        user_home = os.path.expanduser("~")  # np. C:/Users/TwojaNazwa
        # Zawsze pracuj na slashach /, żeby re.match było prostsze:
        old_fixed = old_path.replace("\\", "/")

        pattern = r"^([A-Z]:/Users/[^/]+)(.*)$"
        match = re.match(pattern, old_fixed, re.IGNORECASE)
        if match:
            # remainder = np. "/Documents/Gra" – czyli wszystko po "C:/Users/<ktoś>"
            remainder = match.group(2)
            user_home_slash = user_home.replace("\\", "/")
            new_path_slash = user_home_slash + remainder
            # Przywracamy slashe Windowsowe (jeśli trzeba):
            new_path = new_path_slash.replace("/", os.sep)
            return new_path
        else:
            return old_path

    def repair_save_paths(self):
        """
        Przykładowa metoda, która iteruje po wszystkich grach
        i poprawia ścieżki zapisów (save_path).
        """
        for game_name, game_data in self.games.items():
            old_path = game_data.get("save_path")
            if not old_path:
                continue

            # WAŻNE: Wywołanie przez self.fix_user_in_path
            new_path = self.fix_user_in_path(old_path)

            if new_path != old_path:
                game_data["save_path"] = new_path

            # Możesz też utworzyć folder, jeśli go nie ma:
            try:
                os.makedirs(new_path, exist_ok=True)
            except Exception as e:
                print(f"Nie udało się utworzyć folderu {new_path} dla gry '{game_name}': {e}")

        # Na koniec zapisz config, jeśli chcesz
        # save_config(self.config)



# W klasie GameLauncher

    def backup_to_local_folder(self):
        """
        Kopiuje kluczowe pliki konfiguracyjne i foldery danych aplikacji
        do wskazanego przez użytkownika folderu backupu.
        Pokazuje prosty pasek postępu podczas operacji.
        """
        backup_dir_base = filedialog.askdirectory(title="Wybierz folder, gdzie zrobić backup", parent=self.root)
        if not backup_dir_base:
            return

        timestamp_str = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        # --- ZMIANA: Nazwa folderu głównego backupu ---
        backup_main_folder_name = f"GameLauncher_Backup_{timestamp_str}"
        backup_destination_root = os.path.join(backup_dir_base, backup_main_folder_name)
        # --- KONIEC ZMIANY ---
        
        # Definicja prostych kroków dla paska postępu
        # Każdy element to krotka: (opis_etapu, ścieżka_źródłowa_w_aplikacji, nazwa_docelowa_w_backupie, typ ('file' lub 'dir'))
        # Nazwa docelowa będzie taka sama jak źródłowa dla uproszczenia.
        # --- NOWE ZMIANY: Uproszczona lista kroków i nowa logika kopiowania ---
        items_to_backup = [
            ("Kopiowanie: config.json", CONFIG_FILE, os.path.basename(CONFIG_FILE), 'file'),
            ("Kopiowanie: local_settings.json", LOCAL_SETTINGS_FILE, os.path.basename(LOCAL_SETTINGS_FILE), 'file'),
            ("Kopiowanie: achievements_def.json", "achievements_def.json", "achievements_def.json", 'file'),
            ("Kopiowanie folderu: games_saves", GAMES_FOLDER, GAMES_FOLDER, 'dir'),
            ("Kopiowanie folderu: images (okładki gier i muzyki)", IMAGES_FOLDER, IMAGES_FOLDER, 'dir'),
            ("Kopiowanie folderu: internal_music", INTERNAL_MUSIC_DIR, INTERNAL_MUSIC_DIR, 'dir'),
                        # --- NOWE ZMIANY ---
            ("Kopiowanie folderu: custom_themes", CUSTOM_THEMES_DIR, CUSTOM_THEMES_DIR, 'dir'), # Dodaj ten wiersz
            # --- KONIEC NOWYCH ZMIAN ---
            # Możesz tu dodać inne pliki/foldery, np. dla motywów, jeśli są
        ]
        # --- KONIEC NOWYCH ZMIAN ---

        # Pokaż okno postępu
        self.show_progress_window(f"Tworzenie Backupu: {backup_main_folder_name}")
        if not (hasattr(self, 'progress_window') and self.progress_window.winfo_exists()):
            logging.error("Nie udało się utworzyć okna postępu dla tworzenia backupu.")
            return

        # --- NOWE ZMIANY: Konfiguracja paska postępu dla liczby kroków ---
        self.progress_bar['maximum'] = len(items_to_backup) # Maksimum to liczba elementów do skopiowania
        self.progress_bar['value'] = 0
        self.progress_bar['mode'] = 'determinate'
        # --- KONIEC NOWYCH ZMIAN ---

        # Funkcja pomocnicza do aktualizacji UI paska postępu (prostsza)
        def _update_simple_backup_progress(current_step_index, description):
            if hasattr(self, 'progress_window') and self.progress_window.winfo_exists():
                self.progress_bar['value'] = current_step_index + 1
                self.progress_label.config(text=f"Etap {current_step_index + 1}/{len(items_to_backup)}: {description}")
                self.progress_window.update_idletasks()

        # Funkcja wykonująca backup w osobnym wątku
        def _perform_simple_backup_thread():
            backup_success_thread = True
            error_message_thread = ""

            try:
                os.makedirs(backup_destination_root, exist_ok=True)
                logging.info(f"Utworzono główny folder backupu: {backup_destination_root}")

                for idx, (description, source_path_app, dest_name_in_backup, item_type) in enumerate(items_to_backup):
                    self.root.after(0, lambda i=idx, d=description: _update_simple_backup_progress(i, d))
                    
                    full_source_path_app = os.path.abspath(source_path_app)
                    full_dest_path_in_backup = os.path.join(backup_destination_root, dest_name_in_backup)

                    if not os.path.exists(full_source_path_app):
                        logging.warning(f"Backup: Zasób źródłowy '{full_source_path_app}' nie istnieje. Pomijanie.")
                        continue # Przejdź do następnego elementu

                    try:
                        if item_type == 'file':
                            shutil.copy2(full_source_path_app, full_dest_path_in_backup)
                            logging.info(f"Backup: Skopiowano plik '{full_source_path_app}' do '{full_dest_path_in_backup}'.")
                        elif item_type == 'dir':
                            if os.path.exists(full_dest_path_in_backup): # Jeśli folder docelowy istnieje, usuń go najpierw
                                shutil.rmtree(full_dest_path_in_backup)
                            shutil.copytree(full_source_path_app, full_dest_path_in_backup, dirs_exist_ok=False) # dirs_exist_ok=False, bo już usunęliśmy
                            logging.info(f"Backup: Skopiowano folder '{full_source_path_app}' do '{full_dest_path_in_backup}'.")
                    except Exception as e_copy_item:
                        logging.error(f"Backup: Błąd podczas kopiowania '{full_source_path_app}' do '{full_dest_path_in_backup}': {e_copy_item}")
                        # Można zdecydować, czy kontynuować, czy przerwać. Na razie kontynuujemy z innymi elementami.
                        # backup_success_thread = False; error_message_thread = str(e_copy_item); # Można by tu ustawić globalny błąd
                
                # --- NOWE ZMIANY: Zapisanie pliku local_settings.json BEZ modyfikacji do backupu ---
                # Ten plik jest już na liście items_to_backup, więc zostanie skopiowany.
                # Nie potrzebujemy już `local_settings_data_for_backup_thread` ani specjalnego zapisu.
                # --- KONIEC NOWYCH ZMIAN ---

            except Exception as e_thread_main:
                backup_success_thread = False
                error_message_thread = str(e_thread_main)
                logging.exception("Backup: Krytyczny błąd w wątku tworzenia backupu.")
            finally:
                if hasattr(self, 'progress_window') and self.progress_window.winfo_exists():
                    self.root.after(100, self.progress_window.destroy) # Zamknij okno postępu

                if backup_success_thread:
                    self.root.after(150, lambda bd=backup_destination_root: messagebox.showinfo(
                        "Sukces Backup",
                        f"Backup aplikacji został pomyślnie utworzony w folderze:\n{bd}",
                        parent=self.root
                    ))
                else:
                    final_err_msg_ui = f"Nie udało się utworzyć pełnego backupu aplikacji.\nBłąd: {error_message_thread}"
                    self.root.after(150, lambda err_ui=final_err_msg_ui: messagebox.showerror(
                        "Błąd Backupu", err_ui, parent=self.root
                    ))
                    # Rozważ usunięcie niekompletnego folderu backupu
                    if os.path.exists(backup_destination_root):
                        try:
                            shutil.rmtree(backup_destination_root)
                            logging.info(f"Usunięto niekompletny folder backupu: {backup_destination_root}")
                        except Exception as e_del_incomplete:
                            logging.error(f"Nie można usunąć niekompletnego folderu backupu '{backup_destination_root}': {e_del_incomplete}")
        
        # Uruchomienie wątku
        threading.Thread(target=_perform_simple_backup_thread, daemon=True).start()
        
    def load_local_backup(self):
        """
        Przywraca stan aplikacji z wybranego folderu backupu poprzez bezpośrednie
        kopiowanie plików i folderów. Informuje o konieczności restartu.
        """
        backup_source_root = filedialog.askdirectory(
            title="Wybierz folder z backupem do przywrócenia (np. GameLauncher_Backup_...)",
            parent=self.root
        )
        if not backup_source_root:
            return

        if not messagebox.askyesno("Potwierdź Przywrócenie",
                                   "Czy na pewno chcesz przywrócić dane z tego backupu?\n"
                                   "Wszystkie obecne dane konfiguracyjne, zapisy gier, obrazy i wewnętrzna muzyka zostaną NADPISANE!\n\n"
                                   "Zaleca się zamknięcie aplikacji i utworzenie kopii zapasowej obecnego stanu przed kontynuacją, jeśli nie jesteś pewien.",
                                   icon='warning', parent=self.root):
            return

        # Lista elementów do przywrócenia: (opis, nazwa_zasobu_w_backupie, ścieżka_docelowa_w_aplikacji, typ)
        # Nazwa zasobu w backupie jest taka sama jak w aplikacji dzięki nowej logice backupu.
        items_to_restore = [
            ("Przywracanie: config.json", os.path.basename(CONFIG_FILE), CONFIG_FILE, 'file'),
            ("Przywracanie: local_settings.json", os.path.basename(LOCAL_SETTINGS_FILE), LOCAL_SETTINGS_FILE, 'file'),
            ("Przywracanie: achievements_def.json", "achievements_def.json", "achievements_def.json", 'file'),
            ("Przywracanie folderu: games_saves", GAMES_FOLDER, GAMES_FOLDER, 'dir'),
            ("Przywracanie folderu: images", IMAGES_FOLDER, IMAGES_FOLDER, 'dir'),
            ("Przywracanie folderu: internal_music", INTERNAL_MUSIC_DIR, INTERNAL_MUSIC_DIR, 'dir'),
                        # --- NOWE ZMIANY ---
            ("Przywracanie folderu: custom_themes", CUSTOM_THEMES_DIR, CUSTOM_THEMES_DIR, 'dir'), # Dodaj ten wiersz
            # --- KONIEC NOWYCH ZMIAN ---
        ]

        self.show_progress_window(f"Przywracanie Backupu: {os.path.basename(backup_source_root)}")
        if not (hasattr(self, 'progress_window') and self.progress_window.winfo_exists()):
            logging.error("Nie udało się utworzyć okna postępu dla przywracania backupu.")
            return

        self.progress_bar['maximum'] = len(items_to_restore)
        self.progress_bar['value'] = 0
        self.progress_bar['mode'] = 'determinate'

        def _update_simple_restore_progress(current_step_index, description):
            if hasattr(self, 'progress_window') and self.progress_window.winfo_exists():
                self.progress_bar['value'] = current_step_index + 1
                self.progress_label.config(text=f"Etap {current_step_index + 1}/{len(items_to_restore)}: {description}")
                self.progress_window.update_idletasks()

        def _perform_simple_restore_thread():
            restore_success_thread = True
            error_message_thread = ""
            app_root_path = os.getcwd() # Główny folder aplikacji

            try:
                for idx, (description, item_name_in_backup, item_app_path_relative, item_type) in enumerate(items_to_restore):
                    self.root.after(0, lambda i=idx, d=description: _update_simple_restore_progress(i, d))

                    source_path_in_backup = os.path.join(backup_source_root, item_name_in_backup)
                    destination_path_in_app = os.path.join(app_root_path, item_app_path_relative)

                    if not os.path.exists(source_path_in_backup):
                        logging.warning(f"Przywracanie: Zasób '{source_path_in_backup}' nie istnieje w backupie. Pomijanie.")
                        continue

                    try:
                        if item_type == 'file':
                            # Usuń stary plik w aplikacji, jeśli istnieje, przed kopiowaniem
                            if os.path.exists(destination_path_in_app):
                                os.remove(destination_path_in_app)
                            shutil.copy2(source_path_in_backup, destination_path_in_app)
                            logging.info(f"Przywracanie: Skopiowano plik '{source_path_in_backup}' do '{destination_path_in_app}'.")
                        elif item_type == 'dir':
                            if os.path.exists(destination_path_in_app):
                                shutil.rmtree(destination_path_in_app) # Usuń cały stary folder w aplikacji
                            shutil.copytree(source_path_in_backup, destination_path_in_app, dirs_exist_ok=False)
                            logging.info(f"Przywracanie: Skopiowano folder '{source_path_in_backup}' do '{destination_path_in_app}'.")
                    except Exception as e_copy_item_restore:
                        logging.error(f"Przywracanie: Błąd podczas kopiowania '{source_path_in_backup}' do '{destination_path_in_app}': {e_copy_item_restore}")
                        # Można tu ustawić flagę błędu i przerwać, lub kontynuować z innymi
                        restore_success_thread = False
                        error_message_thread = f"Błąd przy '{item_name_in_backup}': {e_copy_item_restore}"
                        # Na razie kontynuujemy, aby spróbować przywrócić jak najwięcej
                
            except Exception as e_thread_main_restore:
                restore_success_thread = False
                error_message_thread = str(e_thread_main_restore)
                logging.exception("Przywracanie: Krytyczny błąd w wątku przywracania backupu.")
            finally:
                if hasattr(self, 'progress_window') and self.progress_window.winfo_exists():
                    self.root.after(100, self.progress_window.destroy)

                if restore_success_thread:
                    logging.info("Przywracanie backupu plików zakończone pomyślnie. Rozpoczynanie odświeżania aplikacji.")

                                        # --- NOWE ZMIANY: Wyczyszczenie cache motywów niestandardowych po przywróceniu ---
                    if hasattr(self, '_custom_themes_cache'):
                        del self._custom_themes_cache # Wyczyść cache, aby GameLauncher załadował świeże z dysku
                    # --- KONIEC NOWYCH ZMIAN ---
                    
                    # --- NOWE ZMIANY: Sekwencja odświeżania po przywróceniu ---
                    try:
                        # 1. Wczytaj wszystkie konfiguracje na nowo
                        self.config = load_config()
                        self.settings = self.config.setdefault("settings", {})
                        self.games = self.config.setdefault("games", {})
                        self.groups = self.config.setdefault("groups", {})
                        self.user = self.config.setdefault("user", {})
                        self.mods_data = self.config.setdefault("mods_data", {})
                        self.archive = self.config.setdefault("archive", [])
                        self.roadmap = self.config.setdefault("roadmap", [])
                        self.local_settings = load_local_settings()
                        self._load_achievement_definitions()
                        logging.info("Konfiguracje wczytane do pamięci po przywróceniu backupu.")

                        # 2. Zastosuj podstawowe ustawienia (motyw, czcionka) PRZED przebudową UI
                        # To może pomóc uniknąć niektórych błędów TclError związanych ze stylami
                        self.apply_theme(THEMES.get(self.settings.get("theme", "Dark")))
                        self.apply_font_settings()
                        bg_image_path = self.settings.get("background_image", "")
                        if bg_image_path:
                            self.apply_background_image(bg_image_path)
                        
                        # 3. Odśwież główne komponenty UI.
                        # refresh_ui() niszczy i tworzy na nowo wiele rzeczy, co może być przyczyną błędów z 'after'.
                        # Spróbujmy najpierw tylko zaktualizować dane tam, gdzie to możliwe,
                        # a potem wymusić pokazanie strony głównej.
                        
                        # Zamiast pełnego self.refresh_ui(), zróbmy bardziej ukierunkowane odświeżanie.
                        # Najpierw sidebar, bo jest dość niezależny.
                        if hasattr(self, 'sidebar') and self.sidebar.winfo_exists():
                            self.create_sidebar()
                        self.show_home()
                        self.root.after(200, self.update_game_grid)
                        
                        # Odświeżenie odtwarzacza muzyki, jeśli istnieje
                        if hasattr(self, 'music_player_page_instance') and self.music_player_page_instance:
                            logging.info("Odświeżanie MusicPlayerPage po przywróceniu backupu.")
                            if hasattr(self.music_player_page_instance, '_clear_cover_caches'): # Sprawdź, czy metoda istnieje
                                self.music_player_page_instance._clear_cover_caches()
                            
                            self.music_player_page_instance.named_playlists = self.local_settings.get("named_music_playlists", {})
                            self.music_player_page_instance.active_playlist_name = self.local_settings.get("active_music_playlist_name")
                            self.music_player_page_instance.current_track_index = self.local_settings.get("current_track_in_active_playlist_index", -1)
                            self.music_player_page_instance.favorite_tracks = set(self.local_settings.get("music_favorite_tracks", []))
                            
                            self.music_player_page_instance._load_active_playlist()
                            self.music_player_page_instance._update_available_playlists_ui()
                            self.music_player_page_instance._update_playlist_display() # To odświeży listbox
                            
                            # Odśwież kafelki/focus jeśli są aktywne
                            if self.music_player_page_instance.music_library_view_mode.get() == "tiles":
                                self.music_player_page_instance._update_music_tiles_display()
                            if not self.music_player_page_instance.is_playlist_view_active.get():
                                self.music_player_page_instance._update_focus_cover_label(force=True)

                            self.music_player_page_instance.apply_theme_colors() # Zastosuj motyw
                            if self.music_player_page_instance.current_track_index != -1:
                                self.music_player_page_instance._update_now_playing_label()
                            else:
                                self.music_player_page_instance._update_now_playing_label(track_name_override="Nic nie gra")
                        
                        # Poinformuj o sukcesie
                        self.root.after(300, lambda: messagebox.showinfo(
                            "Przywracanie Zakończone",
                            "Dane z backupu zostały pomyślnie przywrócone i załadowane.",
                            parent=self.root
                        ))

                        # === DODAJ TO ===
                        self.root.after(350, self.refresh_ui)
                        self.root.after(360, self.show_home)
                        # === KONIEC DODATKU ===

                    except Exception as e_refresh_ui_after_restore:
                        logging.exception(f"Błąd podczas odświeżania UI po przywróceniu backupu: {e_refresh_ui_after_restore}")
                        messagebox.showwarning("Błąd Odświeżania", 
                                               f"Wystąpił błąd podczas pełnego odświeżania interfejsu po przywróceniu.\n"
                                               f"Szczegóły: {e_refresh_ui_after_restore}\n\n"
                                               "Zalecane jest zrestartowanie aplikacji.", 
                                               parent=self.root)
                    # --- KONIEC NOWYCH ZMIAN ---
                else: # Jeśli restore_success_thread jest False
                    final_err_msg_ui_restore = f"Nie udało się w pełni przywrócić danych z backupu.\nBłąd: {error_message_thread}"
                    self.root.after(150, lambda err_ui_restore=final_err_msg_ui_restore: messagebox.showerror(
                        "Błąd Przywracania", err_ui_restore, parent=self.root
                    ))
        
        threading.Thread(target=_perform_simple_restore_thread, daemon=True).start()


    def _perform_backup_restore_thread(self, backup_dir):
        """
        Wykonuje operacje przywracania backupu w osobnym wątku,
        aktualizując UI okna postępu. (TWOJA LOGIKA W ŚRODKU)
        """
        target_music_library_base_path = os.path.abspath(INTERNAL_MUSIC_DIR)
        os.makedirs(target_music_library_base_path, exist_ok=True)
        success = True
        error_message_details = "Wystąpił nieznany błąd." # Domyślny komunikat
        current_step_description_for_error = "w trakcie inicjalizacji"

        try:
            # ETAP 0: Przygotowywanie
            self.current_restore_step_index = 0
            step_info = self.restore_steps[self.current_restore_step_index]
            current_step_description_for_error = step_info[0]
            self.root.after(0, lambda: self._update_restore_progress(
                next_step_description=step_info[0],
                # Na początku nie dodajemy inkrementacji, bo to tylko start etapu 0
            ))
            time.sleep(0.1) # Mała pauza na wyświetlenie
            # Inkrementacja wagi etapu 0 na końcu etapu (lub tutaj jeśli to jedyna operacja)
            self.root.after(0, lambda: self._update_restore_progress(increment_value=step_info[1]))


            # ETAP 1: Odczytywanie ustawień lokalnych z backupu
            self.current_restore_step_index = 1
            step_info = self.restore_steps[self.current_restore_step_index]
            current_step_description_for_error = step_info[0]
            self.root.after(0, lambda: self._update_restore_progress(next_step_description=current_step_description_for_error))
            
            backed_up_local_settings_path = os.path.join(backup_dir, os.path.basename(LOCAL_SETTINGS_FILE))
            backed_up_local_settings_data = {}
            if os.path.exists(backed_up_local_settings_path):
                with open(backed_up_local_settings_path, "r", encoding="utf-8") as f:
                    backed_up_local_settings_data = json.load(f)
                logging.info(f"Wczytano {LOCAL_SETTINGS_FILE} z backupu.")
            else:
                logging.warning(f"Brak pliku {LOCAL_SETTINGS_FILE} w backupie. Kontynuowanie z pustymi danymi dla muzyki.")
                # Pozwalamy kontynuować, ale niektóre rzeczy nie zostaną przywrócone
            self.root.after(0, lambda: self._update_restore_progress(increment_value=step_info[1]))

            # ETAP 2: Przygotowywanie do przywrócenia biblioteki muzycznej
            self.current_restore_step_index = 2
            step_info = self.restore_steps[self.current_restore_step_index]
            current_step_description_for_error = step_info[0]
            self.root.after(0, lambda: self._update_restore_progress(next_step_description=current_step_description_for_error))
            
            music_backup_source_folder = os.path.join(backup_dir, "music_library_backup")
            restored_named_playlists = {} # Inicjalizacja tutaj
            # --- Tu już nie ma `os.makedirs(target_music_library_base_path...)`, bo jest na początku funkcji
            self.root.after(0, lambda: self._update_restore_progress(increment_value=step_info[1]))


            # ETAP 3: Kopiowanie plików muzycznych
            self.current_restore_step_index = 3
            step_info = self.restore_steps[self.current_restore_step_index]
            music_stage_weight = step_info[1]
            current_step_description_for_error = step_info[0]
            self.root.after(0, lambda: self._update_restore_progress(next_step_description=current_step_description_for_error))

            music_files_to_process_for_progress = []
            # Najpierw zbierz listę plików do skopiowania, aby znać ich liczbę
            if "named_music_playlists" in backed_up_local_settings_data:
                for pl_name, backed_up_entries in backed_up_local_settings_data.get("named_music_playlists", {}).items():
                    for entry in backed_up_entries:
                        rel_path = entry.get('path')
                        if rel_path:
                            src_music_file = os.path.join(music_backup_source_folder, rel_path)
                            if os.path.exists(src_music_file):
                                music_files_to_process_for_progress.append(src_music_file)
            
            total_music_files = len(music_files_to_process_for_progress)
            processed_music_files = 0

            # Faktyczne kopiowanie i aktualizacja danych playlist
            if "named_music_playlists" in backed_up_local_settings_data:
                for playlist_name, backed_up_track_entries in backed_up_local_settings_data["named_music_playlists"].items():
                    current_playlist_restored_entries = []
                    for backed_up_entry in backed_up_track_entries:
                        relative_music_path = backed_up_entry.get('path') 
                        if not relative_music_path: 
                            current_playlist_restored_entries.append(backed_up_entry.copy()) # Zachowaj wpis, ale ścieżka może być zła
                            continue

                        source_music_file_in_backup = os.path.join(music_backup_source_folder, relative_music_path)
                        new_local_entry = backed_up_entry.copy()

                        if os.path.exists(source_music_file_in_backup):
                            music_filename_only = os.path.basename(relative_music_path)
                            target_music_file_local_abs = os.path.join(target_music_library_base_path, music_filename_only)
                            try:
                                os.makedirs(os.path.dirname(target_music_file_local_abs), exist_ok=True)
                                shutil.copy2(source_music_file_in_backup, target_music_file_local_abs)
                                new_local_entry['path'] = target_music_file_local_abs
                                new_local_entry['is_internal'] = True
                            except Exception as e_restore_music:
                                logging.error(f"Nie udało się przywrócić pliku muzycznego '{relative_music_path}': {e_restore_music}")
                                new_local_entry['path'] = None
                            
                            processed_music_files += 1
                            file_progress_percent = int((processed_music_files / total_music_files) * 100) if total_music_files > 0 else 0
                            if hasattr(self, 'progress_window') and self.progress_window.winfo_exists():
                                self.root.after(0, lambda f_details=music_filename_only, fp_perc=file_progress_percent : self._update_restore_progress(
                                    file_details=f_details,
                                    file_progress_percent=fp_perc
                                ))
                        else:
                            logging.warning(f"Plik muzyczny '{relative_music_path}' (ścieżka z backupu: {source_music_file_in_backup}) nie został znaleziony.")
                            new_local_entry['path'] = None
                        current_playlist_restored_entries.append(new_local_entry)
                    restored_named_playlists[playlist_name] = current_playlist_restored_entries
            self.root.after(0, lambda: self._update_restore_progress(increment_value=music_stage_weight))


            # ETAP 4: Zapisywanie zaktualizowanych ustawień lokalnych
            self.current_restore_step_index = 4
            step_info = self.restore_steps[self.current_restore_step_index]
            current_step_description_for_error = step_info[0]
            self.root.after(0, lambda: self._update_restore_progress(next_step_description=current_step_description_for_error))
            
            self.local_settings.clear()
            self.local_settings.update(backed_up_local_settings_data) # backed_up_local_settings_data zawiera już zaktualizowane ścieżki muzyki
            self.local_settings["named_music_playlists"] = restored_named_playlists
            save_local_settings(self.local_settings)
            logging.info(f"Zaktualizowano i zapisano główny {LOCAL_SETTINGS_FILE} po przywróceniu muzyki.")
            self.root.after(0, lambda: self._update_restore_progress(increment_value=step_info[1]))


            # ETAP 5: Przywracanie głównych plików konfiguracyjnych
            self.current_restore_step_index = 5
            step_info = self.restore_steps[self.current_restore_step_index]
            current_step_description_for_error = step_info[0]
            self.root.after(0, lambda: self._update_restore_progress(next_step_description=current_step_description_for_error))
            
            # Przenieś config.json
            config_src_path = os.path.join(backup_dir, os.path.basename(CONFIG_FILE))
            if os.path.exists(config_src_path): shutil.copy2(config_src_path, CONFIG_FILE)
            else: logging.warning(f"W backupie nie znaleziono {CONFIG_FILE}.")
            
            # Przenieś achievements_def.json
            ach_def_src_path = os.path.join(backup_dir, "achievements_def.json")
            if os.path.exists(ach_def_src_path): shutil.copy2(ach_def_src_path, "achievements_def.json")
            else: logging.warning("W backupie nie znaleziono achievements_def.json.")
            self.root.after(0, lambda: self._update_restore_progress(increment_value=step_info[1]))


            # ETAP 6: Przywracanie folderu zapisów gier (games_saves)
            self.current_restore_step_index = 6
            step_info = self.restore_steps[self.current_restore_step_index]
            current_step_description_for_error = step_info[0]
            self.root.after(0, lambda: self._update_restore_progress(next_step_description=current_step_description_for_error))
            
            saves_src_dir = os.path.join(backup_dir, "games_saves_backup")
            if os.path.exists(saves_src_dir):
                if os.path.exists(GAMES_FOLDER): shutil.rmtree(GAMES_FOLDER)
                shutil.copytree(saves_src_dir, GAMES_FOLDER, dirs_exist_ok=True)
                logging.info("Przywrócono folder games_saves.")
            else:
                logging.warning("W backupie nie znaleziono folderu 'games_saves_backup'.")
            self.root.after(0, lambda: self._update_restore_progress(increment_value=step_info[1]))


            # ETAP 7: Przywracanie folderu obrazów (images)
            self.current_restore_step_index = 7
            step_info = self.restore_steps[self.current_restore_step_index]
            current_step_description_for_error = step_info[0]
            self.root.after(0, lambda: self._update_restore_progress(next_step_description=current_step_description_for_error))

            images_src_dir = os.path.join(backup_dir, "images_backup")
            images_dst_app_dir = os.path.abspath(IMAGES_FOLDER)
            if os.path.exists(images_src_dir):
                if os.path.exists(images_dst_app_dir): shutil.rmtree(images_dst_app_dir)
                shutil.copytree(images_src_dir, images_dst_app_dir, dirs_exist_ok=True)
                logging.info(f"Przywrócono folder images do '{images_dst_app_dir}'.")
            else:
                logging.warning("W backupie nie znaleziono folderu 'images_backup'.")
            self.root.after(0, lambda: self._update_restore_progress(increment_value=step_info[1]))
            

            # ETAP 8: Ponowne ładowanie konfiguracji do pamięci i odświeżanie UI
            self.current_restore_step_index = 8
            step_info = self.restore_steps[self.current_restore_step_index]
            current_step_description_for_error = step_info[0]
            self.root.after(0, lambda: self._update_restore_progress(next_step_description=current_step_description_for_error))
            
            self.config = load_config()
            self.settings = self.config.setdefault("settings", {})
            self.games = self.config.setdefault("games", {})
            # ... reszta pól jak w oryginalnym kodzie ...
            self.groups = self.config.setdefault("groups", {})
            self.user = self.config.setdefault("user", {})
            self.mods_data = self.config.setdefault("mods_data", {})
            self.archive = self.config.setdefault("archive", [])
            self.roadmap = self.config.setdefault("roadmap", [])

            self._load_achievement_definitions() 
            # self.local_settings już mamy zaktualizowane i zapisane
            
            # --- Kolejność wywołań w self.root.after dla UI ---
            def refresh_all_ui_components():
                self.repair_save_paths()
                self.refresh_ui() # To jest kluczowe, odświeża np. sidebar, home_page etc.
                self.show_home()  # Ustawia stronę główną

                # Odświeżenie odtwarzacza muzyki
                if hasattr(self, 'music_player_page_instance') and self.music_player_page_instance:
                    logging.info("Końcowe odświeżanie odtwarzacza muzyki po przywróceniu backupu.")
                    self.music_player_page_instance.named_playlists = self.local_settings.get("named_music_playlists", {})
                    self.music_player_page_instance.active_playlist_name = self.local_settings.get("active_music_playlist_name")
                    self.music_player_page_instance.current_track_index = self.local_settings.get("current_track_in_active_playlist_index", -1)
                    self.music_player_page_instance.favorite_tracks = set(self.local_settings.get("music_favorite_tracks", []))
                    
                    self.music_player_page_instance._load_active_playlist()
                    self.music_player_page_instance._update_available_playlists_ui()
                    self.music_player_page_instance._update_playlist_display()
                    self.music_player_page_instance.apply_theme_colors()
                    if self.music_player_page_instance.current_track_index != -1:
                        self.music_player_page_instance._update_now_playing_label()
                    else:
                        self.music_player_page_instance._update_now_playing_label(track_name_override="Nic nie gra")
                
                # Końcowa aktualizacja paska postępu do 100%
                self._update_restore_progress(next_step_description="Zakończono przywracanie!", increment_value=(100 - self.total_progress_accumulator))


            self.root.after(0, refresh_all_ui_components)
            # Celowo nie inkrementujemy tutaj wagi etapu 8, zrobimy to w refresh_all_ui_components po zakończeniu odświeżania

        except json.JSONDecodeError as e_json:
            success = False
            error_message_details = f"Błąd formatu pliku konfiguracyjnego (JSON) w etapie '{current_step_description_for_error}': {e_json}"
            logging.error(error_message_details)
        except IOError as e_io:
            success = False
            error_message_details = f"Błąd operacji plikowej (np. kopiowanie) w etapie '{current_step_description_for_error}': {e_io}"
            logging.error(error_message_details)
        except Exception as e_general:
            success = False
            error_message_details = f"Nieoczekiwany błąd podczas przywracania w etapie '{current_step_description_for_error}': {e_general}"
            logging.exception(error_message_details) # Zapisz pełny traceback dla nieoczekiwanych błędów
        finally:
            # Zapewnij, że okno postępu zostanie zamknięte i wyświetlony zostanie komunikat
            # Dajmy UI chwilę na przetworzenie ostatnich aktualizacji paska, zanim zamkniemy okno
            self.root.after(200, lambda: self._destroy_progress_window())
            if success:
                self.root.after(250, lambda target_music_path=target_music_library_base_path: messagebox.showinfo(
                    "Sukces",
                    f"Przywrócono backup z wybranego folderu.\n\nŚcieżki muzyki zostały zaktualizowane i wskazują na wewnętrzną bibliotekę:\n{target_music_path}",
                    parent=self.root
                ))
            else:
                # Wyświetl bardziej szczegółowy komunikat o błędzie
                self.root.after(250, lambda msg=error_message_details: messagebox.showerror(
                    "Błąd Przywracania",
                    f"Nie udało się w pełni przywrócić backupu.\nSzczegóły:\n{msg}",
                    parent=self.root
                ))

    # --- NOWA METODA: Aktualizacja paska postępu dla PRZYWRACANIA ---
    def _update_restore_progress(self, next_step_description=None, increment_value=None, file_details=None, file_progress_percent=None): # DODANO file_details i file_progress_percent
        """
        Aktualizuje pasek postępu i etykietę podczas przywracania backupu.
        Jeśli 'increment_value' jest podane, dodaje je do 'total_progress_accumulator'.
        Jeśli 'next_step_description' jest podane, używa go jako głównego opisu etapu.
        'file_details' to dodatkowe info np. nazwa pliku.
        'file_progress_percent' to procent dla bieżącego pliku/operacji w ramach etapu.
        """
        if not hasattr(self, 'progress_window') or not self.progress_window.winfo_exists():
            logging.warning("Próba aktualizacji nieistniejącego okna postępu (_update_restore_progress).")
            return

        if increment_value is not None:
            self.total_progress_accumulator += increment_value
            self.total_progress_accumulator = min(self.total_progress_accumulator, 100)
        
        self.progress_bar['value'] = self.total_progress_accumulator

        final_text = ""
        if file_details and file_progress_percent is not None and next_step_description:
            # Wyświetl pełny opis etapu, szczegóły pliku i procenty
            base_desc_for_file_progress = next_step_description.replace("...", "") # Usuń "..." jeśli jest
            final_text = f"{base_desc_for_file_progress}: {file_details} ({file_progress_percent}%) (Całość: {self.total_progress_accumulator}%)"
        elif next_step_description:
            # Tylko opis etapu i globalny procent
            final_text = f"{next_step_description} ({self.total_progress_accumulator}%)"
        else:
            # Tylko globalny procent, jeśli nic innego nie podano
            final_text = f"Postęp: {self.total_progress_accumulator}%"
            
        if hasattr(self, 'progress_label') and self.progress_label.winfo_exists(): # Sprawdź istnienie etykiety
            self.progress_label.config(text=final_text)
        
        self.progress_window.update_idletasks()
    # --- KONIEC NOWEJ METODY ---

    def _perform_backup_restore_thread(self, backup_dir):
        """
        Wykonuje operacje przywracania backupu w osobnym wątku,
        aktualizując UI okna postępu.
        """
        target_music_library_base_path = os.path.abspath(INTERNAL_MUSIC_DIR)
        os.makedirs(target_music_library_base_path, exist_ok=True)
        success = True
        error_message_details = "" # Bardziej szczegółowy opis błędu
        current_step_description_for_error = "przygotowania"

        try:
            # ETAP 0: Przygotowywanie (rozpoczęcie)
            current_step_description_for_error = self.restore_steps[0][0]
            self.root.after(0, lambda: self._update_restore_progress(
                next_step_description=self.restore_steps[0][0],
                increment_value=self.restore_steps[0][1]
            ))

            # ETAP 1: Wczytywanie ustawień lokalnych z backupu
            current_step_description_for_error = self.restore_steps[1][0]
            self.root.after(0, lambda: self._update_restore_progress(next_step_description=current_step_description_for_error))
            
            backed_up_local_settings_path = os.path.join(backup_dir, os.path.basename(LOCAL_SETTINGS_FILE))
            backed_up_local_settings_data = {}
            if os.path.exists(backed_up_local_settings_path):
                with open(backed_up_local_settings_path, "r", encoding="utf-8") as f:
                    backed_up_local_settings_data = json.load(f)
            else:
                logging.warning(f"Brak pliku {LOCAL_SETTINGS_FILE} w backupie.")
                # Nie przerywamy, ale można to zalogować jako część błędu jeśli reszta zawiedzie
            self.root.after(0, lambda: self._update_restore_progress(increment_value=self.restore_steps[1][1]))

            # ETAP 2: Przygotowywanie do przywrócenia biblioteki muzycznej
            current_step_description_for_error = self.restore_steps[2][0]
            self.root.after(0, lambda: self._update_restore_progress(next_step_description=current_step_description_for_error))
            music_backup_source_folder = os.path.join(backup_dir, "music_library_backup")
            self.root.after(0, lambda: self._update_restore_progress(increment_value=self.restore_steps[2][1]))

            # ETAP 3: Kopiowanie plików muzycznych
            self.current_restore_step_index = 3
            step_info = self.restore_steps[self.current_restore_step_index]
            music_stage_weight = step_info[1]
            current_step_description_for_error = step_info[0]
            self.root.after(0, lambda: self._update_restore_progress(next_step_description=current_step_description_for_error))
            
            music_files_to_process_from_backup = []
            if "named_music_playlists" in backed_up_local_settings_data: # Użyj danych WCZYTANYCH z backupu
                for pl_name, backed_up_entries in backed_up_local_settings_data.get("named_music_playlists", {}).items():
                    for entry_from_backup in backed_up_entries:
                        # W backupie, 'path' dla wewnętrznych to tylko nazwa pliku, 'is_internal' jest True
                        # Dla zewnętrznych, 'path' powinno być None, a 'is_internal' False
                        if entry_from_backup.get('is_internal') and entry_from_backup.get('path'): # Sprawdź oba warunki
                            filename_in_backup_folder = entry_from_backup.get('path')
                            src_music_file_in_backup_storage = os.path.join(music_backup_source_folder, filename_in_backup_folder)
                            if os.path.exists(src_music_file_in_backup_storage):
                                # Przekaż oryginalny wpis z backupu i nazwę playlisty do aktualizacji
                                music_files_to_process_from_backup.append((src_music_file_in_backup_storage, entry_from_backup, pl_name))
            
            total_music_files_to_restore = len(music_files_to_process_from_backup)
            processed_music_files_restore = 0

            # Iteruj po plikach do przywrócenia
            for src_file_path_from_backup, original_entry_from_json_backup, playlist_name_for_restore_update in music_files_to_process_from_backup:
                music_filename_only = os.path.basename(src_file_path_from_backup) # To samo co original_entry_from_json_backup.get('path')
                target_abs_path_in_internal_dir = os.path.join(target_music_library_base_path, music_filename_only)
                try:
                    os.makedirs(os.path.dirname(target_abs_path_in_internal_dir), exist_ok=True)
                    shutil.copy2(src_file_path_from_backup, target_abs_path_in_internal_dir)
                    
                    # --- ZMIANA: Aktualizuj backed_up_local_settings_data, a nie self.local_settings ---
                    # To jest ważne, bo self.local_settings zostanie nadpisane w całości później
                    # backed_up_local_settings_data będzie miało oryginalne dane z backupu, ale musimy
                    # podmienić 'path' dla przywróconych plików na ich nową, bezwzględną ścieżkę.
                    
                    # Znajdź i zaktualizuj wpis w backed_up_local_settings_data
                    playlist_to_update = backed_up_local_settings_data["named_music_playlists"].get(playlist_name_for_restore_update)
                    if playlist_to_update:
                        for i, entry_in_pl in enumerate(playlist_to_update):
                            # Porównaj z oryginalnym wpisem z JSONa (np. po starej ścieżce względnej lub unikalnym ID jeśli było)
                            # Tutaj musimy być ostrożni. `original_entry_from_json_backup` jest referencją.
                            # Modyfikujemy go, a potem `local_settings.update(backed_up_local_settings_data)` przepisze wszystko.
                            if entry_in_pl == original_entry_from_json_backup: # Porównanie słowników powinno działać
                                entry_in_pl['path'] = target_abs_path_in_internal_dir
                                entry_in_pl['is_internal'] = True # Potwierdź, że jest teraz wewnętrzny
                                logging.debug(f"Przywracanie: zaktualizowano ścieżkę dla {music_filename_only} w playliście {playlist_name_for_restore_update}")
                                break
                    # --- KONIEC ZMIANY ---

                    processed_music_files_restore += 1
                    file_progress_percent = int((processed_music_files_restore / total_music_files_to_restore) * 100) if total_music_files_to_restore > 0 else 0
                    if hasattr(self, 'progress_window') and self.progress_window.winfo_exists():
                        self.root.after(0, lambda f_details=music_filename_only, fp_perc=file_progress_percent, current_step_desc=current_step_description_for_error : self._update_restore_progress(
                            next_step_description=current_step_desc, # Przekaż aktualny opis etapu
                            file_details=f_details,
                            file_progress_percent=fp_perc
                        ))
                except Exception as e_music_restore_single:
                    logging.error(f"Nie udało się przywrócić pliku muzycznego '{music_filename_only}' z backupu: {e_music_restore_single}")
                    # Oznacz ścieżkę jako None we wpisie w backed_up_local_settings_data,
                    # aby przy ładowaniu odtwarzacza był traktowany jako niedostępny
                    playlist_to_update = backed_up_local_settings_data["named_music_playlists"].get(playlist_name_for_restore_update)
                    if playlist_to_update:
                        for i, entry_in_pl in enumerate(playlist_to_update):
                            if entry_in_pl == original_entry_from_json_backup:
                                entry_in_pl['path'] = None
                                entry_in_pl['is_internal'] = False # Skoro nie ma pliku, nie jest wewnętrzny
                                break

            self.root.after(0, lambda: self._update_restore_progress(increment_value=music_stage_weight)) # Dodaj wagę etapu muzyki


            # ETAP 4: Zapisywanie zaktualizowanych ustawień lokalnych
            current_step_description_for_error = self.restore_steps[4][0]
            self.root.after(0, lambda: self._update_restore_progress(next_step_description=current_step_description_for_error))
            self.local_settings.clear()
            self.local_settings.update(backed_up_local_settings_data)
            save_local_settings(self.local_settings)
            self.root.after(0, lambda: self._update_restore_progress(increment_value=self.restore_steps[4][1]))

            # ETAP 5: Przywracanie głównych plików konfiguracyjnych
            current_step_description_for_error = self.restore_steps[5][0]
            self.root.after(0, lambda: self._update_restore_progress(next_step_description=current_step_description_for_error))
            for config_filename in [os.path.basename(CONFIG_FILE), "achievements_def.json"]:
                src_path = os.path.join(backup_dir, config_filename)
                dst_path = os.path.join(os.getcwd(), config_filename)
                if os.path.exists(src_path): shutil.copy2(src_path, dst_path)
            self.root.after(0, lambda: self._update_restore_progress(increment_value=self.restore_steps[5][1]))

            # ETAP 6: Przywracanie folderu zapisów gier
            current_step_description_for_error = self.restore_steps[6][0]
            self.root.after(0, lambda: self._update_restore_progress(next_step_description=current_step_description_for_error))
            saves_src = os.path.join(backup_dir, "games_saves_backup")
            if os.path.exists(saves_src):
                if os.path.exists(GAMES_FOLDER): shutil.rmtree(GAMES_FOLDER)
                shutil.copytree(saves_src, GAMES_FOLDER, dirs_exist_ok=True)
            self.root.after(0, lambda: self._update_restore_progress(increment_value=self.restore_steps[6][1]))

            # ETAP 7: Przywracanie folderu obrazów
            current_step_description_for_error = self.restore_steps[7][0]
            self.root.after(0, lambda: self._update_restore_progress(next_step_description=current_step_description_for_error))
            images_src = os.path.join(backup_dir, "images_backup")
            images_dst_app = os.path.abspath(IMAGES_FOLDER)
            if os.path.exists(images_src):
                if os.path.exists(images_dst_app): shutil.rmtree(images_dst_app)
                shutil.copytree(images_src, images_dst_app, dirs_exist_ok=True)
            self.root.after(0, lambda: self._update_restore_progress(increment_value=self.restore_steps[7][1]))
            
            # ETAP 8: Ponowne ładowanie konfiguracji i odświeżanie UI
            current_step_description_for_error = self.restore_steps[8][0]
            self.root.after(0, lambda: self._update_restore_progress(next_step_description=current_step_description_for_error))
            
            # Kolejność: Najpierw wczytaj dane, potem aktualizuj UI, które z nich korzysta
            self.config = load_config()
            self.settings = self.config.setdefault("settings", {})
            self.games = self.config.setdefault("games", {})
            self.groups = self.config.setdefault("groups", {})
            self.user = self.config.setdefault("user", {})
            self.mods_data = self.config.setdefault("mods_data", {})
            self.archive = self.config.setdefault("archive", [])
            self.roadmap = self.config.setdefault("roadmap", [])
            self._load_achievement_definitions() # To używa self.achievement_definitions

            # Napraw ścieżki i odśwież główne UI
            self.root.after(0, self.repair_save_paths)
            self.root.after(0, self.refresh_ui) # To odświeży większość UI
            self.root.after(0, self.show_home) # Pokaż stronę główną
            
            # Odświeżenie odtwarzacza muzyki (jeśli istnieje)
            if hasattr(self, 'music_player_page_instance') and self.music_player_page_instance:
                self.root.after(0, lambda: (
                    setattr(self.music_player_page_instance, 'named_playlists', self.local_settings.get("named_music_playlists", {})),
                    setattr(self.music_player_page_instance, 'active_playlist_name', self.local_settings.get("active_music_playlist_name")),
                    setattr(self.music_player_page_instance, 'current_track_index', self.local_settings.get("current_track_in_active_playlist_index", -1)),
                    setattr(self.music_player_page_instance, 'favorite_tracks', set(self.local_settings.get("music_favorite_tracks", []))),
                    self.music_player_page_instance._load_active_playlist(),
                    self.music_player_page_instance._update_available_playlists_ui(),
                    self.music_player_page_instance._update_playlist_display(),
                    self.music_player_page_instance.apply_theme_colors(),
                    (self.music_player_page_instance._update_now_playing_label() if self.music_player_page_instance.current_track_index != -1 
                     else self.music_player_page_instance._update_now_playing_label(track_name_override="Nic nie gra"))
                ))

            self.root.after(0, lambda: self._update_restore_progress(increment_value=self.restore_steps[8][1]))
            # --- Upewnij się, że pasek dochodzi do 100% ---
            self.root.after(100, lambda: self._update_restore_progress(next_step_description="Ukończono!", increment_value=(100 - self.total_progress_accumulator)))


        except json.JSONDecodeError as e:
            success = False
            error_message_details = f"Błąd odczytu pliku JSON ({current_step_description_for_error}): {e}"
            logging.error(error_message_details)
        except IOError as e: # Dla błędów kopiowania plików itp.
            success = False
            error_message_details = f"Błąd operacji plikowej ({current_step_description_for_error}): {e}"
            logging.error(error_message_details)
        except Exception as e:
            success = False
            error_message_details = f"Nie udało się w pełni wczytać backupu aplikacji ({current_step_description_for_error}): {e}"
            logging.exception(error_message_details)
        finally:
            self.root.after(200, self._destroy_progress_window) # Dajmy chwilę na zobaczenie 100%
            if success:
                self.root.after(250, lambda bp=target_music_library_base_path: messagebox.showinfo(
                    "Sukces", 
                    f"Przywrócono backup z wybranego folderu.\n\nŚcieżki muzyki zostały zaktualizowane i wskazują na wewnętrzną bibliotekę:\n{bp}",
                    parent=self.root
                ))
            else:
                final_error_msg = error_message_details if error_message_details else "Wystąpił nieznany błąd podczas przywracania."
                self.root.after(250, lambda em=final_error_msg: messagebox.showerror(
                    "Błąd Przywracania",
                    em,
                    parent=self.root
                ))

    def _save_tiles_per_row_setting(self):
        """Zapisuje ustawienie liczby kafelków i odświeża siatkę, jeśli trzeba."""
        try:
            value = self.tiles_per_row_var.get()
            if 2 <= value <= 8: # Walidacja zakresu
                 if self.local_settings.get("tiles_per_row") != value:
                      self.local_settings["tiles_per_row"] = value
                      save_local_settings(self.local_settings)
                      logging.info(f"Zmieniono liczbę kafelków w rzędzie na: {value}")
                      # Odśwież siatkę, jeśli aktualnie wyświetlana jest biblioteka w trybie kafelków
                      if self.current_frame == self.main_frame and self.library_view_mode.get() == 'tiles':
                           self.reset_and_update_grid()
            else:
                 # Przywróć poprzednią wartość w razie błędu
                 self.tiles_per_row_var.set(self.local_settings.get("tiles_per_row", 4))
                 logging.warning(f"Nieprawidłowa wartość dla kafelków w rzędzie: {value}")
        except tk.TclError: # Jeśli wartość w Spinboxie jest chwilowo niepoprawna
             self.tiles_per_row_var.set(self.local_settings.get("tiles_per_row", 4))
             logging.warning("Błąd odczytu wartości ze Spinboxa kafelków.")
        except Exception as e:
            logging.exception(f"Błąd podczas zapisywania ustawienia kafelków: {e}")
            self.tiles_per_row_var.set(self.local_settings.get("tiles_per_row", 4)) # Przywróć na wszelki wypadek

    def load_scan_folders_list(self):
        """Ładuje listę folderów do skanowania do listboxa w ustawieniach."""
        if hasattr(self, 'scan_folders_listbox') and self.scan_folders_listbox.winfo_exists():
            self.scan_folders_listbox.delete(0, tk.END)
            scan_folders = self.settings.get("scan_folders", [])
            for folder in scan_folders:
                self.scan_folders_listbox.insert(tk.END, folder)

    def add_scan_folder(self):
        """Otwiera dialog wyboru folderu i dodaje go do listy skanowania."""
        folder_selected = filedialog.askdirectory(title="Wybierz folder do skanowania")
        if folder_selected:
            scan_folders = self.settings.get("scan_folders", [])
            if folder_selected not in scan_folders:
                scan_folders.append(folder_selected)
                self.settings["scan_folders"] = scan_folders
                save_config(self.config)
                self.load_scan_folders_list() # Odśwież listbox
            else:
                messagebox.showwarning("Informacja", "Ten folder jest już na liście.")

    def remove_scan_folder(self):
        """Usuwa zaznaczony folder z listy skanowania."""
        selected_indices = self.scan_folders_listbox.curselection()
        if selected_indices:
            index = selected_indices[0]
            folder_to_remove = self.scan_folders_listbox.get(index)
            scan_folders = self.settings.get("scan_folders", [])
            if folder_to_remove in scan_folders:
                scan_folders.remove(folder_to_remove)
                self.settings["scan_folders"] = scan_folders
                save_config(self.config)
                self.load_scan_folders_list() # Odśwież listbox
        else:
            messagebox.showwarning("Błąd", "Nie wybrano folderu do usunięcia.")

    def save_scan_settings(self):
        """Zapisuje ustawienie skanowania rekursywnego."""
        self.settings["scan_recursively"] = self.scan_recursively_var.get()
        save_config(self.config)

    # Funkcja pomocnicza do czyszczenia nazwy folderu
    def guess_game_name_from_folder(self, folder_name):
        """Próbuje odgadnąć nazwę gry na podstawie nazwy folderu."""
        # Usuń popularne tagi i dodatki
        patterns_to_remove = [
            r'\[.*?\]',        # Usuń zawartość w nawiasach kwadratowych np. [CODEX]
            r'\(.*?\)',        # Usuń zawartość w nawiasach okrągłych np. (FitGirl Repack)
            r'v\d+(\.\d+)*',   # Usuń wersje np. v1.2.3
            r'\b(Repack|Update|Fix|Edition|GOTY|Gold|Definitive|Remastered)\b', # Usuń popularne słowa kluczowe (całe słowa)
            r'\b\d{4}\b',      # Usuń rok na końcu (jako całe słowo)
            r'[-_.]',          # Zamień myślniki, podkreślenia, kropki na spacje
        ]
        cleaned_name = folder_name
        for pattern in patterns_to_remove:
            cleaned_name = re.sub(pattern, '', cleaned_name, flags=re.IGNORECASE)

        # Usuń nadmiarowe spacje
        cleaned_name = ' '.join(cleaned_name.split()).strip()
        return cleaned_name if cleaned_name else folder_name # Zwróć oryginał jeśli nic nie zostało

    # Funkcja pomocnicza do znajdowania pliku exe
    def find_likely_executable(self, game_folder_path, guessed_name=""):
        """Próbuje znaleźć najbardziej prawdopodobny plik .exe gry w danym folderze (ulepszona wersja)."""
        potential_exes = []
        guessed_name_lower = guessed_name.lower()
        game_folder_name_lower = os.path.basename(game_folder_path).lower()

        # Heurystyka: Szukaj najpierw w folderze głównym i 'bin', potem reszta
        search_order = [game_folder_path]
        bin_folders = [os.path.join(game_folder_path, d) for d in ['bin', 'Binaries', 'Win32', 'Win64', 'x64', 'x86'] if os.path.isdir(os.path.join(game_folder_path, d))]
        search_order.extend(bin_folders)

        processed_roots = set(search_order)

        # 1. Przeszukaj foldery priorytetowe
        for folder in search_order:
            try:
                for item in os.listdir(folder):
                    item_path = os.path.join(folder, item)
                    if item.lower().endswith('.exe') and item.lower() not in self.find_likely_executable.ignore_files and os.path.isfile(item_path):
                        try:
                            size = os.path.getsize(item_path)
                            potential_exes.append({'path': item_path, 'size': size, 'name': item.lower(), 'depth': 0 if folder == game_folder_path else 1})
                        except OSError: continue
            except OSError: continue # Ignoruj błędy dostępu

        # 2. Przeszukaj resztę folderów (jeśli nic nie znaleziono lub dla pewności?) - na razie pomińmy dla wydajności
        # Można dodać os.walk dla pozostałych folderów, jeśli lista jest pusta

        if not potential_exes:
            logging.debug(f"Nie znaleziono żadnych plików .exe (poza ignorowanymi) w '{game_folder_path}' i jego podfolderach bin.")
            return None

        # Sortowanie z wieloma kryteriami
        def sort_key(exe_info):
            path = exe_info['path']
            name = exe_info['name']
            size = exe_info['size']
            depth = exe_info['depth'] # 0 = root, 1 = bin, etc.
            base_name = name[:-4] # Nazwa bez .exe

            # Najwyższy priorytet: nazwa exe DOKŁADNIE jak nazwa folderu gry
            score = 10 if base_name == game_folder_name_lower else 0

            # Wysoki priorytet: nazwa exe DOKŁADNIE jak odgadnięta nazwa gry
            if not score and base_name == guessed_name_lower: score = 9

            # Średni priorytet: nazwa exe zawiera odgadniętą nazwę LUB nazwa folderu zawiera nazwę exe
            if not score:
                 if guessed_name_lower and guessed_name_lower in base_name: score = 7
                 elif base_name in game_folder_name_lower: score = 6

            # Preferowane słowa kluczowe
            if not score and any(keyword in name for keyword in self.find_likely_executable.preferred_keywords):
                 score = 5

            # Preferuj pliki w folderze głównym (mniejsza głębokość)
            depth_bonus = (2 - depth) * 0.1 # Mały bonus za bycie wyżej

            # Ostateczny klucz: (wynik heurystyki, rozmiar, bonus za głębokość)
            # Sortujemy malejąco, więc większy wynik i rozmiar są lepsze
            return (score, size, depth_bonus)

        potential_exes.sort(key=sort_key, reverse=True)
        logging.debug(f"Posortowani kandydaci dla '{game_folder_path}': {potential_exes}")

        # Zwróć najlepszego kandydata
        best_candidate_path = potential_exes[0]['path']
        logging.info(f"Wybrano najlepszy kandydat .exe dla '{guessed_name}': {best_candidate_path}")
        return best_candidate_path


    # --- NOWE ZMIANY: Metoda start_scan_thread ---
    def start_scan_thread(self):
        """Uruchamia skanowanie folderów w osobnym wątku."""
        scan_folders = self.settings.get("scan_folders", [])
        if not scan_folders:
            messagebox.showinfo("Informacja", "Nie zdefiniowano żadnych folderów do skanowania. Dodaj je w ustawieniach.")
            return

        # Sprawdź, czy inne okno postępu już nie istnieje
        if hasattr(self, 'progress_window') and self.progress_window.winfo_exists():
            messagebox.showwarning("Skanowanie w toku", "Inna operacja (np. synchronizacja, skanowanie) jest już w toku.")
            return

        self.show_progress_window("Skanowanie folderów...")
        self.progress_bar['mode'] = 'indeterminate'
        self.progress_bar.start()
        self.progress_label.config(text="Rozpoczynanie...")

        # Uruchom wątek skanowania
        scan_thread = threading.Thread(target=self.scan_folders_for_games, daemon=True)
        scan_thread.start()

    # --- NOWE ZMIANY: Przepisana metoda scan_folders_for_games ---
    def scan_folders_for_games(self):
        """Skanuje zdefiniowane foldery w poszukiwaniu gier i prezentuje wyniki do weryfikacji."""
        scan_folders_config = self.settings.get("scan_folders", [])
        scan_recursively = self.settings.get("scan_recursively", True)
        ignored_folder_names = set(name.lower() for name in self.settings.get("scan_ignore_folders", []))
        logging.info(f"Rozpoczynanie skanowania. Foldery: {scan_folders_config}, Rekursywnie: {scan_recursively}, Ignorowane: {ignored_folder_names}")

        potential_new_games = [] # Lista słowników dla okna weryfikacji

        try:
            all_potential_folders = set()

            # 1. Zbierz listę folderów do sprawdzenia
            for base_folder in scan_folders_config:
                self.root.after(0, lambda bf=base_folder: self.progress_label.config(text=f"Analiza: {bf}"))
                if not os.path.isdir(base_folder):
                    logging.warning(f"Folder skanowania '{base_folder}' nie istnieje lub nie jest folderem.")
                    continue

                # Sprawdź, czy sam base_folder ma być traktowany jako folder gry
                # Heurystyka: jeśli zawiera plik .exe (poza ignorowanymi)
                contains_exe = False
                try:
                     for item in os.listdir(base_folder):
                          if item.lower().endswith('.exe') and item.lower() not in self.find_likely_executable.ignore_files:
                               contains_exe = True
                               break
                except OSError as e:
                     logging.warning(f"Nie można odczytać zawartości folderu '{base_folder}': {e}")

                if contains_exe and os.path.basename(base_folder).lower() not in ignored_folder_names:
                     all_potential_folders.add(os.path.abspath(base_folder))
                     logging.debug(f"Dodano '{base_folder}' (sam folder bazowy) jako potencjalny folder gry.")

                # Przejdź przez podfoldery (jeśli rekursywnie lub tylko pierwszy poziom)
                if scan_recursively:
                    for root, dirs, files in os.walk(base_folder, topdown=True):
                        # Modyfikuj dirs w miejscu, aby pominąć ignorowane
                        dirs[:] = [d for d in dirs if d.lower() not in ignored_folder_names]
                        # Dodaj nieignorowane foldery z bieżącego poziomu
                        for d in dirs:
                            folder_path = os.path.abspath(os.path.join(root, d))
                            all_potential_folders.add(folder_path)
                else: # Tylko pierwszy poziom
                    try:
                         for item in os.listdir(base_folder):
                              item_path = os.path.abspath(os.path.join(base_folder, item))
                              if os.path.isdir(item_path) and item.lower() not in ignored_folder_names:
                                  all_potential_folders.add(item_path)
                    except OSError as e:
                        logging.warning(f"Nie można odczytać zawartości folderu '{base_folder}': {e}")


            # 2. Przetwórz potencjalne foldery
            sorted_potential_folders = sorted(list(all_potential_folders))
            logging.info(f"Znaleziono {len(sorted_potential_folders)} unikalnych potencjalnych folderów do sprawdzenia.")
            total_folders = len(sorted_potential_folders)

            for i, folder_path in enumerate(sorted_potential_folders):
                # Sprawdzenie ignorowania dla pewności
                if os.path.basename(folder_path).lower() in ignored_folder_names:
                    logging.debug(f"Pomijanie ignorowanego folderu (ostateczne sprawdzenie): {folder_path}")
                    continue

                # Aktualizacja postępu (mniej szczegółowa)
                self.root.after(0, lambda p=folder_path: self.progress_label.config(text=f"Sprawdzanie: {os.path.basename(p)} ({i+1}/{total_folders})"))

                guessed_name = self.guess_game_name_from_folder(os.path.basename(folder_path))

                # Sprawdź czy gra już istnieje w bibliotece
                if guessed_name.lower() in (name.lower() for name in self.games.keys()):
                    logging.info(f"Pominięto (już w bibliotece): {guessed_name} ({folder_path})")
                    continue
                # Sprawdź, czy już dodaliśmy grę o tej nazwie w tym skanowaniu
                if any(g['guessed_name'].lower() == guessed_name.lower() for g in potential_new_games):
                     logging.info(f"Pominięto (duplikat w tym skanowaniu): {guessed_name} ({folder_path})")
                     continue

                executable_path = self.find_likely_executable(folder_path, guessed_name)

                if executable_path:
                    logging.info(f"Znaleziono potencjalną grę: '{guessed_name}' w '{folder_path}' -> {executable_path}")
                    potential_new_games.append({
                        "guessed_name": guessed_name,
                        "folder_path": folder_path,
                        "suggested_exe_path": executable_path,
                        "import": True, # Domyślnie zaznaczone do importu
                        "profiles": [{"name": "Default", "exe_path": None, "arguments": ""}] # Zaczynamy z domyślnym (None exe oznacza użycie suggested_exe_path)
                    })
                else:
                    logging.warning(f"Nie znaleziono pliku .exe dla: {folder_path} (Zgadnięta nazwa: {guessed_name})")


            # 3. Zakończenie i pokazanie wyników
            self.root.after(0, self.stop_scan_progress) # Zatrzymaj pasek postępu

            if potential_new_games:
                logging.info(f"Zakończono skanowanie. Znaleziono {len(potential_new_games)} potencjalnych nowych gier. Otwieranie okna weryfikacji.")
                # Wywołaj okno weryfikacji w głównym wątku
                self.root.after(100, lambda games=potential_new_games: self.show_scan_verification_window(games))
            else:
                logging.info("Skanowanie zakończone. Nie znaleziono żadnych nowych gier.")
                self.root.after(0, lambda: messagebox.showinfo("Skanowanie Zakończone", "Nie znaleziono żadnych nowych gier do dodania."))

        except Exception as e:
            logging.exception("Krytyczny błąd podczas skanowania folderów.")
            # Upewnij się, że okno postępu jest zamknięte
            self.root.after(0, self.stop_scan_progress)
            self.root.after(0, lambda err=e: messagebox.showerror("Błąd Skanowania", f"Wystąpił nieoczekiwany błąd: {err}"))

    # --- NOWE ZMIANY: Metoda do pokazania okna weryfikacji ---
    def show_scan_verification_window(self, potential_games):
        """Otwiera okno weryfikacji znalezionych gier."""
        verification_window = ScanVerificationWindow(self.root, self, potential_games)
        # Nie używamy wait_window, bo główna aplikacja ma działać dalej


    # --- NOWE ZMIANY: Poprawiona `find_likely_executable` ---
    # Dodajemy statyczne atrybuty, aby uniknąć ich tworzenia za każdym razem
    find_likely_executable.ignore_dirs = {'_commonredist', 'directx', 'dotnet', 'redist', 'tools', 'benchmark', 'support', 'data', 'profiles', 'config', 'save', 'logs'}
    find_likely_executable.ignore_files = {'setup.exe', 'uninstall.exe', 'unins000.exe', 'unins001.exe', 'launcher.exe', 'crashreporter.exe', 'configtool.exe', 'activation.exe'}
    find_likely_executable.preferred_keywords = ['game', 'shipping', 'retail'] # Słowa kluczowe podnoszące priorytet

    def update_scan_progress(self, percent, current_folder):
         if hasattr(self, 'progress_bar') and self.progress_bar.winfo_exists():
            if self.progress_bar['mode'] == 'indeterminate':
                self.progress_bar.stop()
                self.progress_bar['mode'] = 'determinate'
            self.progress_bar['value'] = percent
            self.progress_label.config(text=f"{percent}% - {current_folder}")
            self.progress_window.update_idletasks()

    def stop_scan_progress(self):
        if hasattr(self, 'progress_window') and self.progress_window.winfo_exists():
             if self.progress_bar['mode'] == 'indeterminate':
                 self.progress_bar.stop()
             self.progress_window.destroy()

    def parse_folder_name_metadata(self, folder_name):
        """Próbuje wyciągnąć rok i wydawcę z nazwy folderu."""
        metadata = {}
        # Prosty wzorzec na rok w nawiasach np. (2023) lub na końcu
        year_match = re.search(r'(\b(19[8-9]\d|20\d\d)\b)', folder_name)
        if year_match:
            metadata['year'] = year_match.group(1)
            logging.info(f"Znaleziono rok w nazwie folderu '{folder_name}': {metadata['year']}")

        # Prosty wzorzec na wydawcę w nawiasach kwadratowych np. [Ubisoft]
        # To jest bardzo podstawowe, wymagałoby lepszego dopasowania
        publisher_match = re.search(r'\[([^\]]+)\]', folder_name)
        if publisher_match:
             potential_publisher = publisher_match.group(1)
             # Podstawowa walidacja - unikaj np. [CODEX], [PLAZA]
             if potential_publisher.upper() not in ['CODEX', 'PLAZA', 'SKIDROW', 'FLT', 'RELOADED', 'CPY']:
                 metadata['publisher'] = potential_publisher
                 logging.info(f"Znaleziono potencjalnego wydawcę w nazwie folderu '{folder_name}': {metadata['publisher']}")

        return metadata

    def parse_nfo_file(self, game_folder_path):
        """Próbuje znaleźć i sparsować plik .nfo w folderze gry (bardziej elastycznie)."""
        nfo_file = None
        # Szukaj plików .nfo lub .txt (czasem informacje są w .txt)
        for filename in os.listdir(game_folder_path):
            if filename.lower().endswith(('.nfo', '.txt')): # Dodano .txt
                # Unikaj dużych plików tekstowych, które raczej nie są NFO
                try:
                    f_path = os.path.join(game_folder_path, filename)
                    if os.path.getsize(f_path) < 5 * 1024 * 1024: # Limit 5MB
                         nfo_file = f_path
                         if filename.lower().endswith('.nfo'): # Preferuj .nfo
                            break
                except OSError:
                    continue # Pomiń jeśli błąd dostępu/rozmiaru

        if not nfo_file:
            logging.info(f"Nie znaleziono odpowiedniego pliku .nfo/.txt w {game_folder_path}")
            return None

        logging.info(f"Znaleziono plik do parsowania: {nfo_file}")
        encodings_to_try = ['cp437', 'utf-8', 'latin-1', 'cp1250', 'cp1252'] # Dodano więcej kodowań
        nfo_content = None
        for enc in encodings_to_try:
            try:
                with open(nfo_file, 'r', encoding=enc) as f:
                    nfo_content = f.read()
                logging.info(f"Odczytano plik '{os.path.basename(nfo_file)}' używając kodowania: {enc}")
                break
            except UnicodeDecodeError:
                logging.warning(f"Nieudany odczyt pliku '{os.path.basename(nfo_file)}' z kodowaniem {enc}")
                continue
            except Exception as e:
                logging.error(f"Błąd odczytu pliku '{os.path.basename(nfo_file)}' ({enc}): {e}")
                # Nie zwracaj None od razu, spróbuj innych plików jeśli są

        if not nfo_content:
            logging.error(f"Nie udało się odczytać zawartości żadnego pliku .nfo/.txt w {game_folder_path}")
            return None

        # --- Parsowanie zawartości ---
        metadata = {}
        lines = nfo_content.splitlines()

        # 1. Szukanie standardowych wzorców Klucz: Wartość
        patterns = {
            'title': r'^\s*(?:Title|Game Name)\s*:\s*(.+)',
            'publisher': r'^\s*Publisher\s*:\s*(.+)',
            'developer': r'^\s*Developer\s*:\s*(.+)',
            'release_date': r'^\s*(?:Release Date|Date)\s*:\s*(.+)', # Dodano "Date"
            'genre': r'^\s*Genre\s*:\s*(.+)',
            'version': r'^\s*Version\s*:\s*(.+)', # Dodano wzorzec dla wersji
        }
        found_keys = set()
        for key, pattern in patterns.items():
            for line in lines:
                match = re.match(pattern, line, re.IGNORECASE)
                if match:
                    value = match.group(1).strip()
                    if value: # Zapisz tylko jeśli wartość nie jest pusta
                        metadata[key] = value
                        found_keys.add(key)
                        logging.info(f"[Pattern Match] Znaleziono w pliku - {key}: {metadata[key]}")
                        break # Bierzemy pierwsze dopasowanie dla danego klucza

        # 2. Logika rezerwowa (Fallback) dla brakujących pól
        logging.info("Uruchamianie logiki rezerwowej dla brakujących pól NFO...")

        # Fallback dla tytułu: pierwsza niepusta linia, która nie jest dekoracją ASCII art
        if 'title' not in found_keys:
            for line in lines:
                cleaned_line = line.strip()
                # Prosta heurystyka - ignoruj linie z wieloma powtarzającymi się znakami specjalnymi
                if cleaned_line and len(cleaned_line) > 3 and not re.match(r'^[\s\W_]*[-=_*#<>/\\]{3,}[\s\W_]*$', cleaned_line):
                    metadata['title'] = cleaned_line
                    logging.info(f"[Fallback] Użyto pierwszej linii jako tytułu: {metadata['title']}")
                    break

        # Fallback dla daty/roku: szukaj (YYYY) lub YYYY w tekście
        if 'release_date' not in found_keys:
             year_match = re.search(r'\b(19[8-9]\d|20\d\d)\b', nfo_content)
             if year_match:
                 metadata['release_date'] = year_match.group(1)
                 logging.info(f"[Fallback] Znaleziono rok w treści: {metadata['release_date']}")

        # Fallback dla wydawcy: szukaj [PublisherName]
        if 'publisher' not in found_keys:
            publisher_match = re.search(r'\[([^\]]+)\]', nfo_content)
            if publisher_match:
                 potential_publisher = publisher_match.group(1).strip()
                 # Podstawowa walidacja - unikaj scenowych tagów
                 if potential_publisher.upper() not in ['CODEX', 'PLAZA', 'SKIDROW', 'FLT', 'RELOADED', 'CPY', 'STEAM', 'GOG']:
                     metadata['publisher'] = potential_publisher
                     logging.info(f"[Fallback] Znaleziono potencjalnego wydawcę w treści: {metadata['publisher']}")

        # --- Koniec Parsowania ---

        # Zwróć tylko jeśli coś znaleziono
        if metadata:
            logging.info(f"Finalne sparsowane metadane z '{os.path.basename(nfo_file)}': {metadata}")
            return metadata
        else:
            logging.warning(f"Nie udało się sparsować żadnych użytecznych danych z pliku: {nfo_file}")
            return None # Zwróć None jeśli nic nie znaleziono

# W klasie GameLauncher

    # W klasie GameLauncher:

    def _add_edit_achievement_def(self, edit_mode=False, parent_window=None):
        """Otwiera okno dialogowe do dodawania lub edycji definicji osiągnięcia."""
        if parent_window is None:
             parent_window = self.achievements_frame # Domyślnie strona Osiągnięć

        initial_data = None
        original_id = None # Przechowuje oryginalne ID podczas edycji

        if edit_mode:
            # Użyj drzewa definicji z TEJ STRONY
            if not hasattr(self, 'achievements_def_tree') or not self.achievements_def_tree.winfo_exists():
                 messagebox.showerror("Błąd", "Lista definicji osiągnięć nie jest dostępna.", parent=parent_window)
                 return
            selection = self.achievements_def_tree.selection()
            if not selection:
                messagebox.showwarning("Brak zaznaczenia", "Zaznacz osiągnięcie na liście poniżej, które chcesz edytować.", parent=parent_window)
                return
            original_id = selection[0] # iid to ID osiągnięcia
            # Znajdź dane dla original_id w self.achievement_definitions
            initial_data = next((item for item in self.achievement_definitions if item.get("id") == original_id), None)
            if not initial_data:
                 messagebox.showerror("Błąd", f"Nie znaleziono danych dla osiągnięcia o ID: {original_id}", parent=parent_window)
                 return
            initial_data = initial_data.copy() # Pracuj na kopii

        # Otwórz okno dialogowe AchievementForm
        dialog = AchievementForm(parent_window, initial_data, launcher_instance=self) # Użyj parent_window i przekaż self

        if dialog.result:
            new_ach_data = dialog.result
            new_id = new_ach_data.get("id")

            # Sprawdź unikalność ID (ponownie, na wypadek gdyby edytor pozwolił zmienić ID na istniejące)
            for i, existing_ach in enumerate(self.achievement_definitions):
                # Jeśli edytujemy, pomiń sprawdzanie samego siebie (chyba że ID zostało zmienione)
                if edit_mode and existing_ach.get("id") == original_id and new_id == original_id:
                    continue
                if existing_ach.get("id") == new_id:
                    messagebox.showerror("Błąd ID", f"Osiągnięcie o ID '{new_id}' już istnieje!", parent=parent_window)
                    return # Nie zapisuj

            # Zaktualizuj listę definicji w pamięci
            if edit_mode and original_id:
                # Znajdź indeks starego i zamień
                found = False
                for i, ach in enumerate(self.achievement_definitions):
                     if ach.get("id") == original_id:
                          self.achievement_definitions[i] = new_ach_data
                          found = True
                          break
                if not found: # Na wszelki wypadek, gdyby coś poszło nie tak
                     self.achievement_definitions.append(new_ach_data)
            else: # Dodawanie nowego
                self.achievement_definitions.append(new_ach_data)

            # Zapisz zaktualizowaną listę do pliku JSON
            if self._save_achievement_definitions_to_file():
                 self._load_achievement_def_list() # Odśwież listę w ustawieniach
                 # Odśwież stronę osiągnięć, jeśli jest widoczna
                 if hasattr(self, 'achievements_frame') and self.current_frame == self.achievements_frame:
                      self.create_achievements_page()
            else:
                 # Jeśli zapis się nie powiódł, cofnij zmiany w pamięci?
                 # Na razie tylko logujemy błąd, _save... pokaże messagebox
                 logging.error("Zapis definicji osiągnięć nie powiódł się. Zmiany w pamięci mogą nie odpowiadać plikowi.")

    def create_achievements_page(self):
        """Tworzy interfejs strony Osiągnięć (z postępem i zarządzaniem definicjami)."""
        logging.debug("Rozpoczynanie tworzenia strony osiągnięć...")

        # --- BARDZIEJ AGRESYWNE CZYSZCZENIE ---
        if hasattr(self, 'achievements_frame') and self.achievements_frame.winfo_exists():
            logging.debug("Czyszczenie istniejącej ramki achievements_frame...")
            for widget in self.achievements_frame.winfo_children():
                # --- Dodano try-except dla bezpieczeństwa przy destroy ---
                try:
                    widget.destroy()
                except tk.TclError as e:
                    logging.warning(f"Błąd TclError podczas niszczenia widgetu w achievements_frame: {e}")
                except Exception as e:
                    logging.exception(f"Nieoczekiwany błąd podczas niszczenia widgetu: {e}")
            # --- Koniec try-except ---
        else:
            logging.debug("Tworzenie nowej ramki achievements_frame.")
            self.achievements_frame = ttk.Frame(self.root, style="TFrame")
            self.achievements_frame.grid(row=0, column=1, sticky="nsew")
        # --- KONIEC AGRESYWNEGO CZYSZCZENIA ---

        # Konfiguracja głównej ramki
        self.achievements_frame.columnconfigure(0, weight=1)
        self.achievements_frame.rowconfigure(0, weight=1) # Sekcja postępu rośnie
        self.achievements_frame.rowconfigure(1, weight=0) # Sekcja zarządzania stała

        # === Sekcja 1: Postęp Osiągnięć Użytkownika ===
        progress_frame = ttk.Frame(self.achievements_frame)
        progress_frame.grid(row=0, column=0, columnspan=2, sticky="nsew") # columnspan=2 by objąć scrollbar
        progress_frame.columnconfigure(0, weight=1)
        progress_frame.rowconfigure(1, weight=1) # Canvas rośnie

# Nagłówek postępu
        header_frame = ttk.Frame(progress_frame)
        header_frame.grid(row=0, column=0, columnspan=2, sticky="ew", padx=10, pady=(10, 5))
        header_frame.columnconfigure(0, weight=1)
        ttk.Label(header_frame, text="Twoje Osiągnięcia", font=("Helvetica", 16, "bold")).grid(row=0, column=0, sticky="w")

        # --- POPRAWIONA LOGIKA LICZNIKA ---
        # Upewnij się, że definicje są załadowane
        if not hasattr(self, 'achievement_definitions'):
            self._load_achievement_definitions()

        # Pobierz ID wszystkich aktualnie zdefiniowanych osiągnięć
        defined_ids = set()
        if hasattr(self, 'achievement_definitions') and self.achievement_definitions:
            defined_ids = {ach_def.get("id") for ach_def in self.achievement_definitions if ach_def.get("id")}

        # Pobierz dane postępu użytkownika
        user_progress = self.user.get("achievements", {})

        # Licz odblokowane tylko te, które istnieją w definicjach
        unlocked_count = 0
        if defined_ids and user_progress: # Sprawdź, czy mamy co liczyć
            unlocked_count = len([
                ach_id for ach_id, progress_data in user_progress.items()
                if progress_data.get("unlocked") and ach_id in defined_ids # KLUCZOWY WARUNEK: musi istnieć w definicjach
            ])

        # Całkowita liczba zdefiniowanych osiągnięć
        total_count = len(defined_ids)
        # --- KONIEC POPRAWIONEJ LOGIKI LICZNIKA ---

        # Wyświetl poprawny licznik
        ttk.Label(header_frame, text=f"Odblokowano: {unlocked_count} / {total_count}").grid(row=0, column=1, sticky="e", padx=10)

        # Przewijalny obszar na listę postępów (tworzony od nowa)
        ach_canvas = tk.Canvas(progress_frame, bg="#1e1e1e", highlightthickness=0)
        ach_scrollbar = ttk.Scrollbar(progress_frame, orient="vertical", command=ach_canvas.yview)
        # --- Tworzymy scrollable_ach_frame ZA KAŻDYM RAZEM ---
        self.scrollable_ach_frame = ttk.Frame(ach_canvas, style="TFrame")
        # --- Koniec ---
        scrollable_ach_frame_window_id = ach_canvas.create_window((0, 0), window=self.scrollable_ach_frame, anchor="nw")

        # Bindowania dla canvasu i scrollbara
        def _configure_ach_canvas(event):
            if ach_canvas.winfo_exists() and self.scrollable_ach_frame.winfo_exists():
                canvas_width = event.width
                ach_canvas.itemconfig(scrollable_ach_frame_window_id, width=canvas_width)
                ach_canvas.configure(scrollregion=ach_canvas.bbox("all"))
        ach_canvas.bind("<Configure>", _configure_ach_canvas)
        self.scrollable_ach_frame.bind("<Configure>", lambda e: ach_canvas.configure(scrollregion=ach_canvas.bbox("all")) if ach_canvas.winfo_exists() else None)

# W metodzie create_achievements_page:
        # --- POCZĄTEK ZMIAN W _on_ach_mousewheel ---
        def _on_ach_mousewheel(event):
            widget_under_cursor = None # Zainicjuj jako None
            try:
                 # Użyj self.root do znalezienia widgetu, przechwyć potencjalne błędy
                 widget_under_cursor = self.root.winfo_containing(event.x_root, event.y_root)
            except (tk.TclError, KeyError) as e:
                 # Zignoruj błąd TclError (np. kursor poza oknem) lub KeyError (np. 'popdown')
                 logging.debug(f"Ignorowany błąd w winfo_containing (achievements): {e}")
                 widget_under_cursor = None # Upewnij się, że jest None w razie błędu

            # Sprawdź, czy widget pod kursorem to ach_canvas lub jego zawartość
            is_ach_area = False
            curr = widget_under_cursor
            while curr is not None:
                # --- Sprawdź, czy scrollable_ach_frame istnieje przed porównaniem ---
                if curr == ach_canvas or (hasattr(self, 'scrollable_ach_frame') and curr == self.scrollable_ach_frame):
                     is_ach_area = True
                     break
                # --- Koniec sprawdzenia ---
                if curr == self.root: # Zatrzymaj, jeśli dojdziemy do głównego okna
                     break
                try:
                     curr = curr.master # Idź w górę hierarchii
                except tk.TclError: # Na wypadek zniszczonego widgetu
                     break

            # Przewijaj tylko jeśli kursor jest nad właściwym obszarem i canvas istnieje
            if is_ach_area and ach_canvas.winfo_exists():
                scroll_val = -1 * int(event.delta / 120)
                try: # Dodatkowe zabezpieczenie wokół yview
                    view_start, view_end = ach_canvas.yview()
                    # Sprawdź poprawność wartości yview przed przewinięciem
                    if 0.0 <= view_start <= 1.0 and 0.0 <= view_end <= 1.0:
                        # Przewiń tylko, jeśli nie jesteśmy na granicy
                        if (scroll_val < 0 and view_start > 0.0) or (scroll_val > 0 and view_end < 1.0):
                            ach_canvas.yview_scroll(scroll_val, "units")
                            return "break" # Zatrzymaj propagację zdarzenia po przewinięciu
                    else:
                        logging.warning("Niespójny stan yview dla ach_canvas")
                except tk.TclError as e:
                     logging.warning(f"Błąd TclError podczas sprawdzania/przewijania yview dla ach_canvas: {e}")
        # --- KONIEC ZMIAN W _on_ach_mousewheel ---

        # Zamiast bind_all, użyj bind dla tego konkretnego canvasu,
        # co może pomóc uniknąć konfliktów, ale bind_all z return "break" też jest OK.
        # Jeśli nadal są problemy, spróbuj zmienić poniższą linię na:
        # ach_canvas.bind("<MouseWheel>", _on_ach_mousewheel)
        ach_canvas.bind_all("<MouseWheel>", _on_ach_mousewheel, add='+') # Zostawiamy na razie add='+'


        ach_canvas.configure(yscrollcommand=ach_scrollbar.set)
        ach_canvas.grid(row=1, column=0, sticky="nsew", padx=10, pady=5)
        ach_scrollbar.grid(row=1, column=1, sticky="ns", pady=5)
        self.scrollable_ach_frame.columnconfigure(1, weight=1) # Kolumna z tekstem rośnie

        # --- Wypełnij NOWĄ ramkę postępami osiągnięć ---
        logging.debug("Wypełnianie nowo utworzonej scrollable_ach_frame...")
        user_achievements = self.user.get("achievements", {})
        self._ach_icons = {} # Cache ikon

        # Upewnij się, że definicje istnieją przed sortowaniem
        if not hasattr(self, 'achievement_definitions') or not self.achievement_definitions:
             logging.warning("Brak definicji osiągnięć do wyświetlenia.")
             ttk.Label(self.scrollable_ach_frame, text="(Brak zdefiniowanych osiągnięć)").grid(pady=20)
             sorted_definitions = [] # Pusta lista, aby pętla się nie wykonała
        else:
             # Sortuj definicje np. alfabetycznie według nazwy
             sorted_definitions = sorted(self.achievement_definitions, key=lambda x: x.get("name", x.get("id", "")))

        if not sorted_definitions: # Dodatkowe sprawdzenie po sortowaniu
            logging.debug("Lista posortowanych definicji jest pusta.")
            if not self.scrollable_ach_frame.winfo_children(): # Pokaż wiadomość tylko jeśli nic tam nie ma
                ttk.Label(self.scrollable_ach_frame, text="(Brak zdefiniowanych osiągnięć)").grid(pady=20)

        for idx, ach_def in enumerate(sorted_definitions):
            ach_id = ach_def.get("id")
            if not ach_id: continue

            # Pobierz pełne dane postępu (lub utwórz domyślne)
            ach_progress_data = user_achievements.get(ach_id, {"unlocked": False, "timestamp": None, "current_progress": 0})
            is_unlocked = ach_progress_data.get("unlocked")
            timestamp = ach_progress_data.get("timestamp") if is_unlocked else None
            current_progress = ach_progress_data.get("current_progress", 0)
            target_value = ach_def.get("target_value", 1) # Użyj 1 jako minimum

            # Dodaj separator (zaczynając od drugiego elementu)
            if idx > 0:
                 ttk.Separator(self.scrollable_ach_frame, orient='horizontal').grid(row=idx*2 -1, column=0, columnspan=2, sticky='ew', padx=10, pady=5)

            # Ramka dla pojedynczego osiągnięcia
            item_frame = ttk.Frame(self.scrollable_ach_frame, padding=5, style="Game.TFrame")
            item_frame.grid(row=idx*2, column=0, columnspan=2, sticky="ew", pady=(0, 5), padx=5)
            item_frame.columnconfigure(1, weight=1) # Kolumna z tekstem rośnie

            # Ikona
            icon_path = ach_def.get("icon"); icon_label = ttk.Label(item_frame, width=8); icon_label.grid(row=0, column=0, rowspan=3, padx=(0, 10), sticky="ns") # rowspan=3
            if icon_path:
                if icon_path not in self._ach_icons:
                     try:
                         img = Image.open(icon_path); icon_size = (48, 48); img.thumbnail(icon_size, resampling)
                         if not is_unlocked: img = img.convert("L").convert("RGBA")
                         photo = ImageTk.PhotoImage(img); self._ach_icons[icon_path] = photo
                     except Exception as e: logging.error(f"Nie można załadować ikony '{icon_path}': {e}"); self._ach_icons[icon_path] = None
                if self._ach_icons[icon_path]: icon_label.config(image=self._ach_icons[icon_path]); icon_label.image = self._ach_icons[icon_path]
                else: icon_label.config(text="(brak\nikony)", font=("Segoe UI", 7), anchor='center')
            else: icon_label.config(text="")

            # Nazwa Osiągnięcia
            name_text = ach_def.get("name", ach_id); name_color = "white" if is_unlocked else "gray"
            name_label = ttk.Label(item_frame, text=name_text, font=("Helvetica", 11, "bold"), foreground=name_color); name_label.grid(row=0, column=1, sticky="w")

            # Opis
            desc_text = ach_def.get("description", ""); desc_color = "white" if is_unlocked else "gray"
            desc_label = ttk.Label(item_frame, text=desc_text, wraplength=600, justify=tk.LEFT, font=("Segoe UI", 9), foreground=desc_color); desc_label.grid(row=1, column=1, sticky="w")

            # Pasek postępu lub data odblokowania
            if is_unlocked and timestamp:
                unlock_date = datetime.datetime.fromtimestamp(timestamp).strftime('%Y-%m-%d %H:%M')
                unlock_label = ttk.Label(item_frame, text=f"Odblokowano: {unlock_date}", font=("Segoe UI", 8, "italic"), foreground="lightgreen")
                unlock_label.grid(row=2, column=1, sticky="w", pady=(2,0))
            elif not is_unlocked: # Zawsze pokazuj postęp dla nieodblokowanych
                            progress_value = min(current_progress, target_value) if target_value > 0 else 0
                            max_progress = target_value if target_value > 0 else 1

                            progress_widget_frame = ttk.Frame(item_frame)
                            progress_widget_frame.grid(row=2, column=1, sticky="ew", pady=(2,0)) # Użyj row=2
                            progress_widget_frame.columnconfigure(0, weight=1) # Pasek się rozciąga

                            # Pasek postępu
                            pbar = ttk.Progressbar(
                                progress_widget_frame,
                                orient='horizontal',
                                length=200, # Można dostosować długość
                                mode='determinate',
                                maximum=max_progress,
                                value=progress_value,
                                style="custom.Horizontal.TProgressbar" # Użyj stylu, jeśli go zdefiniowałeś
                            )
                            pbar.grid(row=0, column=0, sticky="ew", pady=(2, 2)) # Dodano pady

                            # Tekst postępu
                            progress_text = ""
                            if isinstance(target_value, int) and isinstance(current_progress, int):
                                progress_text = f"{current_progress} / {target_value}"
                            elif isinstance(target_value, float) or isinstance(current_progress, float):
                                progress_text = f"{current_progress:.1f} / {target_value:.1f}" # Format dla float
                            else: # Fallback
                                progress_text = f"{current_progress} / {target_value}"

                            progress_label = ttk.Label(progress_widget_frame, text=progress_text, font=("Segoe UI", 8), foreground="gray")
                            progress_label.grid(row=0, column=1, sticky="w", padx=(5,0), pady=(2, 2)) # Dodano pady


        # === Sekcja 2: Zarządzanie Definicjami Osiągnięć ===
        manage_def_frame = ttk.LabelFrame(self.achievements_frame, text=" Zarządzaj Definicjami ", padding=(10, 5))
        manage_def_frame.grid(row=1, column=0, columnspan=2, sticky="nsew", padx=10, pady=(10, 5))
        manage_def_frame.columnconfigure(0, weight=1)
        manage_def_frame.rowconfigure(0, weight=0) # Stała wysokość dla listy definicji

        # Ramka dla Treeview i Scrollbara
        ach_def_list_frame = ttk.Frame(manage_def_frame)
        ach_def_list_frame.grid(row=0, column=0, sticky="ew", pady=5, padx=5)
        ach_def_list_frame.columnconfigure(0, weight=1); ach_def_list_frame.rowconfigure(0, weight=0)

        # Treeview do wyświetlania i WYBIERANIA definicji
        ach_cols = ("ID", "Nazwa", "Opis", "Warunek");
        self.achievements_def_tree = ttk.Treeview(ach_def_list_frame, columns=ach_cols, show="headings", height=5, selectmode="browse") # Zmniejszono wysokość
        self.achievements_def_tree.heading("ID", text="ID"); self.achievements_def_tree.column("ID", width=120, anchor=tk.W, stretch=False)
        self.achievements_def_tree.heading("Nazwa", text="Nazwa"); self.achievements_def_tree.column("Nazwa", width=180, anchor=tk.W)
        self.achievements_def_tree.heading("Opis", text="Opis"); self.achievements_def_tree.column("Opis", width=250, anchor=tk.W)
        self.achievements_def_tree.heading("Warunek", text="Warunek"); self.achievements_def_tree.column("Warunek", width=150, anchor=tk.W)
        ach_def_scrollbar_y = ttk.Scrollbar(ach_def_list_frame, orient="vertical", command=self.achievements_def_tree.yview)
        ach_def_scrollbar_x = ttk.Scrollbar(ach_def_list_frame, orient="horizontal", command=self.achievements_def_tree.xview)
        self.achievements_def_tree.configure(yscrollcommand=ach_def_scrollbar_y.set, xscrollcommand=ach_def_scrollbar_x.set)
        self.achievements_def_tree.grid(row=0, column=0, sticky="ew")
        ach_def_scrollbar_y.grid(row=0, column=1, sticky="ns")
        ach_def_scrollbar_x.grid(row=1, column=0, columnspan=2, sticky="ew")

        # Przyciski zarządzania
        ach_def_buttons_frame = ttk.Frame(manage_def_frame)
        ach_def_buttons_frame.grid(row=2, column=0, pady=(5, 10))
        ttk.Button(ach_def_buttons_frame, text="Dodaj Nowe", command=lambda: self._add_edit_achievement_def(parent_window=self.achievements_frame)).pack(side=tk.LEFT, padx=5)
        ttk.Button(ach_def_buttons_frame, text="Edytuj Zaznaczone", command=lambda: self._add_edit_achievement_def(edit_mode=True, parent_window=self.achievements_frame)).pack(side=tk.LEFT, padx=5)
        ttk.Button(ach_def_buttons_frame, text="Usuń Zaznaczone", command=self._delete_achievement_def).pack(side=tk.LEFT, padx=5)
        ttk.Button(ach_def_buttons_frame, text="Odśwież Definicje", command=self._reload_definitions_and_refresh_ui).pack(side=tk.RIGHT, padx=5)

        # Wczytaj listę definicji do dolnego Treeview
        self._load_achievement_def_list() # Upewnij się, że ta metoda istnieje i działa

        logging.debug("Zakończono tworzenie strony osiągnięć.")
        # --- DODANO: Wymuszenie aktualizacji scrollregion po chwili ---
        self.root.after(50, lambda: ach_canvas.configure(scrollregion=ach_canvas.bbox("all")) if ach_canvas.winfo_exists() else None)
    # --- NOWA METODA POMOCNICZA do odświeżania ---
    def _reload_definitions_and_refresh_ui(self):
         """Wczytuje ponownie definicje z pliku i odświeża UI."""
         self._load_achievement_definitions() # Wczytaj ponownie z pliku achievements_def.json
         # Odśwież listę definicji w Ustawieniach (jeśli istnieje)
         if hasattr(self, 'achievements_def_tree') and self.achievements_def_tree.winfo_exists():
              self._load_achievement_def_list()
         # Odśwież bieżącą stronę Osiągnięć
         self.check_and_unlock_achievements()
         logging.info("Odświeżono definicje osiągnięć i interfejs.")

    # --- NOWA METODA: Pokazywanie strony osiągnięć ---
    def show_achievements_page(self):
        # Upewnij się, że ramka Osiągnięć jest w gridzie
        self.achievements_frame.grid() 
        self.achievements_frame.tkraise()
        self.current_frame = self.achievements_frame

        # --- NOWE ZMIANY ---
        if not self._achievements_initialized:
            logging.info("Tworzenie zawartości strony Osiągnięć po raz pierwszy (lazy init).")
            self.create_achievements_page() # To buduje UI strony Osiągnięć
            self._achievements_initialized = True # Ustaw flagę
        else:
            # Jeśli strona była już inicjalizowana, tylko odśwież jej dane
            # To zapobiegnie migotaniu i powolnemu odbudowywaniu przy ponownych wejściach
            if hasattr(self, '_reload_definitions_and_refresh_ui'):
                 self._reload_definitions_and_refresh_ui()
            else: # Fallback
                 self.create_achievements_page()
        # --- KONIEC NOWYCH ZMIAN ---
        
        self.current_section = "Przegląda Osiągnięcia"
        self._update_discord_status(status_type="browsing", activity_details=self.current_section)
        logging.info("Wyświetlono stronę osiągnięć.")

    def _download_and_save_rawg_cover(self, game_name, image_url):
        """Pobiera obrazek z URL i zapisuje go lokalnie jako okładkę RAWG."""
        if not image_url:
            return None

        logging.info(f"Próba pobrania okładki RAWG dla '{game_name}' z: {image_url}")
        safe_game_name = re.sub(r'[\\/*?:"<>|]', "_", game_name)

        try:
            response = requests.get(image_url, stream=True, timeout=20) # Zwiększony timeout
            response.raise_for_status()

            # Wykryj rozszerzenie pliku
            content_type = response.headers.get('content-type')
            extension = '.jpg' # Domyślne rozszerzenie
            if content_type:
                if 'jpeg' in content_type: extension = '.jpg'
                elif 'png' in content_type: extension = '.png'
                elif 'webp' in content_type: extension = '.webp'
                elif 'gif' in content_type: extension = '.gif'
                elif 'bmp' in content_type: extension = '.bmp'
            else:
                 # Spróbuj zgadnąć z URL (proste)
                 lower_url = image_url.lower()
                 for ext in ['.png', '.webp', '.jpg', '.jpeg', '.gif', '.bmp']:
                      if lower_url.endswith(ext):
                           extension = ext
                           break

            dest_filename = f"{safe_game_name}_rawg_cover{extension}" # Dodajemy _rawg_cover
            dest_path = os.path.join(IMAGES_FOLDER, dest_filename)
            dest_abs = os.path.abspath(dest_path)

            os.makedirs(IMAGES_FOLDER, exist_ok=True) # Upewnij się, że folder istnieje

            with open(dest_abs, 'wb') as f:
                shutil.copyfileobj(response.raw, f)

            logging.info(f"Pomyślnie pobrano i zapisano okładkę RAWG: {dest_abs}")
            return dest_path # Zwróć ścieżkę względną lub absolutną - tu względna od folderu aplikacji

        except requests.exceptions.Timeout:
            logging.error(f"Timeout podczas pobierania okładki RAWG dla '{game_name}'.")
            return None
        except requests.exceptions.RequestException as e:
            logging.error(f"Błąd sieciowy podczas pobierania okładki RAWG dla '{game_name}': {e}")
            return None
        except IOError as e:
            logging.error(f"Błąd zapisu pliku okładki RAWG dla '{game_name}' w '{dest_abs}': {e}")
            return None
        except Exception as e:
            logging.exception(f"Nieoczekiwany błąd podczas pobierania/zapisu okładki RAWG dla '{game_name}'.")
            return None

    def _on_search_change(self, *args):
        """Obsługuje zmianę w polu wyszukiwania z opóźnieniem (debouncing)."""
        # Anuluj poprzedni zaplanowany update, jeśli istnieje
        if self._search_timer_id:
            self.root.after_cancel(self._search_timer_id)

        # Zaplanuj nowy update po 400 ms (możesz dostosować)
        DEBOUNCE_DELAY_MS = 400
        self._search_timer_id = self.root.after(DEBOUNCE_DELAY_MS, self.update_game_grid)

    def on_canvas_configure_and_lazy_load(self, event):
        """Obsługuje zmianę rozmiaru canvas i inicjuje lazy loading."""
        if hasattr(self, 'canvas') and self.canvas.winfo_exists():
             self.canvas_width = event.width
             # Aktualizuj szerokość okna w canvas
             self.canvas.itemconfig(self.games_frame_id, width=event.width)
             # Bezpośrednie wywołanie update_game_grid jest nieefektywne przy resize.
             # Lepiej tylko przeliczyć układ i załadować widoczne.
             # Na razie zostawimy update_game_grid, ale można to zoptymalizować później
             # self.update_game_grid()
             self._trigger_lazy_load() # Odśwież widoczne kafelki

    def _on_mouse_wheel_and_lazy_load(self, event):
        """Przewijanie za pomocą kółka myszy i inicjowanie lazy loadingu."""
        widget_under_cursor = None # Zainicjuj jako None
        try:
            # --- POPRAWIONA OBSŁUGA BŁĘDÓW ---
            widget_under_cursor = self.root.winfo_containing(event.x_root, event.y_root)
        except (tk.TclError, KeyError) as e:
            # Zignoruj błąd TclError (np. kursor poza oknem) lub KeyError (np. 'popdown')
            logging.debug(f"Ignorowany błąd w winfo_containing (lazy_load): {e}")
            widget_under_cursor = None # Upewnij się, że jest None w razie błędu
            # --- KONIEC POPRAWKI ---

        # Sprawdź, czy ten widget jest naszym canvas lub jego dzieckiem
        is_related_to_canvas = False
        curr = widget_under_cursor
        while curr is not None:
            if curr == self.canvas:
                is_related_to_canvas = True
                break
            if curr == self.root: # Bezpieczne wyjście
                break
            try:
                curr = curr.master
            except tk.TclError: # Na wypadek zniszczonego widgetu
                break

        # Przewijaj tylko jeśli zdarzenie dotyczy naszego canvas lub jego zawartości
        if is_related_to_canvas and hasattr(self, 'canvas') and self.canvas.winfo_exists():
            scroll_amount = -1 * int(event.delta / 120)
            view_start, view_end = self.canvas.yview()
            # Dodano warunek 0.0 <= view_start <= 1.0 and 0.0 <= view_end <= 1.0 dla pewności
            if 0.0 <= view_start <= 1.0 and 0.0 <= view_end <= 1.0:
                if (scroll_amount < 0 and view_start > 0.0) or (scroll_amount > 0 and view_end < 1.0):
                    self.canvas.yview_scroll(scroll_amount, "units")
                    self._trigger_lazy_load()
                    return "break" # Zatrzymaj propagację
            else:
                logging.warning("Niespójny stan yview dla canvas (lazy_load)")

    def _trigger_lazy_load(self, event=None):
         """Pomocnicza funkcja do inicjowania lazy loadingu (może być wywoływana z opóźnieniem)."""
         # Można dodać małe opóźnienie (debouncing) również tutaj, jeśli przewijanie jest bardzo szybkie
         # np. używając self._lazy_load_timer_id = self.root.after(50, self._load_visible_tiles)
         self.root.after(10, self._load_visible_tiles) # Krótkie opóźnienie dla płynności

    def _load_visible_tiles(self):
        """Ładuje zawartość tylko dla widocznych kafelków-placeholderów."""
        if not hasattr(self, 'canvas') or not self.canvas.winfo_exists() or not hasattr(self, 'games_frame'):
             return

        try:
            # Pobierz widoczny obszar canvas
            canvas_height = self.canvas.winfo_height()
            scroll_region = self.canvas.yview()
            visible_top = scroll_region[0] * self.games_frame.winfo_reqheight()
            visible_bottom = scroll_region[1] * self.games_frame.winfo_reqheight()

            # Dodaj mały bufor
            buffer = self.tile_height

            # Pobierz aktualne wymiary kafelka do przekazania
            current_width = getattr(self, 'current_tile_width', 200) # Użyj zapisanego lub domyślnego
            current_height = self.tile_height


            # Iteruj przez ramki-placeholdery w self.games_frame
            for tile_frame in self.games_frame.winfo_children():
                 # Sprawdź, czy ramka ma zapisane informacje i czy nie jest załadowana
                 if hasattr(tile_frame, 'game_info') and not tile_frame.game_info['loaded']:
                     # Pobierz pozycję ramki
                     frame_y = tile_frame.winfo_y()
                     frame_height = tile_frame.winfo_height()
                     if frame_height == 1: # Widget może jeszcze nie mieć pełnego rozmiaru
                         frame_height = current_height # Użyj estymowanej

                     # Sprawdź, czy ramka jest w widocznym obszarze (+ bufor)
                     is_visible = (frame_y + frame_height > visible_top - buffer and
                                   frame_y < visible_bottom + buffer)

                     if is_visible:
                         game_name = tile_frame.game_info['name']
                         game_data = self.games.get(game_name)
                         if game_data:
                              # Przekaż aktualne wymiary kafelka
                              self._populate_game_tile(tile_frame, game_name, game_data, current_width, current_height) # <-- UPEWNIJ SIĘ, ŻE TA LINIA JEST POPRAWNA
                              tile_frame.game_info['loaded'] = True # Oznacz jako załadowany
                         else:
                              logging.warning(f"Nie znaleziono danych dla gry '{game_name}' podczas lazy loadingu.")

        except tk.TclError as e:
            # Może się zdarzyć, jeśli widgety są niszczone podczas operacji
            logging.warning(f"Błąd TclError podczas lazy loadingu: {e}")
        except Exception as e:
             logging.exception("Nieoczekiwany błąd podczas lazy loadingu")

# W klasie GameLauncher:

    def _create_tile_placeholder(self, parent, game_name, row, col, padx_config, pady_config, tile_width, tile_height):
        """Tworzy pustą ramkę (placeholder) dla kafelka gry."""
        game_frame = ttk.Frame(parent, width=tile_width, height=tile_height, style="Game.TFrame", borderwidth=1, relief="solid") # Dodajmy ramkę dla widoczności
        game_frame.grid(row=row, column=col, padx=padx_config, pady=pady_config, sticky="nsew")
        game_frame.grid_propagate(False) # Zapobiegaj zmianie rozmiaru ramki przez zawartość (na razie)

        # Przechowaj informacje potrzebne do późniejszego załadowania
        game_frame.game_info = {'name': game_name, 'loaded': False}

        # Opcjonalnie: Dodaj prosty label "Ładowanie..."
        # loading_label = ttk.Label(game_frame, text="Ładowanie...")
        # loading_label.place(relx=0.5, rely=0.5, anchor=tk.CENTER)
        # game_frame.loading_label = loading_label # Zapisz referencję

        return game_frame

    def _start_discord_rpc(self):
        if self.rpc or self._is_connecting_rpc: return
        if not self.discord_rpc_enabled_var.get(): logging.info("RPC wyłączone w UI."); return

        logging.info("Próba uruchomienia Discord RPC...")
        self._is_connecting_rpc = True 

        try:
            self.rpc = Presence(client_id=self.DISCORD_CLIENT_ID)
            self.rpc.connect() 
            logging.info("Połączono z Discord RPC.")
            activity = self.current_section if hasattr(self, 'current_section') and self.current_section else self.translator.gettext("W menu głównym")
            self._update_discord_status(status_type="browsing", activity_details=activity) # Ustaw status początkowy
            
        except PyPresenceException as e:
            logging.warning(f"Nie udało się połączyć z Discord RPC (w _start_discord_rpc): {e}")
            self.rpc = None
            # --- ZMIANA: Tylko logujemy, nie wołamy _handle_rpc_connection_error od razu ---
            # _handle_rpc_connection_error może odznaczyć checkbox, czego tu nie chcemy przy każdej próbie.
            # Jeśli _start_discord_rpc jest wywoływane przez monitor, to monitor będzie próbował dalej.
            # Jeśli przez użytkownika (przez _toggle_discord_rpc), to _toggle_discord_rpc samo powinno
            # obsłużyć sytuację, gdy połączenie się nie uda (np. przez sprawdzenie self.rpc po chwili).
            # Na razie: pozwólmy monitorowi działać.
            # Jeśli użytkownik właśnie kliknął "włącz RPC", a to się nie udało, to może warto mu dać znać,
            # ale nie przez _handle_rpc_connection_error, które zmienia ustawienia.
            # To wymaga delikatniejszej logiki w _toggle_discord_rpc.
            # --- KONIEC ZMIANY ---
        except ConnectionRefusedError: # Częsty błąd, gdy Discord nie jest uruchomiony
             logging.warning("Nie udało się połączyć z Discord RPC: Connection refused. Discord prawdopodobnie nie jest uruchomiony.")
             self.rpc = None
        except Exception as e: 
            logging.exception("Nieoczekiwany (inny) błąd podczas uruchamiania Discord RPC.")
            self.rpc = None
            # Dla zupełnie nieoczekiwanych, krytycznych błędów można by odznaczyć i zapisać.
            if hasattr(self, 'discord_rpc_enabled_var'): self.discord_rpc_enabled_var.set(False)
            self.local_settings["discord_rpc_enabled"] = False
            save_local_settings(self.local_settings)
            self.root.after(0, lambda err_msg=str(e): messagebox.showerror("Błąd Krytyczny RPC", f"Wystąpił krytyczny błąd RPC i zostało ono wyłączone:\n{err_msg}", parent=self.root))
        finally:
            self._is_connecting_rpc = False

    # --- NOWA METODA POMOCNICZA do obsługi błędów w głównym wątku ---
    def _handle_rpc_connection_error(self, error_message: str, is_critical: bool = True):
        """
        Obsługuje błędy połączenia RPC w głównym wątku GUI.
        Pokazuje messagebox tylko dla krytycznych błędów.
        Zawsze odznacza checkbox i zapisuje ustawienia, jeśli RPC miało być włączone.
        """
        if not self.root.winfo_exists(): return

        log_message = f"Obsługa błędu RPC: {error_message}"
        if is_critical:
            logging.error(log_message) # Błędy krytyczne loguj jako error
            # Pokaż błąd użytkownikowi tylko dla naprawdę krytycznych problemów
            if "pipe" not in error_message.lower(): # Nie pokazuj okna dla "pipe closed"
                 messagebox.showwarning("Discord RPC", f"Problem z połączeniem Discord:\n{error_message}", parent=self.root)
        else:
            logging.warning(log_message) # Mniej krytyczne loguj jako warning

        # Niezależnie od przyczyny (jeśli doszło do błędu obsługiwanego tą metodą),
        # odznacz checkbox i zapisz, że RPC jest wyłączone, bo połączenie nie działa.
        # To da użytkownikowi znać, że musi np. zrestartować Discorda i ponownie włączyć RPC.
        if hasattr(self, 'discord_rpc_enabled_var') and self.discord_rpc_enabled_var.get():
            self.discord_rpc_enabled_var.set(False) 
        
        # Zawsze zapisuj, że jest wyłączone, bo wystąpił problem z połączeniem/aktualizacją.
        # Jeśli to był błąd "pipe closed", monitor zaraz spróbuje połączyć ponownie, jeśli użytkownik znowu włączy.
        if self.local_settings.get("discord_rpc_enabled", False): # Jeśli było zapisane jako włączone
            self.local_settings["discord_rpc_enabled"] = False
            save_local_settings(self.local_settings)
            logging.info("RPC zostało wyłączone w ustawieniach z powodu błędu połączenia/aktualizacji.")

        if self.rpc: # Upewnij się, że instancja RPC jest wyczyszczona
            try:
                self.rpc.close()
            except Exception:
                pass
            self.rpc = None
        self._is_connecting_rpc = False


    def _toggle_discord_rpc(self):
        """Włącza lub wyłącza integrację z Discord RPC na podstawie checkboxa."""
        is_enabled = self.discord_rpc_enabled_var.get()
        # Zapisz zmianę w ustawieniach lokalnych natychmiast
        if self.local_settings.get("discord_rpc_enabled") != is_enabled:
            self.local_settings["discord_rpc_enabled"] = is_enabled
            save_local_settings(self.local_settings)
            logging.info(f"Zmieniono ustawienie Discord RPC na: {is_enabled}")

        if is_enabled:
            # Jeśli użytkownik właśnie włączył, spróbuj połączyć od razu
            if not self.rpc and not self._is_connecting_rpc:
                 logging.info("RPC włączone przez użytkownika. Próba połączenia...")
                 self._start_discord_rpc() # Wywołaj bezpośrednio (jesteśmy w głównym wątku)
            elif self.rpc:
                 logging.info("RPC już działa.")
                 # Upewnij się, że status jest poprawny
                 self._update_discord_status(status_type="idle")

        else:
            # Jeśli użytkownik właśnie wyłączył, zatrzymaj RPC
            logging.info("RPC wyłączone przez użytkownika. Zatrzymywanie połączenia...")
            self._stop_discord_rpc()
            # Opcjonalnie wyczyść status (choć stop powinien to zrobić)
            # if self.rpc: self.rpc.clear()


# W klasie GameLauncher

    def _update_discord_status(self, status_type="idle", game_name=None, profile_name=None, start_time=None, activity_details=None):
        if not self.discord_rpc_enabled_var.get() or not self.rpc: return

        try:
            state_text = ""
            details_text = ""
            large_image_key = 'gl_logo' 
            small_image_key = None 
            small_image_text = None
            start_timestamp = None

            is_game_actually_running = game_name and status_type == "in_game"
            current_music_track_info = None # Będzie przechowywać słownik utworu lub None

            # Sprawdź, czy muzyka gra i pobierz informacje o utworze
            if hasattr(self, 'music_player_page_instance') and \
               self.music_player_page_instance and \
               hasattr(self.music_player_page_instance, 'is_playing') and \
               self.music_player_page_instance.is_playing and \
               not self.music_player_page_instance.is_paused and \
               hasattr(self.music_player_page_instance, 'current_track_index') and \
               self.music_player_page_instance.current_track_index != -1 and \
               hasattr(self.music_player_page_instance, 'playlist') and \
               self.music_player_page_instance.current_track_index < len(self.music_player_page_instance.playlist):
                try:
                    # --- NOWE ZMIANY: Pobierz dane z MusicPlayerPage ---
                    player = self.music_player_page_instance
                    track_entry = player.playlist[player.current_track_index] # Pobierz słownik utworu
                    
                    # Użyj metody z odtwarzacza do uzyskania sformatowanej nazwy (Tytuł - Artysta lub nazwa pliku)
                    # Usuń serduszko, bo to nie jest potrzebne w statusie Discord
                    music_display_name = player._get_display_name_for_track(track_entry).replace("♥ ", "").strip()
                    if music_display_name:
                        current_music_track_info = {
                            "display_name": music_display_name,
                            "start_time_monotonic": getattr(player, '_start_time', 0), # Czas startu z monotonic
                            "pause_accumulator": getattr(player, '_pause_acc', 0) # Akumulator pauz
                        }
                    # --- KONIEC NOWYCH ZMIAN ---
                except Exception as e_music_info:
                    logging.error(f"Błąd pobierania informacji o muzyce dla Discord: {e_music_info}")
                    current_music_track_info = None

            # Główna logika ustalania statusu
            if is_game_actually_running:
                state_text = f"Gra w: {game_name}"
                details_list = [] 

                if profile_name and profile_name.lower() != "default":
                    details_list.append(f"Profil: {profile_name}")
                else:
                    details_list.append("Uruchomiono z GL")

                if current_music_track_info:
                    details_list.append(f"🎧 {current_music_track_info['display_name'][:40]}") # Ogranicz długość nazwy utworu
                    small_image_key = 'music_note_icon' 
                    small_image_text = "Słucha muzyki"
                
                details_text = " | ".join(details_list)
                start_timestamp = int(start_time) if start_time else None
                large_image_key = 'gaming_status' 

            elif current_music_track_info: # Muzyka gra, gra nie
                state_text = "Słucha Muzyki 🎧"
                details_text = current_music_track_info['display_name'][:128] # Ogranicz długość
                large_image_key = 'music_icon' # Nazwa twojego assetu dla muzyki

                # Obliczanie czasu dla Discorda (start utworu)
                try:
                    if current_music_track_info['start_time_monotonic'] > 0:
                        current_track_elapsed = (time.monotonic() -
                                                 current_music_track_info['start_time_monotonic'] -
                                                 current_music_track_info['pause_accumulator'])
                        track_start_for_discord = time.time() - current_track_elapsed
                        start_timestamp = int(track_start_for_discord)
                except Exception as e_timestamp_music:
                    logging.warning(f"Błąd obliczania timestampu muzyki dla Discord: {e_timestamp_music}")
                    start_timestamp = None


            elif status_type == "browsing" and activity_details:
                state_text = self.discord_status_text_var.get() or "Korzysta z Game Launcher"
                details_text = activity_details
                large_image_key = 'gl_logo'
            else:  # Domyślny "idle"
                state_text = self.discord_status_text_var.get() or "Korzysta z Game Launcher"
                details_text = self.current_section if hasattr(self, 'current_section') else "W menu głównym"
                large_image_key = 'gl_logo'

            self.rpc.update(
                state=state_text[:128],
                details=details_text[:128],
                large_image=large_image_key,
                small_image=small_image_key,
                small_text=small_image_text,
                start=start_timestamp
            )
            logging.info(f"Discord RPC Update: State='{state_text}', Details='{details_text}', LargeImg='{large_image_key}', SmallImg='{small_image_key}', Start='{start_timestamp}'")

        except PyPresenceException as e:
            logging.error(f"Błąd PyPresence Discord podczas aktualizacji statusu: {e}")
            # --- ZMIANA: Specjalna obsługa "pipe closed" ---
            if "pipe" in str(e).lower():
                logging.warning("Discord pipe closed. RPC zatrzymane, monitor spróbuje połączyć ponownie.")
                self._stop_discord_rpc() # Użyj nowej, ogólnej metody stop
                # Jeśli monitor ma próbować połączyć, NIE odznaczamy checkboxa
            else: 
                self._handle_rpc_connection_error(str(e), is_critical=True)
            # --- KONIEC ZMIANY ---
        except Exception as e:
            logging.exception("Nieoczekiwany błąd podczas aktualizacji statusu Discord.")

# W klasie GameLauncher

# W klasie GameLauncher

    # --- ZMIANA NAZWY I EWENTUALNIE DROBNE KOREKTY ---
    def _stop_discord_rpc(self): # Poprzednio _stop_discord_rpc_quietly
        """Zatrzymuje połączenie Discord RPC i czyści instancję."""
        self._is_connecting_rpc = False # Zawsze resetuj flagę próby połączenia
        if self.rpc:
            try:
                self.rpc.close() # Użyj metody close() obiektu Presence
                logging.info("Połączenie Discord RPC zamknięte.")
            except PyPresenceException as e:
                 logging.error(f"Błąd PyPresence podczas zamykania połączenia RPC: {e}")
            except Exception as e:
                 logging.exception("Nieoczekiwany błąd podczas zamykania RPC.")
            finally:
                 self.rpc = None # Zawsze resetuj referencję
        # else: # Usunięto log, bo ta metoda może być wołana, nawet jeśli rpc już jest None
            # logging.info("Discord RPC nie było uruchomione lub już zatrzymane.")
    # --- KONIEC ZMIANY ---

    # --- NOWE: Funkcja do zapisu ustawień Discorda (np. tekstu statusu) ---
    def _save_discord_settings(self):
         """Zapisuje ustawienia Discord RPC z interfejsu."""
         new_status_text = self.discord_status_text_var.get()
         if self.local_settings.get("discord_status_text") != new_status_text:
              self.local_settings["discord_status_text"] = new_status_text
              save_local_settings(self.local_settings)
              logging.info(f"Zapisano nowy tekst statusu Discord: {new_status_text}")
              # Zaktualizuj status od razu, jeśli RPC jest aktywne i jesteśmy w stanie idle
              if self.discord_rpc_enabled and self.rpc:
                   # Sprawdź, czy aktualnie nie jest śledzona żadna gra
                   if not self.tracking_games: # Jeśli słownik śledzonych gier jest pusty
                        self._update_discord_status(status_type="idle")

# W klasie GameLauncher:

    # --- NOWA METODA POMOCNICZA ---
    def _load_and_display_settings_avatar(self, size_tuple=None):
        """Ładuje i wyświetla awatar w sekcji Ustawienia."""
        if not hasattr(self, 'settings_avatar_label') or not self.settings_avatar_label.winfo_exists():
            return

        if size_tuple is None:
            s = self.local_settings.get("avatar_display_size", 48)
            size_tuple = (s, s)

        avatar_path = self.user.get("avatar")
        loaded_photo = None

        if avatar_path and os.path.exists(avatar_path):
            try:
                with Image.open(avatar_path) as img:
                        # --- ZMIANA: Użyj size_tuple ---
                    img.thumbnail(size_tuple, resampling)
                        # --- KONIEC ZMIANY ---
                    loaded_photo = ImageTk.PhotoImage(img)
            except Exception as e:
                logging.error(f"Nie można załadować awatara (Ustawienia) '{avatar_path}': {e}")
                loaded_photo = None

        if loaded_photo:
            self.settings_avatar_label.config(image=loaded_photo, text="")
            self.settings_avatar_label.image = loaded_photo
        else:
            try:
                    # --- ZMIANA: Użyj size_tuple ---
                default_avatar = Image.new('RGB', size_tuple, color='#444444')
                    # --- KONIEC ZMIANY ---
                draw = ImageDraw.Draw(default_avatar)
                username_initial = self.user.get("username", "G")[0].upper() if self.user.get("username") else "G"
                try:
                        # --- ZMIANA: Użyj size_tuple ---
                    font = ImageFont.truetype("arialbd.ttf", size_tuple[0] // 2)
                        # --- KONIEC ZMIANY ---
                except IOError:
                    font = ImageFont.load_default()
                bbox = draw.textbbox((0,0), username_initial, font=font)
                text_w, text_h = bbox[2]-bbox[0], bbox[3]-bbox[1]
                    # --- ZMIANA: Użyj size_tuple ---
                draw.text(((size_tuple[0]-text_w)//2, (size_tuple[1]-text_h)//2-2), username_initial, fill="white", font=font)
                    # --- KONIEC ZMIANY ---
                default_photo = ImageTk.PhotoImage(default_avatar)
                self.settings_avatar_label.config(image=default_photo, text="")
                self.settings_avatar_label.image = default_photo
            except Exception as e_def:
                logging.error(f"Nie można stworzyć domyślnego awatara (Ustawienia): {e_def}")
                self.settings_avatar_label.config(image=None, text="")


    def _populate_game_tile(self, tile_frame, game_name, game_data, tile_width, tile_height):
        """Wypełnia ramkę o STAŁYM rozmiarze zawartością kafelka gry (Wersja z Menu Kontekstowym)."""
        logging.debug(f"Populating tile for {game_name} with size {tile_width}x{tile_height}")

        target_image_height = int(tile_height * 0.60)
        target_image_size = (tile_width, target_image_height)
        target_info_height = int(tile_height * 0.18) # Dostosuj w razie potrzeby

        original_cover_path = self.games[game_name].get("cover_image") # Użyj self.games
        # Zapewnij okładkę (tworzy domyślną, jeśli trzeba) - zakładamy, że _ensure_cover istnieje i działa
        cover_path_to_load = self._ensure_cover(game_name, self.games[game_name], target_image_size)

        photo = load_photoimage_from_path(cover_path_to_load, target_image_size)

        # Czyszczenie poprzedniej zawartości
        for widget in tile_frame.winfo_children():
            widget.destroy()

        # Konfiguracja wewnętrznego gridu ramki
        tile_frame.rowconfigure(0, weight=0) # Obraz
        tile_frame.rowconfigure(1, weight=0) # Info
        tile_frame.rowconfigure(2, weight=1) # Przyciski
        tile_frame.columnconfigure(0, weight=1)

        # Okładka (jako Label)
        cover_label = ttk.Label(tile_frame, anchor=tk.CENTER)
        if photo:
            cover_label.config(image=photo)
            cover_label.image = photo
        else:
            # Obsługa braku obrazka (jak poprzednio)
            # ... (kod tworzenia placeholdera) ...
             try:
                 placeholder_img = Image.new('RGB', target_image_size, color='#555555')
                 draw = ImageDraw.Draw(placeholder_img)
                 try: font = ImageFont.truetype("arial.ttf", 12)
                 except IOError: font = ImageFont.load_default()
                 bbox = draw.textbbox((0, 0), "Brak\nOkładki", font=font)
                 text_w, text_h = bbox[2] - bbox[0], bbox[3] - bbox[1]
                 draw.text(((target_image_size[0]-text_w)//2, (target_image_size[1]-text_h)//2), "Brak\nOkładki", fill="white", font=font, align="center")
                 placeholder_photo = ImageTk.PhotoImage(placeholder_img)
                 cover_label.config(image=placeholder_photo)
                 cover_label.image = placeholder_photo
             except Exception as e_placeholder:
                 logging.error(f"Nie można nawet utworzyć placeholdera obrazu: {e_placeholder}")
                 cover_label.config(text="Brak\nOkładki", image='')

        cover_label.grid(row=0, column=0, sticky='ew', padx=5, pady=(5,0))
        # Kliknięcie lewym nadal otwiera szczegóły
        cover_label.bind("<Button-1>", lambda event, gn=game_name: self.show_game_details(gn))
        # --- NOWE: Bindowanie prawego przycisku do menu kontekstowego ---
        # Bindowanie do całej ramki kafelka oraz do etykiety okładki
        tile_frame.bind("<Button-3>", lambda event, gn=game_name: self._show_tile_context_menu(event, gn))
        cover_label.bind("<Button-3>", lambda event, gn=game_name: self._show_tile_context_menu(event, gn))
        # --- KONIEC NOWEGO ---
        # --- ZMIANA: Zwiększ minimalną wysokość i rozmiar czcionki ---
        # target_info_height = int(tile_height * 0.18) # Możemy to usunąć lub zwiększyć
        target_info_height = 60 # Ustawmy minimalną wysokość np. na 60px
        info_font_size = 9 # Zwiększmy domyślny rozmiar czcionki np. do 9
        info_font = ("Segoe UI", info_font_size)
        # --- KONIEC ZMIANY ---

        # Etykiety informacyjne
        info_frame = ttk.Frame(tile_frame, height=target_info_height)
        info_frame.grid(row=1, column=0, sticky='ew', padx=5, pady=2)
        info_frame.columnconfigure(0, weight=1)
        info_frame.rowconfigure(0, weight=1)

        completion = game_data.get('completion', 0)
        game_version = game_data.get('version', '')
        game_tags = ", ".join(game_data.get('tags', []))

        # --- NOWA ZMIANA: Dodanie informacji o typie gry ---
        game_type = game_data.get("game_type", "pc")
        type_info = ""
        if game_type == "emulator":
            emulator_name = game_data.get("emulator_name", "Nieznany Emu")
            type_info = f" [{emulator_name}]" # Dodajmy nazwę emulatora w nawiasach
        elif game_type == "pc":
             type_info = " [PC]" # Opcjonalnie, można oznaczać też gry PC
        # Jeśli chcesz oznaczać tylko gry emulowane, usuń blok elif game_type == "pc"

        # Budowanie tekstu etykiety
        label_text = f"{game_name}{type_info}\n" # Dodaj type_info do nazwy gry
        # --- KONIEC ZMIANY ---

        details = []
        details.append(f"Czas: {self.format_play_time(game_data.get('play_time', 0))}")
        details.append(f"Ukoń.: {completion}%")
        if game_version: details.append(f"Ver: {game_version}")
        if game_tags:
             max_tag_len = tile_width // 9
             if len(game_tags) > max_tag_len: game_tags = game_tags[:max_tag_len] + "..."
             details.append(f"Tagi: {game_tags}")
        label_text += " | ".join(details) # Połącz detale w jednej linii

        # --- ZMIANA: Użyj nowego fontu ---
        name_label = ttk.Label(info_frame, text=label_text, anchor="nw", wraplength=tile_width-15, justify=tk.LEFT, font=info_font)
        # --- KONIEC ZMIANY ---
        name_label.grid(sticky='nsew')
        name_label.bind("<Button-3>", lambda event, gn=game_name: self._show_tile_context_menu(event, gn))
        info_frame.bind("<Button-3>", lambda event, gn=game_name: self._show_tile_context_menu(event, gn))
        # --- KONIEC NOWEGO ---

        # --- ZMIANA: Ramka tylko na kluczowe przyciski ---
        key_buttons_frame = ttk.Frame(tile_frame)
        key_buttons_frame.grid(row=2, column=0, sticky='nsew', padx=5, pady=(0,5))
        # --- ZMIANA: Użyj grid i nadaj wagę kolumnom ---
        key_buttons_frame.columnconfigure((0, 1), weight=1) # Dwie kolumny z równą wagą
        # --- KONIEC ZMIANY ---

        # --- Logika przycisku Uruchom/Zamknij z ikonami ---
        launch_area_frame = ttk.Frame(key_buttons_frame)
        # --- ZMIANA: Umieść w grid ---
        launch_area_frame.grid(row=0, column=0, padx=(0, 1), pady=1, sticky="nsew") # Kolumna 0
        # --- KONIEC ZMIANY ---

        profiles = game_data.get("launch_profiles", [])
        if not profiles: profiles = [{"name": "Default", "exe_path": None, "arguments": ""}]
        default_profile = profiles[0]

        if len(profiles) == 1 and default_profile.get("name", "").lower() == "default":
            tooltip_text_base = "Uruchom"
        else:
            tooltip_text_base = f"Uruchom: {default_profile.get('name', 'Profil')}"

        # Przygotuj dane dla obu stanów
        if self.is_game_running(game_name):
             button_image = self._button_icons.get("stop_btn")
             button_style = "Red.TButton"
             button_command = lambda: self.close_game(game_name)
             tooltip_text = "Zamknij"
        else:
             button_image = self._button_icons.get("play_btn")
             button_style = "Green.TButton"
             button_command = lambda p=default_profile: self.launch_game(game_name, profile=p)
             tooltip_text = tooltip_text_base

        # Utwórz główny przycisk (z ikoną lub tekstem jako fallback)
        if button_image:
             launch_btn = ttk.Button(launch_area_frame, image=button_image, style=button_style, command=button_command)
             launch_btn.image = button_image
             # --- ZMIANA: Zapisz tooltip jako atrybut ---
             launch_btn.tooltip = ToolTip(launch_btn, tooltip_text)
             # --- KONIEC ZMIANY ---
        else:
             # Fallback na tekst, jeśli ikona się nie załadowała
             fallback_text = "Zamknij" if self.is_game_running(game_name) else tooltip_text_base.split(':')[0] # Tylko "Uruchom"
             launch_btn = ttk.Button(launch_area_frame, text=fallback_text, style=button_style, command=button_command)
             # Tooltip nadal przydatny, zwłaszcza dla profilu
             # --- ZMIANA: Zapisz tooltip jako atrybut ---
             launch_btn.tooltip = ToolTip(launch_btn, tooltip_text)
             # --- KONIEC ZMIANY ---

        self._launch_buttons[game_name] = launch_btn # Zapisz referencję

        # Logika dla Menubutton (▼ lub ikona)
        if len(profiles) > 1:
            launch_btn.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            profile_menu_icon = self._button_icons.get("profile_menu_btn")
            if profile_menu_icon:
                 # --- ZMIANA: Zapisz referencję do Menubuttona ---
                 profile_menu_btn = ttk.Menubutton(launch_area_frame, image=profile_menu_icon, style="Toolbutton")
                 profile_menu_btn.image = profile_menu_icon
                 # --- KONIEC ZMIANY ---
                 ToolTip(profile_menu_btn, "Wybierz profil")
            else:
                 profile_menu_btn = ttk.Menubutton(launch_area_frame, text="▼", width=2, style="Toolbutton") # Fallback na tekst
            profile_menu_btn.pack(side=tk.LEFT, fill=tk.Y)
            # --- NOWE: Zapisz Menubutton w słowniku, aby go ukryć ---
            # Klucz może być np. nazwą gry + '_profile_menu'
            self._launch_buttons[f"{game_name}_profile_menu"] = profile_menu_btn
            # --- KONIEC NOWEGO ---
            profile_menu = tk.Menu(profile_menu_btn, tearoff=0, background="#2e2e2e", foreground="white")
            profile_menu_btn["menu"] = profile_menu
            for profile in profiles:
                profile_name = profile.get("name", "Brak Nazwy")
                cmd = lambda p=profile, gn=game_name: self.launch_game(gn, profile=p)
                profile_menu.add_command(label=profile_name, command=cmd)
        else:
            launch_btn.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        # --- KONIEC ZMIANY ---


        # --- Przycisk Zapisy ---
        save_icon_tk = self._button_icons.get("save_btn")
        if save_icon_tk:
             saves_btn = ttk.Button(key_buttons_frame, image=save_icon_tk, style="Toolbutton", command=lambda gn=game_name: self.manage_saves(gn))
             saves_btn.image = save_icon_tk
             ToolTip(saves_btn, "Zarządzaj Zapisami")
        else:
             saves_btn = ttk.Button(key_buttons_frame, text="Zapisy", style="Tile.TButton", command=lambda gn=game_name: self.manage_saves(gn))
        # --- ZMIANA: Umieść w grid ---
        saves_btn.grid(row=0, column=1, padx=(1, 0), pady=1, sticky="nsew") # Kolumna 1
        # --- KONIEC ZMIANY ---


        info_frame.grid_propagate(False)

    # --- NOWA METODA: Menu kontekstowe dla kafelka ---
    def _show_tile_context_menu(self, event, game_name):
        """Wyświetla menu kontekstowe dla kafelka gry (z ikonami i opcją Uruchom)."""
        if game_name not in self.games: return

        game_data = self.games[game_name]
        save_path = game_data.get("save_path")
        is_save_path_valid = save_path and os.path.isdir(save_path)

        context_menu = tk.Menu(self.root, tearoff=0, background="#2e2e2e", foreground="white")

        # --- Opcja Uruchom/Uruchom z profilem (z ikoną) ---
        profiles = game_data.get("launch_profiles", [])
        play_icon = self._button_icons.get('play_menu') # Użyj ikony z _button_icons (wcześniej było _menu_icons)

        if profiles:
            if len(profiles) == 1 and profiles[0].get("name", "").lower() == "default":
                 context_menu.add_command(label="Uruchom", command=lambda gn=game_name: self.launch_game(gn),
                                          image=play_icon, compound=tk.LEFT)
            else:
                 launch_menu = tk.Menu(context_menu, tearoff=0, background="#2e2e2e", foreground="white")
                 context_menu.add_cascade(label="Uruchom z profilem...", menu=launch_menu,
                                          image=play_icon, compound=tk.LEFT)
                 for profile in profiles:
                      profile_name = profile.get("name", "Brak nazwy")
                      cmd = lambda p=profile, gn=game_name: self.launch_game(gn, profile=p)
                      launch_menu.add_command(label=profile_name, command=cmd) # Bez ikon w podmenu na razie
        else:
             context_menu.add_command(label="Uruchom", command=lambda gn=game_name: self.launch_game(gn),
                                      image=play_icon, compound=tk.LEFT)
        context_menu.add_separator()
        # --- Koniec Opcji Uruchom ---


        # --- Pozostałe opcje z ikonami ---
        context_menu.add_command(label="Edytuj dane", command=lambda gn=game_name: self.edit_game(gn),
                                 image=self._button_icons.get('edit'), compound=tk.LEFT) # Użyj _button_icons
        context_menu.add_command(label="Otwórz folder z zapisami", command=lambda p=save_path: self._open_folder(p),
                                 state=tk.NORMAL if is_save_path_valid else tk.DISABLED,
                                 image=self._button_icons.get('folder_open'), compound=tk.LEFT) # Użyj _button_icons
        context_menu.add_command(label="Zarządzaj zapisami", command=lambda gn=game_name: self.manage_saves(gn),
                                 image=self._button_icons.get('save_disk'), compound=tk.LEFT) # Użyj _button_icons
        # --- NOWE: Skróty do zakładek (Z IKONAMI) ---
        context_menu.add_command(label="Pokaż Checklistę", command=lambda gn=game_name: self._show_game_details_and_select_tab(gn, "Checklista"),
                                 image=self._button_icons.get('checklist'), compound=tk.LEFT) # Dodano ikonę
        context_menu.add_command(label="Pokaż Screenshoty", command=lambda gn=game_name: self._show_game_details_and_select_tab(gn, "Screenshoty"),
                                 image=self._button_icons.get('screenshot'), compound=tk.LEFT) # Dodano ikonę
        # --- KONIEC NOWEGO ---
        if hasattr(self, 'extended_mod_manager'):
             context_menu.add_command(label="Mody", command=lambda gn=game_name: self._show_mods_for_game_from_context(gn),
                                      image=self._button_icons.get('mods'), compound=tk.LEFT) # Użyj _button_icons



        context_menu.add_separator()
        context_menu.add_command(label="Resetuj statystyki", command=lambda gn=game_name: self.reset_stats(gn),
                                 image=self._button_icons.get('reset'), compound=tk.LEFT) # Użyj _button_icons

        # Opcje grup (z ikonami)
        if self.groups:
            group_menu_add = tk.Menu(context_menu, tearoff=0, background="#2e2e2e", foreground="white")
            context_menu.add_cascade(label="Dodaj do grupy...", menu=group_menu_add,
                                     image=self._button_icons.get('group_add'), compound=tk.LEFT) # Użyj _button_icons
            can_add_to_any = False
            for group_name in sorted(self.groups.keys()):
                is_in_group = game_name in self.groups.get(group_name, [])
                state = tk.DISABLED if is_in_group else tk.NORMAL
                cmd = lambda gn=game_name, grp=group_name: self._add_to_group_from_menu(gn, grp)
                group_menu_add.add_command(label=group_name, command=cmd, state=state)
                if not is_in_group: can_add_to_any = True
            if not can_add_to_any: context_menu.entryconfig("Dodaj do grupy...", state=tk.DISABLED)

            groups_game_is_in = [grp for grp, games in self.groups.items() if game_name in games]
            if groups_game_is_in:
                 remove_group_menu = tk.Menu(context_menu, tearoff=0, background="#2e2e2e", foreground="white")
                 context_menu.add_cascade(label="Usuń z grupy...", menu=remove_group_menu,
                                          image=self._button_icons.get('group_remove'), compound=tk.LEFT) # Użyj _button_icons
                 for group_name in sorted(groups_game_is_in):
                      cmd = lambda gn=game_name, grp=group_name: self._remove_from_group_from_menu(gn, grp)
                      remove_group_menu.add_command(label=group_name, command=cmd)

        context_menu.add_separator()
        context_menu.add_command(label="Usuń grę", command=lambda gn=game_name: self.delete_game(gn),
                                 image=self._button_icons.get('delete'), compound=tk.LEFT) # Użyj _button_icons
        # --- Koniec opcji z ikonami ---

        context_menu.post(event.x_root, event.y_root)
    # --- NOWA METODA POMOCNICZA dla menu kontekstowego ---
    def _remove_from_group_from_menu(self, game_name, group_name):
        """Usuwa grę z wybranej grupy (wywołane z menu kontekstowego)."""
        if group_name in self.groups and game_name in self.groups[group_name]:
             self.groups[group_name].remove(game_name)
             save_config(self.config)
             messagebox.showinfo("Sukces", f"Gra '{game_name}' została usunięta z grupy '{group_name}'.")
             # Odśwież siatkę tylko jeśli aktualnie przeglądamy TĘ grupę lub Wszystkie Gry
             if self.group_var.get() == group_name or self.group_var.get() == "Wszystkie Gry":
                  self.reset_and_update_grid()
        else:
             # Ten błąd nie powinien wystąpić, jeśli menu jest generowane poprawnie
             messagebox.showwarning("Błąd", f"Gra '{game_name}' nie znajduje się w grupie '{group_name}'.")
             logging.warning(f"Błąd logiki: próba usunięcia gry '{game_name}' z grupy '{group_name}', w której jej nie ma (menu kontekstowe).")
    # --- KONIEC NOWEJ METODY ---

    # --- NOWA METODA POMOCNICZA dla menu kontekstowego ---
    def _show_mods_for_game_from_context(self, game_name):
         """Pokazuje menedżera modów i wybiera grę."""
         self.show_mod_manager()
         self.root.after(100, lambda: self.extended_mod_manager.select_game_in_manager(game_name))

    def _clear_launch_button_ref(self, game_name):
        """Usuwa referencję do przycisku Uruchom/Zamknij, gdy kafelek jest niszczony."""
        if game_name in self._launch_buttons:
            del self._launch_buttons[game_name]
            # logging.debug(f"Usunięto referencję przycisku dla: {game_name}")


    def update_pagination_controls(self, total_items):
        """Aktualizuje stan przycisków i etykiety paginacji."""
        if total_items == 0:
             self._total_pages = 1
             self.current_page = 1
        else:
            self._total_pages = (total_items + self.items_per_page - 1) // self.items_per_page

        # Poprawka, aby current_page nie była większa niż total_pages
        if self.current_page > self._total_pages:
            self.current_page = self._total_pages

        self.page_label.config(text=f"Strona {self.current_page} / {self._total_pages}")

        if self.current_page <= 1:
            self.prev_page_btn.config(state=tk.DISABLED)
        else:
            self.prev_page_btn.config(state=tk.NORMAL)

        if self.current_page >= self._total_pages:
            self.next_page_btn.config(state=tk.DISABLED)
        else:
            self.next_page_btn.config(state=tk.NORMAL)

    def prev_page(self):
        """Przechodzi do poprzedniej strony."""
        if self.current_page > 1:
            self.current_page -= 1
            self.update_game_grid() # Odśwież siatkę dla nowej strony

    def next_page(self):
        """Przechodzi do następnej strony."""
        if self.current_page < self._total_pages:
            self.current_page += 1
            self.update_game_grid() # Odśwież siatkę dla nowej strony

    def reset_pagination(self):
        """Resetuje paginację do pierwszej strony (np. po nowym wyszukiwaniu)."""
        self.current_page = 1

    def _populate_roadmap_and_archive_data(self):
        """Wypełnia danymi Treeview i Kalendarze w zakładkach Roadmapy i Archiwum."""
        logging.debug("Rozpoczynanie ładowania danych Roadmapy i Archiwum...")
        try:
            # Sprawdź, czy widgety istnieją (na wypadek szybkiego przełączania zakładek)
            if hasattr(self, 'roadmap_tree') and self.roadmap_tree.winfo_exists():
                self.load_roadmap() # Ładuje dane do roadmap_tree
            if hasattr(self, 'roadmap_calendar') and self.roadmap_calendar.winfo_exists():
                self.update_calendar() # Aktualizuje kalendarz roadmapy

            if hasattr(self, 'archive_tree') and self.archive_tree.winfo_exists():
                self.load_archive() # Ładuje dane do archive_tree
            if hasattr(self, 'archive_calendar') and self.archive_calendar.winfo_exists():
                self.update_archive_calendar() # Aktualizuje kalendarz archiwum

            # Opcjonalnie: Ukryj wskaźnik ładowania, jeśli go dodałeś
            # if hasattr(self, 'roadmap_loading_label'):
            #     self.roadmap_loading_label.pack_forget()

            logging.debug("Zakończono ładowanie danych Roadmapy i Archiwum.")

        except tk.TclError as e:
            logging.warning(f"Błąd TclError podczas ładowania danych roadmapy/archiwum: {e}")
        except Exception as e:
            logging.exception("Nieoczekiwany błąd podczas ładowania danych roadmapy/archiwum")




# W klasie GameLauncher

    def _create_settings_page_content(self):
        """Tworzy zawartość strony ustawień w self.settings_page_frame."""
        logging.info("Rozpoczynanie tworzenia zawartości ustawień...") # Dodatkowy log na start

        # --- Nagłówek Strony ---
        # ... (bez zmian) ...
        header_frame = ttk.Frame(self.settings_page_frame)
        header_frame.grid(row=0, column=0, sticky="ew", padx=20, pady=(10, 5))
        header_frame.columnconfigure(0, weight=1)
        ttk.Label(header_frame, text="Ustawienia Aplikacji", font=("Helvetica", 18, "bold")).grid(row=0, column=0, sticky="w")


        # --- Przewijalny Obszar na Ustawienia ---
        # ... (kod canvas, scrollbar, scrollable_frame i bindowań bez zmian) ...
        settings_canvas = tk.Canvas(self.settings_page_frame, bg="#1e1e1e", highlightthickness=0)
        settings_scrollbar = ttk.Scrollbar(self.settings_page_frame, orient="vertical", command=settings_canvas.yview)
        scrollable_frame = ttk.Frame(settings_canvas, style="TFrame")
        scrollable_frame_window_id = settings_canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        def _on_canvas_configure(event):
            if settings_canvas.winfo_exists() and scrollable_frame.winfo_exists():
                canvas_width = event.width
                settings_canvas.itemconfig(scrollable_frame_window_id, width=canvas_width)
                # --- DODANO LOGOWANIE BBOX ---
                bbox = settings_canvas.bbox("all")
                logging.debug(f"Settings Canvas Configure - bbox: {bbox}")
                settings_canvas.configure(scrollregion=bbox if bbox else (0,0,1,1))
                # --- KONIEC LOGOWANIA BBOX ---
        settings_canvas.bind("<Configure>", _on_canvas_configure)
        scrollable_frame.bind("<Configure>", lambda e: settings_canvas.configure(scrollregion=settings_canvas.bbox("all")) if settings_canvas.winfo_exists() else None)
        def _on_settings_mousewheel(event):
            try:
                # próbujemy pobrać widget pod kursorem myszy
                widget_under_cursor = self.root.winfo_containing(event.x_root, event.y_root)
            # ⬇⬇⬇   DODAJEMY KeyError i log   ⬇⬇⬇
            except (tk.TclError, KeyError) as e:
                logging.debug(f"Ignorowany błąd w winfo_containing (settings): {e}")
                widget_under_cursor = None


            is_settings_area = False
            curr = widget_under_cursor
            while curr is not None:
                if curr == settings_canvas or curr == scrollable_frame: is_settings_area = True; break
                if curr == self.root: break
                try: curr = curr.master
                except tk.TclError: break
            if is_settings_area and settings_canvas.winfo_exists():
                scroll_val = -1 * int(event.delta / 120)
                view_start, view_end = settings_canvas.yview()
                if (scroll_val < 0 and view_start > 0.0) or (scroll_val > 0 and view_end < 1.0):
                    settings_canvas.yview_scroll(scroll_val, "units")
                    return "break"
        self.root.bind_all("<MouseWheel>", _on_settings_mousewheel, add='+')
        def _safe_scrollbar_set(first, last):
            try:
                settings_scrollbar.set(first, last)
            except tk.TclError:
                pass  # ignorujemy, jeśli scrollbar już nie istnieje

        settings_canvas.configure(yscrollcommand=_safe_scrollbar_set)
        settings_canvas.grid(row=1, column=0, sticky="nsew")
        settings_scrollbar.grid(row=1, column=1, sticky="ns")
        scrollable_frame.columnconfigure(0, weight=1)


        # === SEKCJE USTAWIEŃ ===
        current_row = 0
        logging.debug(f"--- Start sekcji --- current_row: {current_row}")

        # --- Sekcja: Wygląd ---
        appearance_frame = ttk.LabelFrame(scrollable_frame, text=" Wygląd ", padding=(10, 5))
        appearance_frame.grid(row=current_row, column=0, sticky="nsew", padx=20, pady=10)
        appearance_frame.columnconfigure(1, weight=1) 
        
        appearance_current_row = 0 

        # Motyw
        ttk.Label(appearance_frame, text="Aktywny Motyw:").grid(row=appearance_current_row, column=0, padx=5, pady=5, sticky="w")
        self.theme_var = tk.StringVar(value=self.settings.get("theme", "Dark"))
        self.theme_menu = ttk.OptionMenu(appearance_frame, self.theme_var, self.theme_var.get())
        self.theme_menu.grid(row=appearance_current_row, column=1, padx=5, pady=5, sticky="ew")
        self._update_main_theme_selector()
        appearance_current_row += 1

        # Kafelki w rzędzie
        ttk.Label(appearance_frame, text="Kafelki w rzędzie w Bibliotece:").grid(row=appearance_current_row, column=0, padx=5, pady=5, sticky="w")
        self.tiles_per_row_var = tk.IntVar(value=self.local_settings.get("tiles_per_row", 4))
        tiles_spinbox = ttk.Spinbox(appearance_frame, from_=2, to=8, textvariable=self.tiles_per_row_var, width=5, command=self._save_tiles_per_row_setting, state='readonly')
        tiles_spinbox.grid(row=appearance_current_row, column=1, padx=5, pady=5, sticky="w")
        appearance_current_row += 1

        # --- NOWE: Wybór Czcionki ---
        ttk.Label(appearance_frame, text="Czcionka interfejsu:").grid(row=2, column=0, padx=5, pady=5, sticky="w")
        # Pobierz listę dostępnych czcionek (może być długa!)
        # Lepsze podejście: zdefiniuj kilka bezpiecznych, popularnych czcionek
        # lub użyj font.families() ale bądź gotów na długą listę
        available_fonts = ["Segoe UI", "Arial", "Verdana", "Tahoma", "Calibri", "System"]; 
        try: from tkinter import font; system_fonts = list(font.families()); sensible_system_fonts = [f for f in system_fonts if not f.startswith('@')]; available_fonts = sorted(list(set(available_fonts + sensible_system_fonts)), key=str.lower)
        except Exception: pass
        default_font = "Segoe UI" if "Segoe UI" in available_fonts else "System"; self.font_var = tk.StringVar(value=self.local_settings.get("ui_font", default_font))
        font_combo = ttk.Combobox(appearance_frame, textvariable=self.font_var, values=available_fonts, state="readonly", width=30)
        font_combo.grid(row=appearance_current_row, column=1, padx=5, pady=5, sticky="ew")
        font_combo.bind("<<ComboboxSelected>>", self._save_and_apply_font_setting)
        appearance_current_row += 1

        # --- NOWE ZMIANY: Zarządzanie motywami niestandardowymi ---
        custom_theme_frame = ttk.LabelFrame(appearance_frame, text=" Zarządzanie Motywami Niestandardowymi ", padding=10)
        custom_theme_frame.grid(row=3, column=0, columnspan=2, sticky="nsew", padx=5, pady=10) # Dodano w tej samej sekcji
        custom_theme_frame.columnconfigure(0, weight=1)
        custom_theme_frame.rowconfigure(0, weight=1) # Pozwól listboxowi rosnąć

        # Ramka dla Listboxa i Scrollbara motywów
        ct_list_frame = ttk.Frame(custom_theme_frame)
        ct_list_frame.grid(row=0, column=0, columnspan=2, sticky="nsew") # columnspan=2
        ct_list_frame.columnconfigure(0, weight=1); ct_list_frame.rowconfigure(0, weight=1)

        self.custom_themes_listbox = tk.Listbox(ct_list_frame, height=5) # Lista motywów użytkownika
        self.custom_themes_listbox.grid(row=0, column=0, sticky="nsew")
        ct_scrollbar = ttk.Scrollbar(ct_list_frame, orient="vertical", command=self.custom_themes_listbox.yview)
        ct_scrollbar.grid(row=0, column=1, sticky="ns")
        self.custom_themes_listbox.config(yscrollcommand=ct_scrollbar.set)
        self._load_custom_themes_list() # Wczytaj listę

        # Przyciski zarządzania motywami
        ct_buttons_frame = ttk.Frame(custom_theme_frame)
        ct_buttons_frame.grid(row=1, column=0, columnspan=2, pady=(5,0))
        ttk.Button(ct_buttons_frame, text="Dodaj", command=self._add_custom_theme).pack(side=tk.LEFT, padx=2) # Zmniejszono padx
        ttk.Button(ct_buttons_frame, text="Edytuj", command=self._edit_custom_theme).pack(side=tk.LEFT, padx=2)
        ttk.Button(ct_buttons_frame, text="Usuń", command=self._delete_custom_theme).pack(side=tk.LEFT, padx=2)
        # --- NOWE PRZYCISKI ---
        ttk.Button(ct_buttons_frame, text="Eksportuj", command=self._export_custom_theme_dialog).pack(side=tk.LEFT, padx=2)
        ttk.Button(ct_buttons_frame, text="Importuj", command=self._import_custom_theme_dialog).pack(side=tk.LEFT, padx=2)
        # --- KONIEC NOWYCH PRZYCISKÓW ---
        # --- KONIEC NOWYCH ZMIAN ---
        # --- KONIEC ZMIANY ---
        appearance_current_row += 1
        
        # Opcja Nakładki Odtwarzacza
        if not hasattr(self, 'show_track_overlay_var'):
            self.show_track_overlay_var = tk.BooleanVar(
                value=self.local_settings.get("show_track_overlay", False)
            )
        overlay_check = ttk.Checkbutton(
            appearance_frame, 
            text="Pokaż nakładkę 'Teraz Odtwarzane' na ekranie (globalnie)",
            variable=self.show_track_overlay_var,
            command=self._toggle_track_overlay_setting 
        )
        overlay_check.grid(row=appearance_current_row, column=0, columnspan=2, sticky="w", padx=5, pady=(10,5))
        appearance_current_row += 1
        # --- NOWE: Ustawienia pozycji Overlay'a ---
        overlay_position_frame = ttk.Frame(appearance_frame) # Nadal w sekcji "Wygląd"
        overlay_position_frame.grid(row=appearance_current_row, column=0, columnspan=2, sticky="w", padx=5, pady=(5,0))

        ttk.Label(overlay_position_frame, text="Pozycja X nakładki:").grid(row=0, column=0, padx=(0,5), pady=2)
        self.overlay_x_pos_var = tk.IntVar(value=self.local_settings.get("overlay_x_pos", 0)) # Domyślnie 0, jeśli nie ma
        overlay_x_entry = ttk.Entry(overlay_position_frame, textvariable=self.overlay_x_pos_var, width=6)
        overlay_x_entry.grid(row=0, column=1, pady=2)
        # Bindowanie do Enter dla szybkiego zapisu lub przycisk "Zastosuj"
        # overlay_x_entry.bind("<Return>", lambda e: self._apply_overlay_position_from_settings())

        ttk.Label(overlay_position_frame, text="Pozycja Y nakładki:").grid(row=1, column=0, padx=(0,5), pady=2)
        self.overlay_y_pos_var = tk.IntVar(value=self.local_settings.get("overlay_y_pos", 0))
        overlay_y_entry = ttk.Entry(overlay_position_frame, textvariable=self.overlay_y_pos_var, width=6)
        overlay_y_entry.grid(row=1, column=1, pady=2)
        # overlay_y_entry.bind("<Return>", lambda e: self._apply_overlay_position_from_settings())
        
        overlay_pos_buttons_frame = ttk.Frame(appearance_frame)
        overlay_pos_buttons_frame.grid(row=appearance_current_row + 1, column=0, columnspan=2, sticky="w", padx=5, pady=(0,5))

        apply_pos_btn = ttk.Button(overlay_pos_buttons_frame, text="Zastosuj Pozycję", command=self._apply_overlay_position_from_settings)
        apply_pos_btn.pack(side=tk.LEFT, padx=(0,5))
        
        reset_pos_btn = ttk.Button(overlay_pos_buttons_frame, text="Resetuj Pozycję", command=self._reset_overlay_position)
        reset_pos_btn.pack(side=tk.LEFT)
        
        appearance_current_row += 2 # Zajęliśmy dwa dodatkowe wiersze w appearance_frame

        current_row += 1

        # --- Sekcja: Użytkownik ---
        user_frame = ttk.LabelFrame(scrollable_frame, text=" Użytkownik ", padding=(10, 5))
        user_frame.grid(row=current_row, column=0, sticky="nsew", padx=20, pady=10)
        user_frame.columnconfigure(1, weight=1) # Kolumna dla powitania/ścieżki

        # --- NOWE ZMIANY: Wyświetlanie Nazwy i Awatara ---
        # Wyświetlanie Nazwy i Awatara
        user_display_frame = ttk.Frame(user_frame)
        user_display_frame.grid(row=0, column=0, columnspan=3, pady=5, sticky="w")
        # --- ZMIANA: Pobierz rozmiar z ustawień ---
        avatar_size_settings = (self.local_settings.get("avatar_display_size", 48), self.local_settings.get("avatar_display_size", 48))
        # --- KONIEC ZMIANY ---
        self.settings_avatar_label = ttk.Label(user_display_frame, width=avatar_size_settings[0]//8 if avatar_size_settings[0] >= 48 else 6) # Dostosuj placeholder
        self.settings_avatar_label.pack(side=tk.LEFT, padx=5)
        self.settings_username_label = ttk.Label(user_display_frame, text=f"Nazwa: {self.user.get('username', 'Gracz')}", font=("Helvetica", 11, "bold"))
        self.settings_username_label.pack(side=tk.LEFT, padx=10, anchor='w')
        self._load_and_display_settings_avatar() # Wywołaj raz na początku

        # Wywołanie funkcji do załadowania awatara
        self._load_and_display_settings_avatar(avatar_size_settings)
        # --- KONIEC NOWYCH ZMIAN ---

        # Przycisk zmiany nazwy (przesunięty do wiersza 1)
        ttk.Button(user_frame, text="Zmień Nazwę Użytkownika", command=self.change_username).grid(row=1, column=0, columnspan=3, padx=5, pady=5, sticky="w")

        # Zarządzanie ścieżką awatara
        ttk.Label(user_frame, text="Ścieżka Awatara:").grid(row=2, column=0, padx=5, pady=5, sticky="w")
        self.avatar_var = tk.StringVar(value=self.user.get("avatar", ""))
        avatar_entry = ttk.Entry(user_frame, textvariable=self.avatar_var, width=40, state='readonly')
        avatar_entry.grid(row=2, column=1, padx=5, pady=5, sticky="ew")
        avatar_button = ttk.Button(user_frame, text="Wybierz...", command=self.select_avatar)
        avatar_button.grid(row=2, column=2, padx=5, pady=5)
        delete_avatar_btn = ttk.Button(user_frame, text="Usuń Awatar", command=self.delete_avatar)
        delete_avatar_btn.grid(row=3, column=1, columnspan=2, padx=5, pady=(0, 5), sticky="e")

        # --- NOWE: Wybór rozmiaru awatara ---
        avatar_size_control_frame = ttk.Frame(user_frame)
        avatar_size_control_frame.grid(row=4, column=0, columnspan=3, padx=5, pady=(5,10), sticky="w") # W nowym wierszu

        ttk.Label(avatar_size_control_frame, text="Rozmiar Awatara:").pack(side=tk.LEFT, padx=(0,5))
        self.avatar_size_var = tk.IntVar(value=self.local_settings.get("avatar_display_size", 48))
        # Możliwe rozmiary (możesz dostosować)
        avatar_size_options = [32, 48, 64, 96, 128]
        avatar_size_spinbox = ttk.Spinbox(
            avatar_size_control_frame,
            textvariable=self.avatar_size_var,
            values=avatar_size_options,
            width=5,
            command=self._save_and_refresh_avatar_size, # Nowa metoda
            state='readonly'
        )
        avatar_size_spinbox.pack(side=tk.LEFT)
        # --- KONIEC NOWEGO ---
        # TUTAJ WSTAW NOWY PRZYCISK USUWANIA KONTA
        # --- NOWE ZMIANY ---
        # Wstawiamy go w wierszu 5, rozciągając na 3 kolumny
        # --- NOWE ZMIANY ---
        # Zmieniamy tekst przycisku na "Usuń Konto Czatu"
        ttk.Button(user_frame, text="Usuń Konto Czatu", command=self._confirm_delete_chat_account, style="Red.TButton").grid(row=5, column=0, columnspan=3, padx=5, pady=(15, 5), sticky="ew")
        # --- KONIEC NOWYCH ZMIAN ---
        logging.debug(f"Po sekcji Użytkownik - grid_info: {user_frame.grid_info()}, current_row: {current_row}")

        
        current_row += 1

        # --- Sekcja: System  ---
        system_frame = ttk.LabelFrame(scrollable_frame, text=" System ", padding=(10, 5))
        system_frame.grid(row=current_row, column=0, sticky="nsew", padx=20, pady=10)

        self.autostart_var = tk.BooleanVar(value=self.settings.get("autostart", False))
        autostart_check = ttk.Checkbutton(system_frame, text="Uruchamiaj z systemem Windows", variable=self.autostart_var, command=self.toggle_autostart)
        autostart_check.pack(anchor="w", pady=2)

        self.auto_backup_var = tk.BooleanVar(value=self.settings.get("auto_backup_on_exit", True))
        auto_backup_check = ttk.Checkbutton(
            system_frame,
            text="Automatycznie twórz backup zapisów przy zamknięciu gry (nadpisuje poprzedni)",
            variable=self.auto_backup_var,
            command=self._save_auto_backup_setting
        )
        auto_backup_check.pack(anchor="w", pady=2)

        ttk.Button(
            system_frame, text="Resetuj licznik Launchera",
            command=self.reset_launcher_usage_time
        ).pack(anchor="w", pady=2)

        logging.debug(f"Po sekcji System - grid_info: {system_frame.grid_info()}, current_row: {current_row}") # Dodano log dla tej sekcji
        current_row += 1
        # --- Koniec sekcji System ---

        # --- Sekcja: Synchronizacja i API (zmieniona nazwa dla kluczy API) ---
        # Poprzednio nazywała się "Synchronizacja i Backup", ale dodajemy tu też klucze API
        sync_api_frame = ttk.LabelFrame(scrollable_frame, text=" Klucze API i Synchronizacja ", padding=(10, 5)) # Zmieniona nazwa LabelFrame
        sync_api_frame.grid(row=current_row, column=0, sticky="nsew", padx=20, pady=10)
        sync_api_frame.columnconfigure(0, weight=1) # Pozwól zawartości się rozciągać

        # --- NOWE: Ramka specjalnie dla kluczy API ---
        # Ta ramka będzie rodzicem dla sekcji GitHub, RAWG i Last.fm
        api_keys_subframe = ttk.Frame(sync_api_frame, style="TFrame") # Użyj stylu TFrame
        api_keys_subframe.grid(row=0, column=0, sticky="ew", pady=(0,10)) # Pierwszy wiersz w sync_api_frame
        api_keys_subframe.columnconfigure(1, weight=1) # Pozwól polu Entry rosnąć
        # --- KONIEC NOWEGO ---

        # Sekcja GitHub Token (teraz wewnątrz api_keys_subframe)
        github_token_frame = ttk.Frame(api_keys_subframe, style="TFrame") # Rodzicem jest api_keys_subframe
        github_token_frame.grid(row=0, column=0, sticky="ew", pady=(0, 5)) # Wiersz 0 w api_keys_subframe
        github_token_frame.columnconfigure(1, weight=1)
        ttk.Label(github_token_frame, text="GitHub Token:").grid(row=0, column=0, sticky='w', padx=5)
        self.github_token_entry = ttk.Entry(github_token_frame, show='*', width=30)
        self.github_token_entry.grid(row=0, column=1, padx=5, sticky='ew')
        self.github_token_entry.insert(0, self.local_settings.get("github_token", ""))
        ttk.Button(github_token_frame, text="?", width=2, command=self.show_github_token_help).grid(row=0, column=2, padx=5)
        show_gh_token_var = tk.BooleanVar()
        ttk.Checkbutton(github_token_frame, text="Pokaż", variable=show_gh_token_var, command=lambda: self.toggle_show_key(self.github_token_entry, show_gh_token_var)).grid(row=0, column=3, padx=5)
        # Przycisk zapisu GitHub Token (możemy go dać pod wszystkimi polami API)

        # Sekcja RAWG API Key (teraz wewnątrz api_keys_subframe)
        rawg_subframe = ttk.Frame(api_keys_subframe, style="TFrame") # Rodzicem jest api_keys_subframe
        rawg_subframe.grid(row=1, column=0, pady=(5,0), sticky='ew') # Wiersz 1 w api_keys_subframe
        rawg_subframe.columnconfigure(1, weight=1)
        ttk.Label(rawg_subframe, text="RAWG.io API Key:").grid(row=0, column=0, sticky='w', padx=5)
        self.rawg_api_key_entry = ttk.Entry(rawg_subframe, show='*', width=30)
        self.rawg_api_key_entry.grid(row=0, column=1, padx=5, sticky='ew')
        self.rawg_api_key_entry.insert(0, self.local_settings.get("rawg_api_key", ""))
        ttk.Button(rawg_subframe, text="?", width=2, command=self.show_rawg_key_help).grid(row=0, column=2, padx=5)
        show_rawg_key_var = tk.BooleanVar()
        ttk.Checkbutton(rawg_subframe, text="Pokaż", variable=show_rawg_key_var, command=lambda: self.toggle_show_key(self.rawg_api_key_entry, show_rawg_key_var)).grid(row=0, column=3, padx=5)
        # Przycisk zapisu RAWG Key

        # Sekcja Last.fm API Key (teraz wewnątrz api_keys_subframe)
        lastfm_api_frame = ttk.Frame(api_keys_subframe, style="TFrame") # Rodzicem jest api_keys_subframe
        lastfm_api_frame.grid(row=2, column=0, pady=(5,0), sticky='ew') # Wiersz 2 w api_keys_subframe
        lastfm_api_frame.columnconfigure(1, weight=1)
        ttk.Label(lastfm_api_frame, text="Last.fm API Key:").grid(row=0, column=0, sticky='w', padx=5)
        self.lastfm_api_key_entry = ttk.Entry(lastfm_api_frame, show='*', width=30)
        self.lastfm_api_key_entry.grid(row=0, column=1, padx=5, sticky='ew')
        if hasattr(self, 'local_settings'):
            self.lastfm_api_key_entry.insert(0, self.local_settings.get("lastfm_api_key", ""))
        ttk.Button(lastfm_api_frame, text="?", width=2, command=self._show_lastfm_key_help).grid(row=0, column=2, padx=5)
        show_lastfm_key_var = tk.BooleanVar()
        ttk.Checkbutton(lastfm_api_frame, text="Pokaż", variable=show_lastfm_key_var, 
                        command=lambda e=self.lastfm_api_key_entry, v=show_lastfm_key_var: self.toggle_show_key(e, v)
                       ).grid(row=0, column=3, padx=5)

        # Przyciski zapisu dla wszystkich kluczy API (pod polami, wewnątrz api_keys_subframe)
        api_save_buttons_frame = ttk.Frame(api_keys_subframe, style="TFrame")
        api_save_buttons_frame.grid(row=3, column=0, columnspan=4, pady=(10,0), sticky="w") # Wiersz 3 w api_keys_subframe
        ttk.Button(api_save_buttons_frame, text="Zapisz GitHub Token", command=self.save_github_token).pack(side=tk.LEFT, padx=5)
        ttk.Button(api_save_buttons_frame, text="Zapisz RAWG Key", command=self.save_rawg_api_key).pack(side=tk.LEFT, padx=5)
        ttk.Button(api_save_buttons_frame, text="Zapisz Last.fm Key", command=self._save_lastfm_api_key).pack(side=tk.LEFT, padx=5)


        # Separator i reszta opcji synchronizacji (Google Drive, GitHub, Backupy)
        # Te elementy będą teraz w `sync_api_frame`, ale PONIŻEJ `api_keys_subframe`
        ttk.Separator(sync_api_frame, orient='horizontal').grid(row=1, column=0, sticky='ew', pady=15, padx=20) # Wiersz 1 w sync_api_frame

        cloud_services_label = ttk.Label(sync_api_frame, text="Usługi Chmurowe do Synchronizacji:")
        cloud_services_label.grid(row=2, column=0, pady=(5, 2), sticky='w', padx=5) # Wiersz 2 w sync_api_frame
        
        cloud_cb_frame = ttk.Frame(sync_api_frame, style="TFrame")
        cloud_cb_frame.grid(row=3, column=0, sticky='w', padx=5) # Wiersz 3
        self.cloud_services = {"Google Drive": tk.BooleanVar(value=self.settings.get("cloud_service_google_drive", False)), "GitHub": tk.BooleanVar(value=self.settings.get("cloud_service_github", False))}
        ttk.Checkbutton(cloud_cb_frame, text="Google Drive", variable=self.cloud_services["Google Drive"], command=self.update_cloud_services).pack(side=tk.LEFT, padx=5)
        ttk.Checkbutton(cloud_cb_frame, text="GitHub", variable=self.cloud_services["GitHub"], command=self.update_cloud_services).pack(side=tk.LEFT, padx=5)
        
        cloud_btn_frame = ttk.Frame(sync_api_frame, style="TFrame")
        cloud_btn_frame.grid(row=4, column=0, pady=5, sticky='w', padx=5) # Wiersz 4
        ttk.Button(cloud_btn_frame, text="Prześlij", command=self.upload_to_cloud).pack(side=tk.LEFT, padx=5)
        ttk.Button(cloud_btn_frame, text="Pobierz", command=self.download_from_cloud).pack(side=tk.LEFT, padx=5)
        
        ttk.Separator(sync_api_frame, orient='horizontal').grid(row=5, column=0, sticky='ew', pady=15, padx=20) # Wiersz 5
        
        local_backup_label = ttk.Label(sync_api_frame, text="Lokalny Backup:")
        local_backup_label.grid(row=6, column=0, pady=(5, 2), sticky='w', padx=5) # Wiersz 6
        
        local_btn_frame = ttk.Frame(sync_api_frame, style="TFrame")
        local_btn_frame.grid(row=7, column=0, pady=5, sticky='w', padx=5) # Wiersz 7
        ttk.Button(local_btn_frame, text="Zgraj Backup", command=self.backup_to_local_folder).pack(side=tk.LEFT, padx=5)
        ttk.Button(local_btn_frame, text="Wczytaj Backup", command=self.load_local_backup).pack(side=tk.LEFT, padx=5)

        logging.debug(f"Po sekcji Synchronizacja i API - grid_info: {sync_api_frame.grid_info()}, current_row: {current_row}")
        current_row += 1

        # --- NOWA SEKCJA: Skanowanie Screenshotów ---
        screenshot_scan_frame = ttk.LabelFrame(scrollable_frame, text=" Skanowanie Screenshotów ", padding=(10, 5))
        screenshot_scan_frame.grid(row=current_row, column=0, sticky="nsew", padx=20, pady=10)
        screenshot_scan_frame.columnconfigure(0, weight=1) # Pozwól listboxowi rosnąć

        # Ramka dla Listboxa i Scrollbara folderów
        ss_list_manage_frame = ttk.Frame(screenshot_scan_frame)
        ss_list_manage_frame.grid(row=0, column=0, sticky="nsew", pady=5, padx=5)
        ss_list_manage_frame.columnconfigure(0, weight=1)
        ss_list_manage_frame.rowconfigure(0, weight=1)

        ss_listbox_frame = ttk.Frame(ss_list_manage_frame)
        ss_listbox_frame.grid(row=0, column=0, sticky='nsew')
        ss_listbox_frame.rowconfigure(0, weight=1)
        ss_listbox_frame.columnconfigure(0, weight=1)

        self.autoscan_folders_listbox = tk.Listbox(ss_listbox_frame, height=4) # Ustaw wysokość listboxa
        self.autoscan_folders_listbox.grid(row=0, column=0, sticky='nsew')
        ss_scan_scrollbar = ttk.Scrollbar(ss_listbox_frame, orient="vertical", command=self.autoscan_folders_listbox.yview)
        ss_scan_scrollbar.grid(row=0, column=1, sticky='ns')
        self.autoscan_folders_listbox.config(yscrollcommand=ss_scan_scrollbar.set)
        self.load_autoscan_folders_list() # Załaduj listę

        # Ramka dla przycisków zarządzania folderami
        ss_buttons_frame = ttk.Frame(ss_list_manage_frame)
        ss_buttons_frame.grid(row=0, column=1, sticky='ns', padx=5)
        ttk.Button(ss_buttons_frame, text="Dodaj", command=self.add_autoscan_folder).pack(pady=2, fill='x')
        ttk.Button(ss_buttons_frame, text="Usuń", command=self.remove_autoscan_folder).pack(pady=2, fill='x')
        # --- NOWE ZMIANY: Sekcja ignorowanych folderów screenshotów ---
        # Etykieta wyjaśniająca
        ss_ignore_label = ttk.Label(screenshot_scan_frame, text="Nazwy folderów do ignorowania podczas skanowania screenshotów (jedna na linię):")
        ss_ignore_label.grid(row=2, column=0, columnspan=2, sticky='w', padx=5, pady=(15, 2)) # Zwiększono pady

        # Ramka dla pola Text i Scrollbara ignorowanych
        ss_ignore_text_frame = ttk.Frame(screenshot_scan_frame)
        ss_ignore_text_frame.grid(row=3, column=0, columnspan=2, sticky='nsew', padx=5, pady=2) # Zmieniono wiersz
        ss_ignore_text_frame.columnconfigure(0, weight=1)
        ss_ignore_text_frame.rowconfigure(0, weight=1)

        self.ss_ignored_folders_text = tk.Text(ss_ignore_text_frame, height=4, wrap=tk.WORD, relief=tk.FLAT) # Ustawiono wysokość
        # Stylizacja pola Text (jak w skanowaniu gier)
        style = ttk.Style()
        text_bg = style.lookup('TEntry', 'fieldbackground')
        text_fg = style.lookup('TEntry', 'foreground')
        self.ss_ignored_folders_text.config(background=text_bg, foreground=text_fg, relief=tk.SOLID, borderwidth=1)
        self.ss_ignored_folders_text.grid(row=0, column=0, sticky='nsew')

        ss_ignore_scrollbar = ttk.Scrollbar(ss_ignore_text_frame, orient="vertical", command=self.ss_ignored_folders_text.yview)
        ss_ignore_scrollbar.grid(row=0, column=1, sticky='ns')
        self.ss_ignored_folders_text.config(yscrollcommand=ss_ignore_scrollbar.set)
        self.load_screenshot_ignored_folders() # Załaduj listę

        # Przycisk zapisu ignorowanych folderów screenshotów
        save_ss_ignore_btn = ttk.Button(screenshot_scan_frame, text="Zapisz Ignorowane Foldery Screenshotów", command=self.save_screenshot_ignored_folders)
        save_ss_ignore_btn.grid(row=4, column=0, columnspan=2, pady=(5, 10)) # Zmieniono wiersz
        # --- KONIEC NOWYCH ZMIAN ---

        # Checkbox - Skanuj przy starcie
        self.autoscan_on_startup_var = tk.BooleanVar(value=self.settings.get("autoscan_on_startup", False))
        autoscan_startup_check = ttk.Checkbutton(
            screenshot_scan_frame,
            text="Skanuj screenshoty automatycznie przy uruchomieniu launchera",
            variable=self.autoscan_on_startup_var,
            command=self._save_autoscan_startup_setting # Zapisz ustawienie
        )
        autoscan_startup_check.grid(row=1, column=0, sticky='w', padx=5, pady=5)

        # Przycisk skanowania teraz (globalny)
        start_screenshot_scan_btn = ttk.Button(screenshot_scan_frame, text="Skanuj Screenshoty Teraz (Wszystkie Gry)", command=self.start_scan_screenshots_thread)
        start_screenshot_scan_btn.grid(row=2, column=0, pady=10)

        current_row += 1
        # --- KONIEC NOWEJ SEKCJI ---

        # --- Sekcja: Emulatory ---
        logging.debug(f"--- Tworzenie sekcji Emulatorów --- current_row: {current_row}") # LOG PRZED
        emulators_frame = ttk.LabelFrame(scrollable_frame, text=" Emulatory ", padding=(10, 5))
        emulators_frame.grid(row=current_row, column=0, sticky="nsew", padx=20, pady=10)
        emulators_frame.columnconfigure(0, weight=1)
        # ... (zawartość sekcji Emulatory, Treeview, przyciski) ...
        emu_list_frame = ttk.Frame(emulators_frame); emu_list_frame.grid(row=0, column=0, sticky="ew", pady=5, padx=5); emu_list_frame.columnconfigure(0, weight=1)
        emu_cols = ("Nazwa", "Ścieżka"); self.emulators_tree = ttk.Treeview(emu_list_frame, columns=emu_cols, show="headings", height=4, selectmode="browse"); self.emulators_tree.heading("Nazwa", text="Nazwa Emulatora"); self.emulators_tree.heading("Ścieżka", text="Ścieżka do .exe"); self.emulators_tree.column("Nazwa", width=200, anchor=tk.W); self.emulators_tree.column("Ścieżka", width=400, anchor=tk.W); emu_scrollbar = ttk.Scrollbar(emu_list_frame, orient="vertical", command=self.emulators_tree.yview); self.emulators_tree.configure(yscrollcommand=emu_scrollbar.set); self.emulators_tree.grid(row=0, column=0, sticky="nsew"); emu_scrollbar.grid(row=0, column=1, sticky="ns")
        emu_buttons_frame = ttk.Frame(emulators_frame); emu_buttons_frame.grid(row=1, column=0, pady=(5, 10))
        ttk.Button(emu_buttons_frame, text="Dodaj Emulator", command=self._add_edit_emulator).pack(side=tk.LEFT, padx=5); ttk.Button(emu_buttons_frame, text="Edytuj Zaznaczony", command=lambda: self._add_edit_emulator(edit_mode=True)).pack(side=tk.LEFT, padx=5); ttk.Button(emu_buttons_frame, text="Usuń Zaznaczony", command=self._delete_emulator).pack(side=tk.LEFT, padx=5)
        self._load_emulators_list() # Wywołaj ładowanie
        # --- DODANO SPRAWDZENIE GRID INFO ---
        self.root.update_idletasks() # Wymuś aktualizację geometrii przed sprawdzeniem
        logging.debug(f"Po sekcji Emulatory - grid_info: {emulators_frame.grid_info()}, current_row: {current_row}")
        # --- KONIEC SPRAWDZENIA ---
        current_row += 1



        # --- Sekcja: Newsy (RSS) ---
        news_settings_frame = ttk.LabelFrame(scrollable_frame, text=" Newsy (RSS) ", padding=(10, 5))
        news_settings_frame.grid(row=current_row, column=0, sticky="nsew", padx=20, pady=10)
        # ... (zawartość sekcji Newsów) ...
        news_settings_frame.columnconfigure(0, weight=1); ttk.Label(news_settings_frame, text="Zarządzanie Kanałami RSS:").grid(row=0, column=0, sticky='w', pady=5); rss_list_outer_frame = ttk.Frame(news_settings_frame); rss_list_outer_frame.grid(row=1, column=0, sticky='nsew', pady=5); rss_list_outer_frame.columnconfigure(0, weight=1); self.rss_management_frame = ttk.Frame(rss_list_outer_frame); self.rss_management_frame.grid(sticky='nsew'); self.populate_rss_management_frame(); rss_buttons_frame = ttk.Frame(news_settings_frame); rss_buttons_frame.grid(row=2, column=0, pady=5); ttk.Button(rss_buttons_frame, text="Dodaj Kanał RSS", command=self.add_rss_feed_from_settings).pack(side=tk.LEFT, padx=5); ttk.Separator(news_settings_frame, orient='horizontal').grid(row=3, column=0, sticky='ew', pady=10, padx=10); post_limit_frame = ttk.Frame(news_settings_frame); post_limit_frame.grid(row=4, column=0, pady=5); ttk.Label(post_limit_frame, text="Liczba wyświetlanych newsów:").pack(side=tk.LEFT, padx=5); self.post_limit_var = tk.IntVar(value=self.settings.get("news_post_limit", 10)); ttk.Spinbox(post_limit_frame, from_=1, to=100, textvariable=self.post_limit_var, width=5, command=self.update_post_limit).pack(side=tk.LEFT)
        logging.debug(f"Po sekcji Newsy - grid_info: {news_settings_frame.grid_info()}, current_row: {current_row}")
        current_row += 1

        # --- Sekcja: Narzędzia Biblioteki ---
        tools_frame = ttk.LabelFrame(scrollable_frame, text=" Narzędzia Biblioteki ", padding=(10, 5))
        tools_frame.grid(row=current_row, column=0, sticky="nsew", padx=20, pady=10)
        # ... (zawartość sekcji Narzędzia) ...
        ttk.Button(tools_frame, text="Znajdź Potencjalne Duplikaty", command=self.start_duplicate_scan_thread).pack(pady=5)
        logging.debug(f"Po sekcji Narzędzia - grid_info: {tools_frame.grid_info()}, current_row: {current_row}")
        current_row += 1

        # --- Sekcja: Aktualizacje ---
        update_frame = ttk.LabelFrame(scrollable_frame, text=" Aktualizacje Aplikacji ", padding=(10, 5))
        update_frame.grid(row=current_row, column=0, sticky="nsew", padx=20, pady=10)
        # ... (zawartość sekcji Aktualizacje) ...
        ttk.Button(update_frame, text="Sprawdź Aktualizacje Teraz", command=self.manual_check_updates).pack(pady=5); ttk.Label(update_frame, text=f"Aktualna wersja: {PROGRAM_VERSION}").pack(pady=5)
        logging.debug(f"Po sekcji Aktualizacje - grid_info: {update_frame.grid_info()}, current_row: {current_row}")
        current_row += 1

        # --- NOWA SEKCJA: Discord Rich Presence ---
        discord_frame = ttk.LabelFrame(scrollable_frame, text=" Integracja z Discord ", padding=(10, 5))
        discord_frame.grid(row=current_row, column=0, sticky="nsew", padx=20, pady=10)
        discord_frame.columnconfigure(1, weight=1)

        # Włącz/Wyłącz
        self.discord_rpc_enabled_var = tk.BooleanVar(value=self.local_settings.get("discord_rpc_enabled", False)) # Domyślnie wyłączone
        discord_enable_check = ttk.Checkbutton(
            discord_frame,
            text="Włącz Discord Rich Presence (pokaż status w Discord)",
            variable=self.discord_rpc_enabled_var,
            command=self._toggle_discord_rpc # Funkcja do (de)aktywacji
        )
        discord_enable_check.grid(row=0, column=0, columnspan=2, sticky="w", padx=5, pady=5)

        # Własny tekst statusu
        ttk.Label(discord_frame, text="Tekst statusu (gdy w menu):").grid(row=1, column=0, padx=5, pady=5, sticky="w")
        self.discord_status_text_var = tk.StringVar(value=self.local_settings.get("discord_status_text", "Korzysta z Game Launcher"))
        discord_status_entry = ttk.Entry(discord_frame, textvariable=self.discord_status_text_var, width=40)
        discord_status_entry.grid(row=1, column=1, padx=5, pady=5, sticky="ew")
                # --- NOWE: Bindowanie zapisu po utracie fokusu (WSTAW TUTAJ) ---
        discord_status_entry.bind("<FocusOut>", lambda e: self._save_discord_settings())
        # --- KONIEC NOWEGO ---
        # Przycisk zapisu dla tekstu (lub zapisuj automatycznie przy zmianie?) - na razie przycisk
        # ttk.Button(discord_frame, text="Zapisz Tekst", command=self._save_discord_settings).grid(row=1, column=2, padx=5)

        current_row += 1 # Zwiększ po sekcji Discord
        # --- KONIEC NOWEJ SEKCJI ---

        # --- NOWA SEKCJA: Zdalne Sterowanie ---
        remote_frame = ttk.LabelFrame(scrollable_frame, text=" Zdalne Sterowanie (Telefon/Przeglądarka) ", padding=(10, 5))
        remote_frame.grid(row=current_row, column=0, sticky="nsew", padx=20, pady=10)
        remote_frame.columnconfigure(1, weight=1) # Pozwól etykiecie URL rosnąć

        # Checkbutton Włącz/Wyłącz
        self.remote_server_enabled_var = tk.BooleanVar(value=self.local_settings.get("remote_control_enabled", False))
        remote_enable_check = ttk.Checkbutton(
            remote_frame,
            text="Włącz zdalne sterowanie (uruchamianie gier przez przeglądarkę w sieci lokalnej)",
            variable=self.remote_server_enabled_var,
            command=self._toggle_remote_server
        )
        remote_enable_check.grid(row=0, column=0, columnspan=3, sticky="w", padx=5, pady=5) # Zmieniono columnspan

        # Etykieta pokazująca adres URL
        ttk.Label(remote_frame, text="Adres do wpisania w przeglądarce telefonu (w tej samej sieci Wi-Fi):").grid(row=1, column=0, columnspan=3, sticky="w", padx=5, pady=(10, 0)) # Zmieniono columnspan
        self.remote_url_label = ttk.Label(remote_frame, text="Serwer wyłączony", font=("Segoe UI", 9, "bold"), foreground="gray", wraplength=450)
        self.remote_url_label.grid(row=2, column=0, columnspan=3, sticky="w", padx=5, pady=(0, 10)) # Zmieniono columnspan

        # --- NOWE ZMIANY: Pole do zmiany portu ---
        port_frame = ttk.Frame(remote_frame) # Ramka dla portu i przycisku zapisu
        port_frame.grid(row=3, column=0, columnspan=3, sticky="w", padx=5, pady=5) # Zmieniono columnspan

        ttk.Label(port_frame, text="Port serwera:").pack(side=tk.LEFT, padx=(0, 5))
        # Użyj IntVar dla łatwiejszej walidacji
        self.remote_port_var = tk.IntVar(value=self.local_settings.get("remote_control_port", 5000))
        port_entry = ttk.Entry(port_frame, textvariable=self.remote_port_var, width=6)
        port_entry.pack(side=tk.LEFT)
        # Przycisk zapisu portu
        save_port_btn = ttk.Button(port_frame, text="Zapisz Port", command=self._save_remote_port)
        save_port_btn.pack(side=tk.LEFT, padx=(10, 0))
        # --- KONIEC NOWYCH ZMIAN ---

        current_row += 1
        # --- KONIEC SEKCJI ---

        # --- NOWA SEKCJA: Skróty Klawiszowe Odtwarzacza Muzyki ---
        # 1. NAJPIERW stwórz główną ramkę dla tej sekcji
        hotkeys_frame_outer = ttk.LabelFrame(scrollable_frame, text=" Skróty Klawiszowe Odtwarzacza Muzyki ", padding=(10, 5))
        hotkeys_frame_outer.grid(row=current_row, column=0, sticky="nsew", padx=20, pady=10)
        hotkeys_frame_outer.columnconfigure(1, weight=1) 

        # Zmienne do przechowywania referencji (przeniesione z __init__ tutaj lub do __init__ jeśli wolisz)
        if not hasattr(self, 'music_hotkey_entries'): # Inicjalizuj, jeśli nie istnieje
            self.music_hotkey_entries = {}
        if not hasattr(self, 'music_hotkey_vars'):
            self.music_hotkey_vars = {}
        
        # Zapisz referencję do ramki, jeśli będziesz jej potrzebował w innych metodach
        self.hotkeys_frame_outer = hotkeys_frame_outer # <-- Dodane dla pewności

        hotkey_row = 0 # Lokalny licznik wierszy dla elementów wewnątrz hotkeys_frame_outer

        # 2. TERAZ stwórz Checkbutton jako dziecko hotkeys_frame_outer
        self.music_hotkeys_enabled_var = tk.BooleanVar(
            value=self.local_settings.get("music_hotkeys_enabled", True)
        )
        enable_hotkeys_check = ttk.Checkbutton(
            hotkeys_frame_outer, # Rodzicem jest hotkeys_frame_outer
            text="Włącz globalne skróty klawiszowe dla odtwarzacza muzyki",
            variable=self.music_hotkeys_enabled_var,
            command=self._toggle_music_hotkeys_enabled # Ta metoda będzie aktualizować stan innych kontrolek
        )
        enable_hotkeys_check.grid(row=hotkey_row, column=0, columnspan=3, pady=(0,10), sticky="w", padx=5) # Dodano padx
        hotkey_row += 1

        # 3. Zdefiniuj akcje i pętlę tworzącą pola dla poszczególnych skrótów
        hotkey_actions = {
            "play_pause": "Odtwórz / Pauza",
            "next_track": "Następny utwór",
            "prev_track": "Poprzedni utwór",
            "stop_music": "Zatrzymaj",
            "volume_up": "Głośniej",
            "volume_down": "Ciszej"
        }
        # Mapowanie dla _set_music_hotkey_dialog, aby miało dostęp do nazw wyświetlanych
        if not hasattr(self, 'hotkey_actions_display_names'): 
            self.hotkey_actions_display_names = hotkey_actions.copy()
        
        current_hotkeys = self.local_settings.get("music_hotkeys", DEFAULT_MUSIC_HOTKEYS.copy())

        for action_key, display_name in hotkey_actions.items():
            ttk.Label(hotkeys_frame_outer, text=f"{display_name}:").grid(row=hotkey_row, column=0, padx=5, pady=3, sticky="w")
            
            shortcut_var = tk.StringVar(value=current_hotkeys.get(action_key, ""))
            self.music_hotkey_vars[action_key] = shortcut_var

            shortcut_entry = ttk.Entry(hotkeys_frame_outer, textvariable=shortcut_var, state="readonly", width=25)
            shortcut_entry.grid(row=hotkey_row, column=1, padx=5, pady=3, sticky="ew")
            self.music_hotkey_entries[action_key] = shortcut_entry
            
            set_button = ttk.Button(hotkeys_frame_outer, text="Ustaw", 
                                    command=lambda k=action_key, v=shortcut_var, e=shortcut_entry: self._set_music_hotkey_dialog(k, v, e))
            set_button.grid(row=hotkey_row, column=2, padx=5, pady=3)
            # Zapisz referencję do przycisku "Ustaw", aby móc go włączać/wyłączać
            if not hasattr(self, 'music_hotkey_set_buttons'):
                self.music_hotkey_set_buttons = {}
            self.music_hotkey_set_buttons[action_key] = set_button
            hotkey_row += 1
        
        # 4. Przycisk resetowania do domyślnych
        self.reset_hotkeys_btn = ttk.Button(hotkeys_frame_outer, text="Przywróć Domyślne Skróty", command=self._reset_music_hotkeys)
        self.reset_hotkeys_btn.grid(row=hotkey_row, column=0, columnspan=3, pady=(10,5))
        hotkey_row += 1 # Dla spójności, jeśli coś dodasz poniżej

        # 5. Wywołaj _toggle_music_hotkeys_enabled() RAZ na końcu tworzenia tej sekcji,
        #    aby ustawić początkowy stan (aktywny/nieaktywny) dla wszystkich kontrolek skrótów.
        self._toggle_music_hotkeys_enabled() 

        current_row += 1
        # --- KONIEC SEKCJI SKRÓTÓW ---

        # --- NOWA SEKCJA: Narzędzia Deweloperskie ---
        developer_tools_frame = ttk.LabelFrame(scrollable_frame, text=" Narzędzia Deweloperskie ", padding=(10, 5))
        developer_tools_frame.grid(row=current_row, column=0, sticky="nsew", padx=20, pady=10)
        developer_tools_frame.columnconfigure(0, weight=1) # Daj miejscu na przyciski/zawartość
        
        # Przycisk otwierający konsolę deweloperską
        ttk.Button(developer_tools_frame, text="Pokaż Konsolę Deweloperską", command=self._show_developer_console).pack(pady=5)
        
        # Pusta przestrzeń na dole dla przewijania (przesunięta)
        spacer_frame = ttk.Frame(scrollable_frame, height=20)
        spacer_frame.grid(row=current_row + 1, column=0)
        
        current_row += 2 # Ta sekcja zajmuje 2 rzędy (developer_tools_frame + spacer_frame)
        # --- KONIEC NOWEJ SEKCJI ---


        # --- Pusta przestrzeń na dole dla przewijania ---
        spacer_frame = ttk.Frame(scrollable_frame, height=20)
        spacer_frame.grid(row=current_row, column=0)
        logging.debug(f"Po Spacer - grid_info: {spacer_frame.grid_info()}, current_row: {current_row}")
        current_row += 1

        logging.info("Zakończono tworzenie zawartości ustawień.")
        # --- Dodajmy wymuszenie aktualizacji scrollregion po chwili ---
        self.root.after(50, lambda: settings_canvas.configure(scrollregion=settings_canvas.bbox("all")) if settings_canvas.winfo_exists() else None)

    # --- NOWA METODA ---
    def _save_and_refresh_avatar_size(self):
        """Zapisuje wybraną wielkość awatara i odświeża podglądy."""
        try:
            new_size = self.avatar_size_var.get() # Spinbox zwraca int
            current_size = self.local_settings.get("avatar_display_size", 48)

            if new_size != current_size:
                self.local_settings["avatar_display_size"] = new_size
                save_local_settings(self.local_settings)
                logging.info(f"Zmieniono rozmiar wyświetlania awatara na: {new_size}x{new_size}")

                # Odśwież awatary w UI
                self._load_and_display_settings_avatar() # W ustawieniach
                self.create_home_page() # Przebuduj stronę główną (najprostszy sposób na odświeżenie awatara tam)
            else:
                logging.debug("Rozmiar awatara nie został zmieniony.")
        except tk.TclError:
            logging.error("Błąd TclError podczas odczytu rozmiaru awatara ze Spinboxa.")
            # Przywróć poprzednią wartość, jeśli coś poszło nie tak
            self.avatar_size_var.set(self.local_settings.get("avatar_display_size", 48))
        except Exception as e:
            logging.exception(f"Nieoczekiwany błąd podczas zapisywania/odświeżania rozmiaru awatara: {e}")
    # --- KONIEC NOWEJ METODY ---

    def populate_rss_management_frame(self):
        """Wypełnia ramkę zarządzania RSS w ustawieniach."""
        if not hasattr(self, 'rss_management_frame') or not self.rss_management_frame.winfo_exists():
             return # Nie rób nic, jeśli ramka nie istnieje

        # Wyczyść starą zawartość
        for widget in self.rss_management_frame.winfo_children():
            widget.destroy()

        self.rss_vars = [] # Resetuj listę zmiennych
        for idx, feed in enumerate(self.settings.get("rss_feeds", [])):
            var = tk.BooleanVar(value=feed.get("active", True))
            self.rss_vars.append(var) # Dodaj zmienną do listy

            frame = ttk.Frame(self.rss_management_frame)
            frame.pack(fill='x', pady=1, padx=5) # Użyj pack dla prostszej listy pionowej
            cb = ttk.Checkbutton(frame, text=feed.get("name", feed["url"]), variable=var, command=self.update_rss_feeds)
            cb.pack(side="left", expand=True, fill='x')
            # Użyj lambda z indeksem lub obiektem feed do usunięcia
            del_btn = ttk.Button(frame, text="Usuń", command=lambda f=feed: self.remove_specific_rss_feed(f))
            del_btn.pack(side="right")

    def add_rss_feed_from_settings(self):
        """Dodaje nowy kanał RSS z poziomu strony ustawień."""
        new_feed_url = simpledialog.askstring("Dodaj RSS Feed", "Podaj URL RSS Feed:")
        if new_feed_url:
            new_feed_name = simpledialog.askstring("Nazwa RSS Feed", "Podaj nazwę RSS Feed (opcjonalnie):")
            if not new_feed_name: new_feed_name = new_feed_url

            rss_list = self.settings.setdefault("rss_feeds", [])
            if any(feed["url"] == new_feed_url for feed in rss_list):
                messagebox.showwarning("Błąd", "Ten RSS Feed już istnieje.")
                return

            rss_list.append({"url": new_feed_url, "active": True, "name": new_feed_name})
            save_config(self.config)
            messagebox.showinfo("Sukces", "RSS Feed został dodany.")
            self.populate_rss_management_frame() # Odśwież listę w ustawieniach

            # Odśwież newsy, jeśli są aktualnie wyświetlane
            if self.current_frame == self.news_frame:
                 self.load_news_threaded()

    def _toggle_music_hotkeys_enabled(self):
        """Zapisuje stan włączenia/wyłączenia skrótów i je (re)rejestruje oraz aktualizuje UI."""
        enabled = self.music_hotkeys_enabled_var.get()
        self.local_settings["music_hotkeys_enabled"] = enabled
        save_local_settings(self.local_settings)
        logging.info(f"Globalne skróty muzyczne {'włączone' if enabled else 'wyłączone'}.")
        
        if enabled:
            self._register_music_hotkeys()
        else:
            if self.global_hotkeys_listener and self.global_hotkeys_listener.is_alive():
                self.global_hotkeys_listener.stop()
                self.global_hotkeys_listener = None
                logging.info("Zatrzymano listenera GlobalHotKeys (skróty wyłączone).")
        
        # Zaktualizuj stan kontrolek w UI
        new_state = tk.NORMAL if enabled else tk.DISABLED
        
        for action_key, entry_widget in self.music_hotkey_entries.items():
            if entry_widget.winfo_exists():
                entry_widget.config(state="readonly" if enabled else tk.DISABLED) # Entry jest readonly lub disabled
        
        if hasattr(self, 'music_hotkey_set_buttons'): # Sprawdź, czy słownik istnieje
            for action_key, button_widget in self.music_hotkey_set_buttons.items():
                if button_widget.winfo_exists():
                    button_widget.config(state=new_state)
        
        if hasattr(self, 'reset_hotkeys_btn') and self.reset_hotkeys_btn.winfo_exists():
            self.reset_hotkeys_btn.config(state=new_state)

    def _reset_music_hotkeys(self):
        """Przywraca domyślne skróty klawiszowe dla odtwarzacza muzyki."""
        if messagebox.askyesno("Resetuj Skróty", 
                               "Czy na pewno chcesz przywrócić domyślne skróty klawiszowe dla odtwarzacza?\n"
                               "Nowe skróty zaczną działać natychmiast.", 
                               parent=self.settings_page_frame if hasattr(self, 'settings_page_frame') else self.root):
            
            self.local_settings["music_hotkeys"] = DEFAULT_MUSIC_HOTKEYS.copy()
            save_local_settings(self.local_settings)
            
            # Odśwież pola Entry w UI
            for action_key, string_var in self.music_hotkey_vars.items():
                string_var.set(self.local_settings["music_hotkeys"].get(action_key, "")) # Użyj .get() dla bezpieczeństwa
            
            logging.info("Przywrócono domyślne skróty klawiszowe dla muzyki.")
            
            # --- KLUCZOWA ZMIANA: Odśwież zarejestrowane globalne skróty ---
            self.root.after(10, self._reregister_all_global_hotkeys) # Użyj after dla bezpieczeństwa
            # --- KONIEC KLUCZOWEJ ZMIANY ---
            
            messagebox.showinfo("Przywrócono Domyślne", 
                                "Domyślne skróty klawiszowe zostały przywrócone i powinny być aktywne.", 
                                parent=self.settings_page_frame if hasattr(self, 'settings_page_frame') else self.root)

    def remove_specific_rss_feed(self, feed_to_remove):
        """Usuwa konkretny kanał RSS i odświeża UI ustawień."""
        confirm = messagebox.askyesno("Usuń RSS Feed", f"Czy na pewno chcesz usunąć RSS Feed:\n{feed_to_remove.get('name', feed_to_remove['url'])}?")
        if confirm:
            rss_list = self.settings.get("rss_feeds", [])
            # Usuń przez porównanie słowników lub unikalnego URL
            original_length = len(rss_list)
            self.settings["rss_feeds"] = [feed for feed in rss_list if feed['url'] != feed_to_remove['url']]

            if len(self.settings["rss_feeds"]) < original_length:
                save_config(self.config)
                messagebox.showinfo("Sukces", "RSS Feed został usunięty.")
                self.populate_rss_management_frame() # Odśwież listę w ustawieniach
                # Odśwież newsy, jeśli są aktualnie wyświetlane
                if self.current_frame == self.news_frame:
                    self.load_news_threaded()
            else:
                 messagebox.showerror("Błąd", "Nie udało się znaleźć i usunąć kanału RSS.")

    # Upewnij się, że update_rss_feeds używa self.rss_vars
    def update_rss_feeds(self):
        """Aktualizuje status aktywności kanałów RSS."""
        rss_list = self.settings.get("rss_feeds", [])
        # Upewnij się, że liczba zmiennych zgadza się z liczbą kanałów
        if len(self.rss_vars) == len(rss_list):
            for idx, feed in enumerate(rss_list):
                feed["active"] = self.rss_vars[idx].get()
            save_config(self.config)
            # Nie trzeba tu pokazywać messagebox, zmiana jest widoczna
            # messagebox.showinfo("Sukces", "Ustawienia RSS Feeds zostały zaktualizowane.")
            logging.info("Zaktualizowano statusy aktywności RSS.")
            if self.current_frame == self.news_frame:
                 self.load_news_threaded()
        else:
             logging.error("Niezgodność liczby zmiennych RSS i listy kanałów!")
             messagebox.showerror("Błąd wewnętrzny", "Niezgodność danych RSS. Spróbuj ponownie otworzyć ustawienia.")

    def _save_chat_server_url(self):
        """Zapisuje nowy URL serwera czatu i aktualizuje go w instancji."""
        new_url = self.chat_server_url_var.get().strip()
        if not new_url:
            messagebox.showwarning("Brak URL", "Adres URL serwera czatu nie może być pusty.", 
                                 parent=self.settings_page_frame if hasattr(self, 'settings_page_frame') else self.root)
            self.chat_server_url_var.set(self.chat_server_url) # Przywróć stary
            return

        if not active_server_data:
            messagebox.showerror("Błąd", "Brak aktywnego serwera do zaktualizowania URL.", parent=self.root) # Dostosuj parent
            return

        # Prosta walidacja (można rozbudować)
        if not (new_url.startswith("http://") or new_url.startswith("https://")):
            messagebox.showerror("Nieprawidłowy URL", "Adres URL serwera czatu musi zaczynać się od http:// lub https://",
                               parent=self.settings_page_frame if hasattr(self, 'settings_page_frame') else self.root)
            self.chat_server_url_var.set(self.chat_server_url) # Przywróć stary
            return
            
        if self.local_settings.get("chat_server_url") != new_url:
            self.local_settings["chat_server_url"] = new_url
            save_local_settings(self.local_settings)
            self.chat_server_url = new_url # Zaktualizuj atrybut w instancji GameLauncher
            
            logging.info(f"Zmieniono adres URL serwera czatu na: {new_url}")
            messagebox.showinfo("Zapisano URL", 
                                f"Nowy adres serwera czatu ({new_url}) został zapisany.\n"
                                "Jeśli byłeś połączony z czatem, rozłącz się i połącz ponownie, aby użyć nowego adresu.",
                                parent=self.settings_page_frame if hasattr(self, 'settings_page_frame') else self.root)
            
            # Jeśli użytkownik jest aktualnie połączony z czatem, powinien się rozłączyć,
            # bo zmienił URL serwera.
            if self.sio and self.sio.connected:
                self._chat_logout() # To powinno rozłączyć i zresetować UI czatu
        else:
            messagebox.showinfo("Informacja", "Adres URL serwera czatu nie został zmieniony.",
                                parent=self.settings_page_frame if hasattr(self, 'settings_page_frame') else self.root)

    def _normalize_game_name_for_duplicates(self, name):
        """Tworzy 'klucz' do porównywania nazw gier, ignorując drobne różnice."""
        # Konwertuj na małe litery
        normalized = name.lower()
        # Usuń znaki specjalne, spacje, cyfry (bardziej agresywnie niż guess_game_name)
        normalized = re.sub(r'[^a-z]', '', normalized) # Usuń wszystko co nie jest literą a-z
        # Można dodać bardziej zaawansowane techniki jak Stemming lub Soundex, ale zacznijmy prosto
        return normalized

    def start_duplicate_scan_thread(self):
        """Uruchamia skanowanie w poszukiwaniu duplikatów w osobnym wątku."""
        if not self.games:
             messagebox.showinfo("Informacja", "Biblioteka gier jest pusta.")
             return

        self.show_progress_window("Wyszukiwanie duplikatów...")
        self.progress_bar['mode'] = 'indeterminate'
        self.progress_bar.start()
        self.progress_label.config(text="Analizowanie biblioteki...")

        scan_thread = threading.Thread(target=self.find_potential_duplicates, daemon=True)
        scan_thread.start()

    def _save_auto_backup_setting(self):
        """Zapisuje ustawienie automatycznego backupu."""
        self.settings["auto_backup_on_exit"] = self.auto_backup_var.get()
        save_config(self.config)
        logging.info(f"Ustawienie auto-backup zmienione na: {self.auto_backup_var.get()}")

    def find_potential_duplicates(self):
        """Logika wyszukiwania potencjalnych duplikatów."""
        logging.info("Rozpoczynanie wyszukiwania duplikatów...")
        potential_duplicates = {} # { normalized_name: [original_name1, original_name2, ...], ... }
        processed_count = 0
        total_games = len(self.games)

        try:
            for original_name in list(self.games.keys()): # Iteruj po kopii kluczy
                # Aktualizacja postępu (opcjonalna, może spowalniać)
                # processed_count += 1
                # percent = int((processed_count / total_games) * 100) if total_games > 0 else 0
                # self.root.after(0, lambda p=percent, name=original_name: self.update_progress_label(f"{p}% - {name}"))

                normalized = self._normalize_game_name_for_duplicates(original_name)
                if not normalized: # Pomiń, jeśli nazwa po normalizacji jest pusta
                    continue

                if normalized not in potential_duplicates:
                    potential_duplicates[normalized] = []
                potential_duplicates[normalized].append(original_name)

            # Filtruj tylko te, które mają więcej niż jedną grę
            duplicate_groups = {norm_name: games_list
                                for norm_name, games_list in potential_duplicates.items()
                                if len(games_list) > 1}

            logging.info(f"Znaleziono {len(duplicate_groups)} grup potencjalnych duplikatów.")

            # Zatrzymaj pasek postępu i pokaż wyniki
            self.root.after(0, self.stop_scan_progress) # Użyj tej samej funkcji co dla skanowania
            self.root.after(10, lambda groups=duplicate_groups: self.show_duplicate_results(groups))

        except Exception as e:
            logging.exception("Błąd podczas wyszukiwania duplikatów.")
            self.root.after(0, self.stop_scan_progress)
            self.root.after(0, lambda: messagebox.showerror("Błąd", f"Wystąpił błąd podczas szukania duplikatów:\n{e}"))

    # Metoda do aktualizacji etykiety paska postępu (jeśli chcesz)
    # def update_progress_label(self, text):
    #     if hasattr(self, 'progress_label') and self.progress_label.winfo_exists():
    #         self.progress_label.config(text=text)
    #         self.progress_window.update_idletasks()

# W klasie GameLauncher

# W klasie GameLauncher

    def _show_lastfm_key_help(self):
        message = (
            "Jak uzyskać klucz API Last.fm:\n\n"
            "1. Zaloguj się lub załóż konto na [https://www.last.fm](https://www.last.fm)\n"
            "2. Przejdź na stronę [https://www.last.fm/api/account/create](https://www.last.fm/api/account/create)\n"
            "3. Wypełnij formularz (nazwa aplikacji, opis itp.). Nie musisz podawać 'Callback URL', jeśli nie tworzysz aplikacji webowej.\n"
            "4. Po zaakceptowaniu, otrzymasz swój API Key oraz API Secret (Secret nie będzie nam na razie potrzebny do pobierania okładek, ale zachowaj go).\n"
            "5. Skopiuj API Key i wklej go w polu w ustawieniach launchera.\n\n"
            "Klucz API jest wymagany do automatycznego pobierania okładek albumów."
        )
        messagebox.showinfo("Pomoc - Klucz API Last.fm", message, parent=self.settings_page_frame if hasattr(self, 'settings_page_frame') else self.root)

    def _save_lastfm_api_key(self):
        if hasattr(self, 'lastfm_api_key_entry'):
            key = self.lastfm_api_key_entry.get().strip()
            if key:
                self.local_settings["lastfm_api_key"] = key
                save_local_settings(self.local_settings)
                messagebox.showinfo("Sukces", "Klucz API Last.fm został zapisany.", parent=self.settings_page_frame if hasattr(self, 'settings_page_frame') else self.root)
            else:
                if "lastfm_api_key" in self.local_settings:
                    del self.local_settings["lastfm_api_key"]
                    save_local_settings(self.local_settings)
                    messagebox.showinfo("Usunięto", "Klucz API Last.fm został usunięty.", parent=self.settings_page_frame if hasattr(self, 'settings_page_frame') else self.root)
                else:
                    messagebox.showwarning("Brak klucza", "Pole klucza API Last.fm jest puste.", parent=self.settings_page_frame if hasattr(self, 'settings_page_frame') else self.root)

    def show_duplicate_results(self, duplicate_groups):
        """Wyświetla okno z wynikami skanowania duplikatów (z licznikiem zaznaczenia)."""
        if not duplicate_groups:
            messagebox.showinfo("Duplikaty", "Nie znaleziono potencjalnych duplikatów.")
            return

        results_window = tk.Toplevel(self.root)
        results_window.title("Potencjalne Duplikaty Gier")
        results_window.geometry("850x500")
        results_window.configure(bg="#1e1e1e")
        results_window.grab_set()

        ttk.Label(results_window, text="Znaleziono następujące grupy potencjalnych duplikatów:", font=("Helvetica", 12)).pack(pady=10)

        tree_frame = ttk.Frame(results_window)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        columns = ("Nazwa Gry", "Czas Gry", "Data Dodania", "Ścieżka Pliku")
        # --- ZMIANA: Zapisz referencję do Treeview w self ---
        self.duplicate_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", selectmode="extended")
        # --- KONIEC ZMIANY ---

        self.duplicate_tree.heading("Nazwa Gry", text="Nazwa Gry", command=lambda: self._sort_duplicate_tree("Nazwa Gry"))
        self.duplicate_tree.column("Nazwa Gry", width=200, anchor=tk.W)
        self.duplicate_tree.heading("Czas Gry", text="Czas Gry", command=lambda: self._sort_duplicate_tree("Czas Gry"))
        self.duplicate_tree.column("Czas Gry", width=80, anchor=tk.CENTER)
        self.duplicate_tree.heading("Data Dodania", text="Data Dodania", command=lambda: self._sort_duplicate_tree("Data Dodania"))
        self.duplicate_tree.column("Data Dodania", width=110, anchor=tk.CENTER)
        self.duplicate_tree.heading("Ścieżka Pliku", text="Ścieżka Pliku", command=lambda: self._sort_duplicate_tree("Ścieżka Pliku"))
        self.duplicate_tree.column("Ścieżka Pliku", width=300, anchor=tk.W)

        tree_scrollbar = ttk.Scrollbar(tree_frame, orient="vertical", command=self.duplicate_tree.yview)
        self.duplicate_tree.configure(yscrollcommand=tree_scrollbar.set)

        tree_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.duplicate_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        self._duplicate_sort_col = "Nazwa Gry"
        self._duplicate_sort_rev = False

        group_id_counter = 0
        self.duplicate_tree_data = {}
        for normalized_name, game_list in duplicate_groups.items():
            group_iid = f"group_{group_id_counter}"
            self.duplicate_tree.insert("", "end", iid=group_iid, values=(f"--- Grupa: {normalized_name} ({len(game_list)} gry) ---", "", "", ""), tags=('group_header',))
            self.duplicate_tree.tag_configure('group_header', background='#3e3e3e', foreground='white')

            for game_name in game_list:
                game_data = self.games.get(game_name, {})
                exe_path = game_data.get("exe_path", "Brak ścieżki")
                play_time_str = self.format_play_time(game_data.get('play_time', 0))
                try:
                    added_timestamp = game_data.get('date_added')
                    added_date_str = datetime.datetime.fromtimestamp(added_timestamp).strftime('%Y-%m-%d %H:%M') if added_timestamp else ""
                except Exception: added_date_str = ""

                values = (game_name, play_time_str, added_date_str, exe_path)
                self.duplicate_tree.insert(group_iid, "end", iid=game_name, values=values)
                self.duplicate_tree_data[game_name] = game_data

            group_id_counter += 1

        # Przyciski akcji
        action_frame = ttk.Frame(results_window)
        action_frame.pack(pady=10, fill=tk.X)

        # Ramka na przyciski po lewej (Otwórz Lokalizację)
        left_action_frame = ttk.Frame(action_frame)
        left_action_frame.pack(side=tk.LEFT, padx=10)
        ttk.Button(left_action_frame, text="Otwórz Lokalizację", command=self._open_selected_duplicate_location).pack(side=tk.LEFT) # Dodaj side=tk.LEFT

        # --- NOWE: Etykieta licznika zaznaczenia ---
        self.duplicate_count_label = ttk.Label(left_action_frame, text="Zaznaczono: 0 gier")
        self.duplicate_count_label.pack(side=tk.LEFT, padx=10)
        # --- KONIEC NOWEGO ---

        # Ramka na przyciski po prawej (Usuń, Zamknij)
        right_action_frame = ttk.Frame(action_frame)
        right_action_frame.pack(side=tk.RIGHT, padx=10)

        def delete_selected():
            selected_items = self.duplicate_tree.selection()
            games_to_delete = [item for item in selected_items if not item.startswith("group_")]

            if not games_to_delete:
                 messagebox.showwarning("Brak zaznaczenia", "Zaznacz gry, które chcesz usunąć.", parent=results_window)
                 return

            # --- ZMIANA: Uproszczony komunikat ---
            confirm_msg = f"Czy na pewno chcesz usunąć {len(games_to_delete)} zaznaczone gry?"
            # --- KONIEC ZMIANY ---
            if messagebox.askyesno("Potwierdź Usunięcie", confirm_msg, parent=results_window):
                deleted_count = 0
                # ... (reszta logiki usuwania bez zmian) ...
                for game_name_to_delete in games_to_delete:
                     if game_name_to_delete in self.games:
                          try:
                              logging.info(f"Usuwanie duplikatu: {game_name_to_delete}")
                              cover_image = self.games[game_name_to_delete].get("cover_image")
                              if cover_image and os.path.exists(cover_image) and os.path.dirname(os.path.abspath(cover_image)) == os.path.abspath(IMAGES_FOLDER):
                                   os.remove(cover_image)
                              backup_path = os.path.join(GAMES_FOLDER, game_name_to_delete)
                              if os.path.exists(backup_path): shutil.rmtree(backup_path)
                              for group in self.groups.values():
                                  if game_name_to_delete in group: group.remove(game_name_to_delete)
                              del self.games[game_name_to_delete]
                              deleted_count += 1
                          except Exception as e:
                              logging.error(f"Błąd podczas usuwania duplikatu '{game_name_to_delete}': {e}")
                              messagebox.showerror("Błąd Usuwania", f"Nie udało się usunąć gry '{game_name_to_delete}':\n{e}", parent=results_window)

                if deleted_count > 0:
                     save_config(self.config)
                     self.reset_and_update_grid()
                     self.update_tag_filter_options()
                     messagebox.showinfo("Usunięto", f"Usunięto {deleted_count} gier.", parent=results_window.master)
                     results_window.destroy()

        ttk.Button(right_action_frame, text="Usuń Zaznaczone Gry", command=delete_selected).pack(side=tk.LEFT, padx=5)
        ttk.Button(right_action_frame, text="Zamknij", command=results_window.destroy).pack(side=tk.LEFT, padx=5)

        # --- NOWE: Bindowanie zdarzenia zmiany zaznaczenia ---
        self.duplicate_tree.bind('<<TreeviewSelect>>', self._update_duplicate_selection_count)
        # --- KONIEC NOWEGO ---

        # Wywołaj raz na początku, aby pokazać "Zaznaczono: 0 gier"
        self._update_duplicate_selection_count()


    # --- NOWA METODA: Aktualizacja licznika zaznaczenia ---
    def _update_duplicate_selection_count(self, event=None):
        """Aktualizuje etykietę pokazującą liczbę zaznaczonych gier (nie grup)."""
        if hasattr(self, 'duplicate_tree') and self.duplicate_tree.winfo_exists() and \
           hasattr(self, 'duplicate_count_label') and self.duplicate_count_label.winfo_exists():
            try:
                selected_items = self.duplicate_tree.selection()
                game_items = [item for item in selected_items if not item.startswith("group_")]
                count = len(game_items)
                self.duplicate_count_label.config(text=f"Zaznaczono: {count} gier")
            except tk.TclError as e:
                 # Może się zdarzyć, jeśli okno jest niszczone
                 logging.warning(f"Błąd TclError podczas aktualizacji licznika zaznaczenia: {e}")
            except Exception as e:
                 logging.exception("Nieoczekiwany błąd podczas aktualizacji licznika zaznaczenia.")

    # Metoda _sort_duplicate_tree pozostaje bez zmian
    # Metoda _open_selected_duplicate_location pozostaje bez zmian


    # --- NOWA METODA: Sortowanie Treeview duplikatów ---
    def _sort_duplicate_tree(self, column_name):
        """Sortuje dane w Treeview okna duplikatów."""
        if not hasattr(self, 'duplicate_tree') or not self.duplicate_tree.winfo_exists():
            return

        # Odwróć kierunek, jeśli kliknięto tę samą kolumnę
        reverse_sort = self._duplicate_sort_rev
        if column_name == self._duplicate_sort_col:
            reverse_sort = not reverse_sort
        else:
            self._duplicate_sort_col = column_name
            reverse_sort = False
        self._duplicate_sort_rev = reverse_sort

        # Zbierz wszystkie elementy (gry, nie nagłówki grup) z ich danymi
        items_to_sort = []
        for iid in self.duplicate_tree_data: # Użyj słownika danych
            if not iid.startswith("group_") and iid in self.duplicate_tree_data:
                 # Pobierz wartości bezpośrednio z self.duplicate_tree_data dla spójności
                 game_data = self.duplicate_tree_data[iid]
                 items_to_sort.append((iid, game_data))

        # Zdefiniuj funkcję klucza sortowania
        key_func = None
        if column_name == "Nazwa Gry":
            key_func = lambda item: item[0].lower() # item[0] to iid (nazwa gry)
        elif column_name == "Czas Gry":
            key_func = lambda item: item[1].get('play_time', 0) # item[1] to game_data
        elif column_name == "Data Dodania":
            key_func = lambda item: item[1].get('date_added', 0)
        elif column_name == "Ścieżka Pliku":
            key_func = lambda item: item[1].get('exe_path', '').lower()

        if not key_func: return # Nieznana kolumna

        # Posortuj listę (iid, game_data)
        items_to_sort.sort(key=key_func, reverse=reverse_sort)

        # Przenieś elementy w Treeview zgodnie z nową kolejnością
        # WAŻNE: Musimy zachować strukturę grup! Przenosimy tylko elementy wewnątrz grup.
        for group_iid in self.duplicate_tree.get_children(""): # Iteruj po nagłówkach grup
            # Zbierz dzieci (gry) tej grupy
            group_children_iids = self.duplicate_tree.get_children(group_iid)
            # Odfiltruj posortowane elementy, które należą do tej grupy
            sorted_children_in_group = [item[0] for item in items_to_sort if item[0] in group_children_iids]
            # Przenieś dzieci w nowej kolejności
            for i, child_iid in enumerate(sorted_children_in_group):
                self.duplicate_tree.move(child_iid, group_iid, i)

        # Zaktualizuj wskaźniki sortowania w nagłówkach (opcjonalnie)
        for col in self.duplicate_tree['columns']:
            text = col
            if col == column_name:
                text += " ▲" if not reverse_sort else " ▼"
            self.duplicate_tree.heading(col, text=text)

    # --- NOWA METODA: Otwieranie lokalizacji ---
    def _open_selected_duplicate_location(self):
        """Otwiera folder zawierający plik .exe zaznaczonej gry."""
        selection = self.duplicate_tree.selection()
        if not selection:
            messagebox.showwarning("Brak zaznaczenia", "Zaznacz grę, której lokalizację chcesz otworzyć.", parent=self.root) # Użyj self.root jako parent
            return
        if len(selection) > 1:
            messagebox.showwarning("Wiele zaznaczonych", "Zaznacz tylko jedną grę, aby otworzyć jej lokalizację.", parent=self.root)
            return

        selected_iid = selection[0]
        if selected_iid.startswith("group_"):
             messagebox.showwarning("Zaznaczono grupę", "Zaznacz konkretną grę, a nie nagłówek grupy.", parent=self.root)
             return

        game_data = self.duplicate_tree_data.get(selected_iid)
        if not game_data:
             messagebox.showerror("Błąd", f"Nie znaleziono danych dla gry: {selected_iid}", parent=self.root)
             return

        exe_path = game_data.get("exe_path")
        if not exe_path or not os.path.exists(exe_path):
             messagebox.showerror("Brak ścieżki", f"Nie można zlokalizować pliku wykonywalnego dla gry: {selected_iid}\nŚcieżka: {exe_path}", parent=self.root)
             return

        folder_path = os.path.dirname(exe_path)
        try:
             if sys.platform == "win32":
                 # Użyj startfile dla Windows
                 os.startfile(os.path.normpath(folder_path))
             elif sys.platform == "darwin": # macOS
                 subprocess.run(['open', folder_path])
             else: # linux variants
                 subprocess.run(['xdg-open', folder_path])
             logging.info(f"Otwieranie folderu: {folder_path}")
        except Exception as e:
             logging.error(f"Nie można otworzyć folderu '{folder_path}': {e}")
             messagebox.showerror("Błąd", f"Nie można otworzyć folderu:\n{folder_path}\n\nBłąd: {e}", parent=self.root)

    def load_ignored_folders(self):
        """Wczytuje listę ignorowanych folderów do pola Text w ustawieniach."""
        if hasattr(self, 'ignored_folders_text') and self.ignored_folders_text.winfo_exists():
            ignored_list = self.settings.get("scan_ignore_folders", []) # Nowy klucz w settings
            # Wyczyść stare dane
            self.ignored_folders_text.delete("1.0", tk.END)
            # Wstaw nowe, każda nazwa w nowej linii
            self.ignored_folders_text.insert("1.0", "\n".join(ignored_list))

    def save_ignored_folders(self):
        """Pobiera nazwy z pola Text, czyści je i zapisuje do konfiguracji."""
        if hasattr(self, 'ignored_folders_text') and self.ignored_folders_text.winfo_exists():
            # Pobierz cały tekst
            raw_text = self.ignored_folders_text.get("1.0", tk.END)
            # Podziel na linie, usuń białe znaki z każdej i odfiltruj puste linie
            ignored_list = [line.strip().lower() for line in raw_text.splitlines() if line.strip()]
            # Zapisz unikalne wartości (konwersja na set i z powrotem na listę)
            unique_ignored_list = sorted(list(set(ignored_list)))

            self.settings["scan_ignore_folders"] = unique_ignored_list
            save_config(self.config)
            # Przeładuj, aby pokazać posortowaną i oczyszczoną listę
            self.load_ignored_folders()
            messagebox.showinfo("Zapisano", "Lista ignorowanych folderów została zapisana.")
            logging.info(f"Zapisano ignorowane foldery: {unique_ignored_list}")

    def _sort_list_view_by_column(self, column_name):
        """Sortuje dane w widoku listy po kliknięciu nagłówka kolumny."""
        if self.library_view_mode.get() != 'list': return

        # ... (logika ustalania reverse_sort i _list_sort_column) ...
        reverse_sort = False
        if column_name == self._list_sort_column: reverse_sort = not self._list_sort_reverse
        else: self._list_sort_column = column_name; reverse_sort = False
        self._list_sort_reverse = reverse_sort


        # --- ZMIANA: Użyj filter_or_group_var i rozpoznaj typ ---
        selected_filter_or_group = self.filter_or_group_var.get()
        is_static_group = selected_filter_or_group in self.groups
        is_advanced_filter = selected_filter_or_group in self.config.get("saved_filters", {})
        # --- KONIEC ZMIANY ---

        # Pobierz aktualne filtry (Gatunek, Tag, Typ Gry)
        search_query = self.search_var.get().lower()
        selected_genre = self.filter_var.get()
        selected_tag = self.tag_filter_var.get().strip()
        selected_game_type_filter = self.game_type_filter_var.get()

        # --- ZMIANA: Logika filtrowania listy do posortowania ---
        games_to_sort = []
        if is_static_group:
             games_to_sort = list(self.groups.get(selected_filter_or_group, [])) # Użyj gier z grupy
        elif is_advanced_filter:
             # TODO: Zastosuj reguły filtra zaawansowanego (na razie weź wszystkie)
             logging.debug(f"Sortowanie listy dla filtra zaawansowanego '{selected_filter_or_group}' (logika filtrowania TODO).")
             games_to_sort = list(self.games.keys())
        else: # "Wszystkie Gry" lub separator
             games_to_sort = list(self.games.keys())

        # Zastosuj pozostałe filtry do listy `games_to_sort`
        filtered_names = []
        for game_name in games_to_sort:
            game_data = self.games.get(game_name)
            if not game_data: continue

            # --- TODO: Wstaw tutaj kod sprawdzania reguł filtra, jeśli is_advanced_filter ---
            # if is_advanced_filter:
            #     if not self._check_game_against_rules(...): continue

            # Filtrowanie po typie gry
            game_type = game_data.get("game_type", "pc")
            type_match = False
            if selected_game_type_filter == "Wszystkie Typy": type_match = True
            elif selected_game_type_filter == "Gry PC" and game_type == "pc": type_match = True
            elif selected_game_type_filter == "Gry Emulowane" and game_type == "emulator": type_match = True
            if not type_match: continue

            # Pozostałe filtry
            if search_query and search_query not in game_name.lower(): continue
            if selected_genre != "Wszystkie Gatunki" and selected_genre not in game_data.get("genres", []): continue
            if selected_tag and selected_tag != "Wszystkie Tagi":
                 if not any(selected_tag.lower() == tag.lower() for tag in game_data.get("tags", [])): continue

            filtered_names.append(game_name)
        # --- KONIEC ZMIANY ---


        # Pobierz klucz sortowania (bez zmian)
        key_func = None
        # ... (definicja key_func jak poprzednio) ...
        if column_name == "Nazwa": key_func = lambda name: name.lower()
        elif column_name == "Czas Gry": key_func = lambda name: self.games.get(name, {}).get('play_time', 0)
        elif column_name == "Ocena": key_func = lambda name: self.games.get(name, {}).get('rating') or -1
        elif column_name == "Data Dodania": key_func = lambda name: self.games.get(name, {}).get('date_added', 0)
        elif column_name == "Wersja": key_func = lambda name: self.games.get(name, {}).get('version', '').lower()
        elif column_name == "Gatunki": key_func = lambda name: ", ".join(self.games.get(name, {}).get('genres', [])).lower()
        elif column_name == "Tagi": key_func = lambda name: ", ".join(self.games.get(name, {}).get('tags', [])).lower()


        if key_func:
             # Posortuj przefiltrowaną listę `filtered_names`
             sorted_games = sorted(filtered_names, key=key_func, reverse=reverse_sort)

             # Wyczyść i wypełnij Treeview posortowanymi danymi (bez zmian)
             self.list_view_tree.delete(*self.list_view_tree.get_children())
             for game_name in sorted_games:
                  # ... (kod wstawiania do Treeview) ...
                    game_data = self.games.get(game_name);
                    if game_data:
                        play_time_str = self.format_play_time(game_data.get('play_time', 0)); rating_str = str(game_data.get('rating', ''))
                        genres_str = ", ".join(game_data.get('genres', [])); version_str = game_data.get('version', ''); tags_str = ", ".join(game_data.get('tags', []))
                        try: added_timestamp = game_data.get('date_added'); added_date_str = datetime.datetime.fromtimestamp(added_timestamp).strftime('%Y-%m-%d %H:%M') if added_timestamp else ""
                        except Exception: added_date_str = ""
                        values = (game_name, play_time_str, rating_str, genres_str, version_str, tags_str, added_date_str)
                        self.list_view_tree.insert("", "end", iid=game_name, values=values)


             # Zaktualizuj wskaźnik sortowania w nagłówku (bez zmian)
             # ... (kod aktualizacji nagłówków) ...
             for col in self.list_view_tree['columns']:
                  text = col;
                  if col == column_name: text += " ▲" if not reverse_sort else " ▼"
                  self.list_view_tree.heading(col, text=text)


    def _on_list_view_double_click(self, event):
        """Obsługuje podwójne kliknięcie na elemencie listy."""
        item_iid = self.list_view_tree.focus()
        if item_iid and item_iid in self.games:
            logging.info(f"Podwójne kliknięcie na: {item_iid}")
            # Zamiast: self.launch_game(item_iid)
            self.show_game_details(item_iid) # Otwórz okno szczegółów
        else:
            logging.warning(f"Podwójne kliknięcie na nieznany element: {item_iid}")

    def show_game_details(self, game_name):
        """Otwiera okno ze szczegółami wybranej gry."""
        # Sprawdź, czy okno dla tej gry już nie jest otwarte (proste sprawdzenie po tytule)
        details_title = f"Szczegóły Gry - {game_name}"
        for widget in self.root.winfo_children():
             if isinstance(widget, tk.Toplevel) and widget.title() == details_title:
                 logging.debug(f"Okno szczegółów dla '{game_name}' już otwarte. Podnoszenie.")
                 widget.lift()
                 widget.focus_force()
                 return # Nie twórz nowego

        logging.info(f"Otwieranie okna szczegółów dla: {game_name}")
        GameDetailsWindow(self.root, self, game_name) # Utwórz nowe okno

# W klasie GameLauncher

    def _apply_overlay_position_from_settings(self):
        """Zapisuje i stosuje pozycję overlay'a z pól w ustawieniach."""
        try:
            new_x = self.overlay_x_pos_var.get()
            new_y = self.overlay_y_pos_var.get()
            
            self.local_settings["overlay_x_pos"] = new_x
            self.local_settings["overlay_y_pos"] = new_y
            save_local_settings(self.local_settings)
            logging.info(f"Zapisano nową pozycję overlay'a z ustawień: X={new_x}, Y={new_y}")

            if hasattr(self, 'track_overlay') and self.track_overlay and self.track_overlay.winfo_exists():
                self.track_overlay.x_pos = new_x # Zaktualizuj wewnętrzne zmienne overlay'a
                self.track_overlay.y_pos = new_y
                self.track_overlay.geometry(f"{self.track_overlay.width}x{self.track_overlay.height}+{new_x}+{new_y}")
                self.track_overlay.lift() # Na wszelki wypadek
        except tk.TclError:
            messagebox.showerror("Błąd Wartości", "Pozycja X i Y muszą być liczbami całkowitymi.", parent=self.settings_page_frame)
        except Exception as e:
            logging.error(f"Błąd podczas stosowania pozycji overlay'a: {e}")

    def _reset_overlay_position(self):
        """Resetuje pozycję overlay'a do wartości domyślnych i zapisuje."""
        if hasattr(self, 'track_overlay') and self.track_overlay: # Potrzebujemy dostępu do wymiarów overlay'a
            screen_w = self.track_overlay.winfo_screenwidth()
            screen_h = self.track_overlay.winfo_screenheight()
            overlay_w = self.track_overlay.width
            overlay_h = self.track_overlay.height
        else: # Fallback, jeśli overlay nie istnieje
            screen_w = self.root.winfo_screenwidth()
            screen_h = self.root.winfo_screenheight()
            overlay_w = 300 # Użyj domyślnych szerokości
            overlay_h = 70
        
        default_x = screen_w - overlay_w - 20
        default_y = screen_h - overlay_h - 60 

        self.overlay_x_pos_var.set(default_x)
        self.overlay_y_pos_var.set(default_y)
        
        self.local_settings["overlay_x_pos"] = default_x
        self.local_settings["overlay_y_pos"] = default_y
        save_local_settings(self.local_settings)
        logging.info("Zresetowano pozycję overlay'a do domyślnej.")
        
        # Zastosuj od razu
        self._apply_overlay_position_from_settings()
        messagebox.showinfo("Reset Pozycji", "Pozycja nakładki została zresetowana.", parent=self.settings_page_frame)

    def _on_list_view_right_click(self, event):
        """Wyświetla menu kontekstowe dla widoku listy (z ikonami)."""
        # Identyfikuj wiersz pod kursorem
        item_iid = self.list_view_tree.identify_row(event.y)
        if not item_iid: return # Kliknięto poza elementem

        # Zaznacz kliknięty element, jeśli jeszcze nie jest zaznaczony
        if item_iid not in self.list_view_tree.selection():
             # Usuń poprzednie zaznaczenie i zaznacz nowe
             self.list_view_tree.selection_set(item_iid)
        # Ustaw fokus na klikniętym elemencie
        self.list_view_tree.focus(item_iid)

        if item_iid in self.games: # Upewnij się, że to gra
             game_name = item_iid
             game_data = self.games[game_name]
             save_path = game_data.get("save_path")
             is_save_path_valid = save_path and os.path.isdir(save_path)

             context_menu = tk.Menu(self.root, tearoff=0, background="#2e2e2e", foreground="white")

             # --- Opcja Uruchom/Uruchom z profilem (z ikoną) ---
             profiles = game_data.get("launch_profiles", [])
             play_icon = self._button_icons.get('play_menu') # Użyj ikony 'play_menu'

             if profiles:
                 if len(profiles) == 1 and profiles[0].get("name", "").lower() == "default":
                      context_menu.add_command(label="Uruchom", command=lambda: self.launch_game(game_name),
                                               image=play_icon, compound=tk.LEFT)
                 else:
                      launch_menu = tk.Menu(context_menu, tearoff=0, background="#2e2e2e", foreground="white")
                      context_menu.add_cascade(label="Uruchom z profilem...", menu=launch_menu,
                                               image=play_icon, compound=tk.LEFT)
                      for profile in profiles:
                           profile_name = profile.get("name", "Brak nazwy")
                           cmd = lambda p=profile: self.launch_game(game_name, profile=p)
                           launch_menu.add_command(label=profile_name, command=cmd) # Bez ikon w podmenu
                 context_menu.add_separator()
             else: # Fallback
                  context_menu.add_command(label="Uruchom", command=lambda: self.launch_game(game_name),
                                           image=play_icon, compound=tk.LEFT)
                  context_menu.add_separator()

             # --- Pozostałe opcje z ikonami ---
             context_menu.add_command(label="Edytuj dane", command=lambda: self.edit_game(game_name),
                                      image=self._button_icons.get('edit'), compound=tk.LEFT)
             context_menu.add_command(label="Otwórz folder z zapisami", command=lambda p=save_path: self._open_folder(p),
                                      state=tk.NORMAL if is_save_path_valid else tk.DISABLED,
                                      image=self._button_icons.get('folder_open'), compound=tk.LEFT)
             context_menu.add_command(label="Zarządzaj zapisami", command=lambda: self.manage_saves(game_name),
                                      image=self._button_icons.get('save_disk'), compound=tk.LEFT)
             # --- NOWE: Skróty do zakładek (Z IKONAMI) ---
             context_menu.add_command(label="Pokaż Checklistę", command=lambda gn=game_name: self._show_game_details_and_select_tab(gn, "Checklista"),
                                      image=self._button_icons.get('checklist'), compound=tk.LEFT) # Dodano ikonę
             context_menu.add_command(label="Pokaż Screenshoty", command=lambda gn=game_name: self._show_game_details_and_select_tab(gn, "Screenshoty"),
                                      image=self._button_icons.get('screenshot'), compound=tk.LEFT) # Dodano ikonę
             # --- KONIEC NOWEGO ---
             if hasattr(self, 'extended_mod_manager'):
                 context_menu.add_command(label="Mody", command=lambda gn=game_name: self._show_mods_for_game_from_context(gn),
                                          image=self._button_icons.get('mods'), compound=tk.LEFT)

             # Opcje grup (z ikonami)
             if self.groups:
                 group_menu_add = tk.Menu(context_menu, tearoff=0, background="#2e2e2e", foreground="white")
                 context_menu.add_cascade(label="Dodaj do grupy...", menu=group_menu_add,
                                          image=self._button_icons.get('group_add'), compound=tk.LEFT)
                 can_add_to_any = False
                 for group_name in sorted(self.groups.keys()):
                      is_in_group = game_name in self.groups.get(group_name, [])
                      state = tk.DISABLED if is_in_group else tk.NORMAL
                      cmd = lambda gn=game_name, grp=group_name: self._add_to_group_from_menu(gn, grp)
                      group_menu_add.add_command(label=group_name, command=cmd, state=state)
                      if not is_in_group: can_add_to_any = True
                 if not can_add_to_any: context_menu.entryconfig("Dodaj do grupy...", state=tk.DISABLED)

                 groups_game_is_in = [grp for grp, games in self.groups.items() if game_name in games]
                 if groups_game_is_in:
                      remove_group_menu = tk.Menu(context_menu, tearoff=0, background="#2e2e2e", foreground="white")
                      context_menu.add_cascade(label="Usuń z grupy...", menu=remove_group_menu,
                                               image=self._button_icons.get('group_remove'), compound=tk.LEFT)
                      for group_name in sorted(groups_game_is_in):
                           cmd = lambda gn=game_name, grp=group_name: self._remove_from_group_from_menu(gn, grp)
                           remove_group_menu.add_command(label=group_name, command=cmd)

             context_menu.add_command(label="Resetuj statystyki", command=lambda: self.reset_stats(game_name),
                                      image=self._button_icons.get('reset'), compound=tk.LEFT)
             context_menu.add_separator()
             context_menu.add_command(label="Usuń grę", command=lambda: self.delete_game(game_name),
                                      image=self._button_icons.get('delete'), compound=tk.LEFT)
             # --- Koniec opcji z ikonami ---

             context_menu.post(event.x_root, event.y_root)
        else:
             logging.warning(f"Kliknięto prawym na nieznany element listy: {item_iid}")

    # Metoda pomocnicza dla menu kontekstowego
    def _add_to_group_from_menu(self, game_name, group_name):
         """Dodaje grę do grupy wybranej z menu kontekstowego."""
         if game_name not in self.groups[group_name]:
             self.groups[group_name].append(game_name)
             save_config(self.config)
             messagebox.showinfo("Sukces", f"Gra '{game_name}' została dodana do grupy '{group_name}'.")
             # Odświeżenie siatki nie jest konieczne, jeśli nie jesteśmy w widoku tej grupy
         else:
              messagebox.showwarning("Błąd", f"Gra '{game_name}' już znajduje się w grupie '{group_name}'.")

    def toggle_show_key(self, entry_widget, show_var):
        """Przełącza widoczność hasła/klucza w danym polu Entry."""
        if show_var.get():
            entry_widget.config(show='')
        else:
            entry_widget.config(show='*')

    def save_rawg_api_key(self):
        """Zapisuje klucz API RAWG do ustawień lokalnych."""
        key = self.rawg_api_key_entry.get().strip()
        if key:
            self.local_settings["rawg_api_key"] = key
            save_local_settings(self.local_settings)
            messagebox.showinfo("Sukces", "Klucz API RAWG został zapisany.")
        else:
            # Opcjonalnie: Usuń klucz, jeśli pole jest puste
            if "rawg_api_key" in self.local_settings:
                del self.local_settings["rawg_api_key"]
                save_local_settings(self.local_settings)
                messagebox.showinfo("Usunięto", "Klucz API RAWG został usunięty.")
            else:
                messagebox.showwarning("Brak klucza", "Pole klucza API RAWG jest puste.")

    def show_rawg_key_help(self):
        """Wyświetla pomoc dotyczącą klucza RAWG API."""
        message = (
            "Jak uzyskać klucz RAWG API:\n\n"
            "1. Zarejestruj się lub zaloguj na stronie: https://rawg.io/\n"
            "2. Przejdź do strony swojego profilu (kliknij na awatar).\n"
            "3. W sekcji 'API key' znajdziesz swój klucz.\n"
            "4. Skopiuj klucz i wklej go w polu powyżej.\n\n"
            "Klucz API jest wymagany do pobierania szczegółowych informacji o grach."
        )
        # Użyj self.root jako rodzica dla okna ustawień
        parent_window = self.settings_page_frame if hasattr(self, 'settings_page_frame') else self.root
        messagebox.showinfo("Pomoc - Klucz RAWG API", message, parent=parent_window)
from .shared_imports import *  # noqa: F401,F403
from .constants import (
    MONTH_COLORS,
    DEFAULT_MUSIC_HOTKEYS,
    MONTH_NAMES_PL,
    resampling,
    PROGRAM_VERSION,
    CONFIG_FILE,
    GAMES_FOLDER,
    IMAGES_FOLDER,
    INTERNAL_MUSIC_DIR,
    CUSTOM_THEMES_DIR,
    LOCAL_SETTINGS_FILE,
    THEMES,
)
from .utils import (
    get_contrast_color,
    _load_theme_from_file,
    load_local_settings,
    save_local_settings,
    load_config,
    save_config,
    create_default_cover,
    load_photoimage_from_path,
)
from .overlay import TrackOverlayWindow
from .translator import DummyTranslator
from .genres import ManageGenresWindow
from .mods import ExtendedModManager
from .forms import (
    GameForm,
    SaveManager,
    GameDetailsWindow,
    AddProfileDialog,
    ScanVerificationWindow,
    AchievementForm,
    ThemeEditorWindow,
)
from .filters import AdvancedFilterManager, FilterEditorWindow, RuleEditor
from .music import MusicPlayerPage
from .tooltip import ToolTip
from .chat import ChatServerEditorDialog


